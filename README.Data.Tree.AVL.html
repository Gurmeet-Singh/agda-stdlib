<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.Tree.AVL</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Some examples showing how the AVL tree module can be used</a>
<a id="167" class="Comment">------------------------------------------------------------------------</a>

<a id="241" class="Symbol">{-#</a> <a id="245" class="Keyword">OPTIONS</a> <a id="253" class="Pragma">--cubical-compatible</a> <a id="274" class="Pragma">--safe</a> <a id="281" class="Symbol">#-}</a>

<a id="286" class="Keyword">module</a> <a id="293" href="README.Data.Tree.AVL.html" class="Module">README.Data.Tree.AVL</a> <a id="314" class="Keyword">where</a>

<a id="321" class="Comment">------------------------------------------------------------------------</a>
<a id="394" class="Comment">-- Setup</a>

<a id="404" class="Comment">-- AVL trees are defined in Data.Tree.AVL.</a>

<a id="448" class="Keyword">import</a> <a id="455" href="Data.Tree.AVL.html" class="Module">Data.Tree.AVL</a>

<a id="470" class="Comment">-- This module is parametrised by keys, which have to form a (strict)</a>
<a id="540" class="Comment">-- total order, and values, which are indexed by keys. Let us use</a>
<a id="606" class="Comment">-- natural numbers as keys and vectors of strings as values.</a>

<a id="668" class="Keyword">open</a> <a id="673" class="Keyword">import</a> <a id="680" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="700" class="Keyword">using</a> <a id="706" class="Symbol">(</a><a id="707" href="Data.Nat.Properties.html#11471" class="Function">&lt;-strictTotalOrder</a><a id="725" class="Symbol">)</a>
<a id="727" class="Keyword">open</a> <a id="732" class="Keyword">import</a> <a id="739" href="Data.Product.html" class="Module">Data.Product</a> <a id="752" class="Symbol">as</a> <a id="755" class="Module">Prod</a> <a id="760" class="Keyword">using</a> <a id="766" class="Symbol">(</a><a id="767" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="770" class="Symbol">;</a> <a id="772" href="Data.Product.Base.html#1686" class="Function Operator">_,′_</a><a id="776" class="Symbol">)</a>
<a id="778" class="Keyword">open</a> <a id="783" class="Keyword">import</a> <a id="790" href="Data.String.html" class="Module">Data.String</a> <a id="802" class="Keyword">using</a> <a id="808" class="Symbol">(</a><a id="809" href="Agda.Builtin.String.html#318" class="Postulate">String</a><a id="815" class="Symbol">)</a>
<a id="817" class="Keyword">open</a> <a id="822" class="Keyword">import</a> <a id="829" href="Data.Vec.html" class="Module">Data.Vec</a> <a id="838" class="Keyword">using</a> <a id="844" class="Symbol">(</a><a id="845" href="Data.Vec.Base.html#1086" class="Datatype">Vec</a><a id="848" class="Symbol">;</a> <a id="850" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">_∷_</a><a id="853" class="Symbol">;</a> <a id="855" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a><a id="857" class="Symbol">)</a>
<a id="859" class="Keyword">open</a> <a id="864" class="Keyword">import</a> <a id="871" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="910" class="Keyword">open</a> <a id="915" href="Data.Tree.AVL.html" class="Module">Data.Tree.AVL</a> <a id="929" href="Data.Nat.Properties.html#11471" class="Function">&lt;-strictTotalOrder</a> <a id="948" class="Keyword">renaming</a> <a id="957" class="Symbol">(</a><a id="958" href="Data.Tree.AVL.html#1576" class="Datatype">Tree</a> <a id="963" class="Symbol">to</a> <a id="966" class="Datatype">Tree′</a><a id="971" class="Symbol">)</a>
<a id="Tree"></a><a id="973" href="README.Data.Tree.AVL.html#973" class="Function">Tree</a> <a id="978" class="Symbol">=</a> <a id="980" href="README.Data.Tree.AVL.html#966" class="Datatype">Tree′</a> <a id="986" class="Symbol">(</a><a id="987" href="Data.Tree.AVL.Value.html#702" class="InductiveConstructor">MkValue</a> <a id="995" class="Symbol">(</a><a id="996" href="Data.Vec.Base.html#1086" class="Datatype">Vec</a> <a id="1000" href="Agda.Builtin.String.html#318" class="Postulate">String</a><a id="1006" class="Symbol">)</a> <a id="1008" class="Symbol">(</a><a id="1009" href="Relation.Binary.PropositionalEquality.Core.html#1808" class="Function">subst</a> <a id="1015" class="Symbol">(</a><a id="1016" href="Data.Vec.Base.html#1086" class="Datatype">Vec</a> <a id="1020" href="Agda.Builtin.String.html#318" class="Postulate">String</a><a id="1026" class="Symbol">)))</a>

<a id="1031" class="Comment">------------------------------------------------------------------------</a>
<a id="1104" class="Comment">-- Construction of trees</a>

<a id="1130" class="Comment">-- Some values.</a>

<a id="v₁"></a><a id="1147" href="README.Data.Tree.AVL.html#1147" class="Function">v₁</a>  <a id="1151" class="Symbol">=</a> <a id="1153" class="String">&quot;cepa&quot;</a> <a id="1160" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="1162" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a>
<a id="v₁′"></a><a id="1165" href="README.Data.Tree.AVL.html#1165" class="Function">v₁′</a> <a id="1169" class="Symbol">=</a> <a id="1171" class="String">&quot;depa&quot;</a> <a id="1178" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="1180" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a>
<a id="v₂"></a><a id="1183" href="README.Data.Tree.AVL.html#1183" class="Function">v₂</a>  <a id="1187" class="Symbol">=</a> <a id="1189" class="String">&quot;apa&quot;</a> <a id="1195" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="1197" class="String">&quot;bepa&quot;</a> <a id="1204" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="1206" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a>

<a id="1210" class="Comment">-- Empty and singleton trees.</a>

<a id="t₀"></a><a id="1241" href="README.Data.Tree.AVL.html#1241" class="Function">t₀</a> <a id="1244" class="Symbol">:</a> <a id="1246" href="README.Data.Tree.AVL.html#973" class="Function">Tree</a>
<a id="1251" href="README.Data.Tree.AVL.html#1241" class="Function">t₀</a> <a id="1254" class="Symbol">=</a> <a id="1256" href="Data.Tree.AVL.html#1746" class="Function">empty</a>

<a id="t₁"></a><a id="1263" href="README.Data.Tree.AVL.html#1263" class="Function">t₁</a> <a id="1266" class="Symbol">:</a> <a id="1268" href="README.Data.Tree.AVL.html#973" class="Function">Tree</a>
<a id="1273" href="README.Data.Tree.AVL.html#1263" class="Function">t₁</a> <a id="1276" class="Symbol">=</a> <a id="1278" href="Data.Tree.AVL.html#1802" class="Function">singleton</a> <a id="1288" class="Number">2</a> <a id="1290" href="README.Data.Tree.AVL.html#1183" class="Function">v₂</a>

<a id="1294" class="Comment">-- Insertion of a key-value pair into a tree.</a>

<a id="t₂"></a><a id="1341" href="README.Data.Tree.AVL.html#1341" class="Function">t₂</a> <a id="1344" class="Symbol">=</a> <a id="1346" href="Data.Tree.AVL.html#1903" class="Function">insert</a> <a id="1353" class="Number">1</a> <a id="1355" href="README.Data.Tree.AVL.html#1147" class="Function">v₁</a> <a id="1358" href="README.Data.Tree.AVL.html#1263" class="Function">t₁</a>

<a id="1362" class="Comment">-- If you insert a key-value pair and the key already exists in the</a>
<a id="1430" class="Comment">-- tree, then the old value is thrown away.</a>

<a id="t₂′"></a><a id="1475" href="README.Data.Tree.AVL.html#1475" class="Function">t₂′</a> <a id="1479" class="Symbol">=</a> <a id="1481" href="Data.Tree.AVL.html#1903" class="Function">insert</a> <a id="1488" class="Number">1</a> <a id="1490" href="README.Data.Tree.AVL.html#1165" class="Function">v₁′</a> <a id="1494" href="README.Data.Tree.AVL.html#1341" class="Function">t₂</a>

<a id="1498" class="Comment">-- Deletion of the mapping for a certain key.</a>

<a id="t₃"></a><a id="1545" href="README.Data.Tree.AVL.html#1545" class="Function">t₃</a> <a id="1548" class="Symbol">=</a> <a id="1550" href="Data.Tree.AVL.html#2190" class="Function">delete</a> <a id="1557" class="Number">2</a> <a id="1559" href="README.Data.Tree.AVL.html#1341" class="Function">t₂</a>

<a id="1563" class="Comment">-- Conversion of a list of key-value mappings to a tree.</a>

<a id="1621" class="Keyword">open</a> <a id="1626" class="Keyword">import</a> <a id="1633" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="1648" class="Keyword">using</a> <a id="1654" class="Symbol">(</a><a id="1655" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">_∷_</a><a id="1658" class="Symbol">;</a> <a id="1660" href="Data.List.Base.html#7375" class="InductiveConstructor">[]</a><a id="1662" class="Symbol">)</a>

<a id="t₄"></a><a id="1665" href="README.Data.Tree.AVL.html#1665" class="Function">t₄</a> <a id="1668" class="Symbol">:</a> <a id="1670" href="README.Data.Tree.AVL.html#973" class="Function">Tree</a>
<a id="1675" href="README.Data.Tree.AVL.html#1665" class="Function">t₄</a> <a id="1678" class="Symbol">=</a> <a id="1680" href="Data.Tree.AVL.html#3316" class="Function">fromList</a> <a id="1689" class="Symbol">((</a><a id="1691" class="Number">2</a> <a id="1693" href="Data.Tree.AVL.Value.html#950" class="InductiveConstructor Operator">,</a> <a id="1695" href="README.Data.Tree.AVL.html#1183" class="Function">v₂</a><a id="1697" class="Symbol">)</a> <a id="1699" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1701" class="Symbol">(</a><a id="1702" class="Number">1</a> <a id="1704" href="Data.Tree.AVL.Value.html#950" class="InductiveConstructor Operator">,</a> <a id="1706" href="README.Data.Tree.AVL.html#1147" class="Function">v₁</a><a id="1708" class="Symbol">)</a> <a id="1710" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1712" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="1714" class="Symbol">)</a>

<a id="1717" class="Comment">------------------------------------------------------------------------</a>
<a id="1790" class="Comment">-- Queries</a>

<a id="1802" class="Comment">-- Let us formulate queries as unit tests.</a>

<a id="1846" class="Keyword">open</a> <a id="1851" class="Keyword">import</a> <a id="1858" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1896" class="Keyword">using</a> <a id="1902" class="Symbol">(</a><a id="1903" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="1906" class="Symbol">;</a> <a id="1908" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="1912" class="Symbol">)</a>

<a id="1915" class="Comment">-- Searching for a key.</a>

<a id="1940" class="Keyword">open</a> <a id="1945" class="Keyword">import</a> <a id="1952" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a> <a id="1967" class="Keyword">using</a> <a id="1973" class="Symbol">(</a><a id="1974" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a><a id="1978" class="Symbol">;</a> <a id="1980" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a><a id="1985" class="Symbol">)</a>
<a id="1987" class="Keyword">open</a> <a id="1992" class="Keyword">import</a> <a id="1999" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="2015" class="Symbol">as</a> <a id="2018" class="Module">Maybe</a> <a id="2024" class="Keyword">using</a> <a id="2030" class="Symbol">(</a><a id="2031" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a><a id="2035" class="Symbol">;</a> <a id="2037" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a><a id="2044" class="Symbol">)</a>

<a id="q₀"></a><a id="2047" href="README.Data.Tree.AVL.html#2047" class="Function">q₀</a> <a id="2050" class="Symbol">:</a> <a id="2052" href="Data.Tree.AVL.html#2293" class="Function">lookup</a> <a id="2059" href="README.Data.Tree.AVL.html#1341" class="Function">t₂</a> <a id="2062" class="Number">2</a> <a id="2064" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2066" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2071" href="README.Data.Tree.AVL.html#1183" class="Function">v₂</a>
<a id="2074" href="README.Data.Tree.AVL.html#2047" class="Function">q₀</a> <a id="2077" class="Symbol">=</a> <a id="2079" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="q₁"></a><a id="2085" href="README.Data.Tree.AVL.html#2085" class="Function">q₁</a> <a id="2088" class="Symbol">:</a> <a id="2090" href="Data.Tree.AVL.html#2293" class="Function">lookup</a> <a id="2097" href="README.Data.Tree.AVL.html#1545" class="Function">t₃</a> <a id="2100" class="Number">2</a> <a id="2102" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2104" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>
<a id="2112" href="README.Data.Tree.AVL.html#2085" class="Function">q₁</a> <a id="2115" class="Symbol">=</a> <a id="2117" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="q₂"></a><a id="2123" href="README.Data.Tree.AVL.html#2123" class="Function">q₂</a> <a id="2126" class="Symbol">:</a> <a id="2128" class="Symbol">(</a><a id="2129" class="Number">3</a> <a id="2131" href="Data.Tree.AVL.html#5873" class="Function Operator">∈?</a> <a id="2134" href="README.Data.Tree.AVL.html#1341" class="Function">t₂</a><a id="2136" class="Symbol">)</a> <a id="2138" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2140" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a>
<a id="2146" href="README.Data.Tree.AVL.html#2123" class="Function">q₂</a> <a id="2149" class="Symbol">=</a> <a id="2151" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="q₃"></a><a id="2157" href="README.Data.Tree.AVL.html#2157" class="Function">q₃</a> <a id="2160" class="Symbol">:</a> <a id="2162" class="Symbol">(</a><a id="2163" class="Number">1</a> <a id="2165" href="Data.Tree.AVL.html#5873" class="Function Operator">∈?</a> <a id="2168" href="README.Data.Tree.AVL.html#1665" class="Function">t₄</a><a id="2170" class="Symbol">)</a> <a id="2172" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2174" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a>
<a id="2179" href="README.Data.Tree.AVL.html#2157" class="Function">q₃</a> <a id="2182" class="Symbol">=</a> <a id="2184" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="2190" class="Comment">-- Turning a tree into a sorted list of key-value pairs.</a>

<a id="q₄"></a><a id="2248" href="README.Data.Tree.AVL.html#2248" class="Function">q₄</a> <a id="2251" class="Symbol">:</a> <a id="2253" href="Data.Tree.AVL.html#3439" class="Function">toList</a> <a id="2260" href="README.Data.Tree.AVL.html#1263" class="Function">t₁</a> <a id="2263" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2265" class="Symbol">(</a><a id="2266" class="Number">2</a> <a id="2268" class="InductiveConstructor Operator">,</a> <a id="2270" href="README.Data.Tree.AVL.html#1183" class="Function">v₂</a><a id="2272" class="Symbol">)</a> <a id="2274" class="InductiveConstructor Operator">∷</a> <a id="2276" class="InductiveConstructor">[]</a>
<a id="2279" href="README.Data.Tree.AVL.html#2248" class="Function">q₄</a> <a id="2282" class="Symbol">=</a> <a id="2284" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="q₅"></a><a id="2290" href="README.Data.Tree.AVL.html#2290" class="Function">q₅</a> <a id="2293" class="Symbol">:</a> <a id="2295" href="Data.Tree.AVL.html#3439" class="Function">toList</a> <a id="2302" href="README.Data.Tree.AVL.html#1341" class="Function">t₂</a> <a id="2305" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2307" class="Symbol">(</a><a id="2308" class="Number">1</a> <a id="2310" class="InductiveConstructor Operator">,</a> <a id="2312" href="README.Data.Tree.AVL.html#1147" class="Function">v₁</a><a id="2314" class="Symbol">)</a> <a id="2316" class="InductiveConstructor Operator">∷</a> <a id="2318" class="Symbol">(</a><a id="2319" class="Number">2</a> <a id="2321" class="InductiveConstructor Operator">,</a> <a id="2323" href="README.Data.Tree.AVL.html#1183" class="Function">v₂</a><a id="2325" class="Symbol">)</a> <a id="2327" class="InductiveConstructor Operator">∷</a> <a id="2329" class="InductiveConstructor">[]</a>
<a id="2332" href="README.Data.Tree.AVL.html#2290" class="Function">q₅</a> <a id="2335" class="Symbol">=</a> <a id="2337" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="q₅′"></a><a id="2343" href="README.Data.Tree.AVL.html#2343" class="Function">q₅′</a> <a id="2347" class="Symbol">:</a> <a id="2349" href="Data.Tree.AVL.html#3439" class="Function">toList</a> <a id="2356" href="README.Data.Tree.AVL.html#1475" class="Function">t₂′</a> <a id="2360" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2362" class="Symbol">(</a><a id="2363" class="Number">1</a> <a id="2365" class="InductiveConstructor Operator">,</a> <a id="2367" href="README.Data.Tree.AVL.html#1165" class="Function">v₁′</a><a id="2370" class="Symbol">)</a> <a id="2372" class="InductiveConstructor Operator">∷</a> <a id="2374" class="Symbol">(</a><a id="2375" class="Number">2</a> <a id="2377" class="InductiveConstructor Operator">,</a> <a id="2379" href="README.Data.Tree.AVL.html#1183" class="Function">v₂</a><a id="2381" class="Symbol">)</a> <a id="2383" class="InductiveConstructor Operator">∷</a> <a id="2385" class="InductiveConstructor">[]</a>
<a id="2388" href="README.Data.Tree.AVL.html#2343" class="Function">q₅′</a> <a id="2392" class="Symbol">=</a> <a id="2394" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="2400" class="Comment">------------------------------------------------------------------------</a>
<a id="2473" class="Comment">-- Views</a>

<a id="2483" class="Comment">-- Partitioning a tree into the smallest element plus the rest, or the</a>
<a id="2554" class="Comment">-- largest element plus the rest.</a>

<a id="2589" class="Keyword">open</a> <a id="2594" class="Keyword">import</a> <a id="2601" href="Function.Base.html" class="Module">Function.Base</a> <a id="2615" class="Keyword">using</a> <a id="2621" class="Symbol">(</a><a id="2622" href="Function.Base.html#704" class="Function">id</a><a id="2624" class="Symbol">)</a>

<a id="v₆"></a><a id="2627" href="README.Data.Tree.AVL.html#2627" class="Function">v₆</a> <a id="2630" class="Symbol">:</a> <a id="2632" href="Data.Tree.AVL.html#2726" class="Function">headTail</a> <a id="2641" href="README.Data.Tree.AVL.html#1241" class="Function">t₀</a> <a id="2644" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2646" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>
<a id="2654" href="README.Data.Tree.AVL.html#2627" class="Function">v₆</a> <a id="2657" class="Symbol">=</a> <a id="2659" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="v₇"></a><a id="2665" href="README.Data.Tree.AVL.html#2665" class="Function">v₇</a> <a id="2668" class="Symbol">:</a> <a id="2670" href="Data.Maybe.Base.html#2049" class="Function">Maybe.map</a> <a id="2680" class="Symbol">(</a><a id="2681" href="Data.Product.Base.html#2362" class="Function">Prod.map₂</a> <a id="2691" href="Data.Tree.AVL.html#3439" class="Function">toList</a><a id="2697" class="Symbol">)</a> <a id="2699" class="Symbol">(</a><a id="2700" href="Data.Tree.AVL.html#2726" class="Function">headTail</a> <a id="2709" href="README.Data.Tree.AVL.html#1341" class="Function">t₂</a><a id="2711" class="Symbol">)</a> <a id="2713" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a>
     <a id="2720" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2725" class="Symbol">((</a><a id="2727" class="Number">1</a> <a id="2729" class="InductiveConstructor Operator">,</a> <a id="2731" href="README.Data.Tree.AVL.html#1147" class="Function">v₁</a><a id="2733" class="Symbol">)</a> <a id="2735" class="InductiveConstructor Operator">,</a> <a id="2737" class="Symbol">((</a><a id="2739" class="Number">2</a> <a id="2741" class="InductiveConstructor Operator">,</a> <a id="2743" href="README.Data.Tree.AVL.html#1183" class="Function">v₂</a><a id="2745" class="Symbol">)</a> <a id="2747" class="InductiveConstructor Operator">∷</a> <a id="2749" class="InductiveConstructor">[]</a><a id="2751" class="Symbol">))</a>
<a id="2754" href="README.Data.Tree.AVL.html#2665" class="Function">v₇</a> <a id="2757" class="Symbol">=</a> <a id="2759" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="v₈"></a><a id="2765" href="README.Data.Tree.AVL.html#2765" class="Function">v₈</a> <a id="2768" class="Symbol">:</a> <a id="2770" href="Data.Tree.AVL.html#2946" class="Function">initLast</a> <a id="2779" href="README.Data.Tree.AVL.html#1241" class="Function">t₀</a> <a id="2782" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2784" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>
<a id="2792" href="README.Data.Tree.AVL.html#2765" class="Function">v₈</a> <a id="2795" class="Symbol">=</a> <a id="2797" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="v₉"></a><a id="2803" href="README.Data.Tree.AVL.html#2803" class="Function">v₉</a> <a id="2806" class="Symbol">:</a> <a id="2808" href="Data.Maybe.Base.html#2049" class="Function">Maybe.map</a> <a id="2818" class="Symbol">(</a><a id="2819" href="Data.Product.Base.html#2312" class="Function">Prod.map₁</a> <a id="2829" href="Data.Tree.AVL.html#3439" class="Function">toList</a><a id="2835" class="Symbol">)</a> <a id="2837" class="Symbol">(</a><a id="2838" href="Data.Tree.AVL.html#2946" class="Function">initLast</a> <a id="2847" href="README.Data.Tree.AVL.html#1665" class="Function">t₄</a><a id="2849" class="Symbol">)</a> <a id="2851" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a>
     <a id="2858" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2863" class="Symbol">(((</a><a id="2866" class="Number">1</a> <a id="2868" class="InductiveConstructor Operator">,</a> <a id="2870" href="README.Data.Tree.AVL.html#1147" class="Function">v₁</a><a id="2872" class="Symbol">)</a> <a id="2874" class="InductiveConstructor Operator">∷</a> <a id="2876" class="InductiveConstructor">[]</a><a id="2878" class="Symbol">)</a> <a id="2880" href="Data.Product.Base.html#1686" class="Function Operator">,′</a> <a id="2883" class="Symbol">(</a><a id="2884" class="Number">2</a> <a id="2886" class="InductiveConstructor Operator">,</a> <a id="2888" href="README.Data.Tree.AVL.html#1183" class="Function">v₂</a><a id="2890" class="Symbol">))</a>
<a id="2893" href="README.Data.Tree.AVL.html#2803" class="Function">v₉</a> <a id="2896" class="Symbol">=</a> <a id="2898" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="2904" class="Comment">------------------------------------------------------------------------</a>
<a id="2977" class="Comment">-- Further reading</a>

<a id="2997" class="Comment">-- Variations of the AVL tree module are available:</a>

<a id="3050" class="Comment">-- • Finite maps with indexed keys and values.</a>

<a id="3098" class="Keyword">import</a> <a id="3105" href="Data.Tree.AVL.IndexedMap.html" class="Module">Data.Tree.AVL.IndexedMap</a>

<a id="3131" class="Comment">-- • Finite sets.</a>

<a id="3150" class="Keyword">import</a> <a id="3157" href="Data.Tree.AVL.Sets.html" class="Module">Data.Tree.AVL.Sets</a>
</pre></body></html>