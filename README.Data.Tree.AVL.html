<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.Tree.AVL</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Some examples showing how the AVL tree module can be used</a>
<a id="167" class="Comment">------------------------------------------------------------------------</a>

<a id="241" class="Symbol">{-#</a> <a id="245" class="Keyword">OPTIONS</a> <a id="253" class="Pragma">--cubical-compatible</a> <a id="274" class="Pragma">--safe</a> <a id="281" class="Symbol">#-}</a>

<a id="286" class="Keyword">module</a> <a id="293" href="README.Data.Tree.AVL.html" class="Module">README.Data.Tree.AVL</a> <a id="314" class="Keyword">where</a>

<a id="321" class="Comment">------------------------------------------------------------------------</a>
<a id="394" class="Comment">-- Setup</a>

<a id="404" class="Comment">-- AVL trees are defined in Data.Tree.AVL.</a>

<a id="448" class="Keyword">import</a> <a id="455" href="Data.Tree.AVL.html" class="Module">Data.Tree.AVL</a>

<a id="470" class="Comment">-- This module is parametrised by keys, which have to form a (strict)</a>
<a id="540" class="Comment">-- total order, and values, which are indexed by keys. Let us use</a>
<a id="606" class="Comment">-- natural numbers as keys and vectors of strings as values.</a>

<a id="668" class="Keyword">open</a> <a id="673" class="Keyword">import</a> <a id="680" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="700" class="Keyword">using</a> <a id="706" class="Symbol">(</a><a id="707" href="Data.Nat.Properties.html#11471" class="Function">&lt;-strictTotalOrder</a><a id="725" class="Symbol">)</a>
<a id="727" class="Keyword">open</a> <a id="732" class="Keyword">import</a> <a id="739" href="Data.Product.html" class="Module">Data.Product</a> <a id="752" class="Symbol">as</a> <a id="755" class="Module">Prod</a> <a id="760" class="Keyword">using</a> <a id="766" class="Symbol">(</a><a id="767" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="770" class="Symbol">;</a> <a id="772" href="Data.Product.Base.html#1686" class="Function Operator">_,′_</a><a id="776" class="Symbol">)</a>
<a id="778" class="Keyword">open</a> <a id="783" class="Keyword">import</a> <a id="790" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="807" class="Keyword">using</a> <a id="813" class="Symbol">(</a><a id="814" href="Agda.Builtin.String.html#318" class="Postulate">String</a><a id="820" class="Symbol">)</a>
<a id="822" class="Keyword">open</a> <a id="827" class="Keyword">import</a> <a id="834" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a> <a id="848" class="Keyword">using</a> <a id="854" class="Symbol">(</a><a id="855" href="Data.Vec.Base.html#1086" class="Datatype">Vec</a><a id="858" class="Symbol">;</a> <a id="860" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">_∷_</a><a id="863" class="Symbol">;</a> <a id="865" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a><a id="867" class="Symbol">)</a>
<a id="869" class="Keyword">open</a> <a id="874" class="Keyword">import</a> <a id="881" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="920" class="Keyword">open</a> <a id="925" href="Data.Tree.AVL.html" class="Module">Data.Tree.AVL</a> <a id="939" href="Data.Nat.Properties.html#11471" class="Function">&lt;-strictTotalOrder</a> <a id="958" class="Keyword">renaming</a> <a id="967" class="Symbol">(</a><a id="968" href="Data.Tree.AVL.html#1584" class="Datatype">Tree</a> <a id="973" class="Symbol">to</a> <a id="976" class="Datatype">Tree′</a><a id="981" class="Symbol">)</a>
<a id="Tree"></a><a id="983" href="README.Data.Tree.AVL.html#983" class="Function">Tree</a> <a id="988" class="Symbol">=</a> <a id="990" href="README.Data.Tree.AVL.html#976" class="Datatype">Tree′</a> <a id="996" class="Symbol">(</a><a id="997" href="Data.Tree.AVL.Value.html#704" class="InductiveConstructor">MkValue</a> <a id="1005" class="Symbol">(</a><a id="1006" href="Data.Vec.Base.html#1086" class="Datatype">Vec</a> <a id="1010" href="Agda.Builtin.String.html#318" class="Postulate">String</a><a id="1016" class="Symbol">)</a> <a id="1018" class="Symbol">(</a><a id="1019" href="Relation.Binary.PropositionalEquality.Core.html#1808" class="Function">subst</a> <a id="1025" class="Symbol">(</a><a id="1026" href="Data.Vec.Base.html#1086" class="Datatype">Vec</a> <a id="1030" href="Agda.Builtin.String.html#318" class="Postulate">String</a><a id="1036" class="Symbol">)))</a>

<a id="1041" class="Comment">------------------------------------------------------------------------</a>
<a id="1114" class="Comment">-- Construction of trees</a>

<a id="1140" class="Comment">-- Some values.</a>

<a id="v₁"></a><a id="1157" href="README.Data.Tree.AVL.html#1157" class="Function">v₁</a>  <a id="1161" class="Symbol">=</a> <a id="1163" class="String">&quot;cepa&quot;</a> <a id="1170" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="1172" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a>
<a id="v₁′"></a><a id="1175" href="README.Data.Tree.AVL.html#1175" class="Function">v₁′</a> <a id="1179" class="Symbol">=</a> <a id="1181" class="String">&quot;depa&quot;</a> <a id="1188" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="1190" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a>
<a id="v₂"></a><a id="1193" href="README.Data.Tree.AVL.html#1193" class="Function">v₂</a>  <a id="1197" class="Symbol">=</a> <a id="1199" class="String">&quot;apa&quot;</a> <a id="1205" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="1207" class="String">&quot;bepa&quot;</a> <a id="1214" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="1216" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a>

<a id="1220" class="Comment">-- Empty and singleton trees.</a>

<a id="t₀"></a><a id="1251" href="README.Data.Tree.AVL.html#1251" class="Function">t₀</a> <a id="1254" class="Symbol">:</a> <a id="1256" href="README.Data.Tree.AVL.html#983" class="Function">Tree</a>
<a id="1261" href="README.Data.Tree.AVL.html#1251" class="Function">t₀</a> <a id="1264" class="Symbol">=</a> <a id="1266" href="Data.Tree.AVL.html#1754" class="Function">empty</a>

<a id="t₁"></a><a id="1273" href="README.Data.Tree.AVL.html#1273" class="Function">t₁</a> <a id="1276" class="Symbol">:</a> <a id="1278" href="README.Data.Tree.AVL.html#983" class="Function">Tree</a>
<a id="1283" href="README.Data.Tree.AVL.html#1273" class="Function">t₁</a> <a id="1286" class="Symbol">=</a> <a id="1288" href="Data.Tree.AVL.html#1810" class="Function">singleton</a> <a id="1298" class="Number">2</a> <a id="1300" href="README.Data.Tree.AVL.html#1193" class="Function">v₂</a>

<a id="1304" class="Comment">-- Insertion of a key-value pair into a tree.</a>

<a id="t₂"></a><a id="1351" href="README.Data.Tree.AVL.html#1351" class="Function">t₂</a> <a id="1354" class="Symbol">=</a> <a id="1356" href="Data.Tree.AVL.html#1911" class="Function">insert</a> <a id="1363" class="Number">1</a> <a id="1365" href="README.Data.Tree.AVL.html#1157" class="Function">v₁</a> <a id="1368" href="README.Data.Tree.AVL.html#1273" class="Function">t₁</a>

<a id="1372" class="Comment">-- If you insert a key-value pair and the key already exists in the</a>
<a id="1440" class="Comment">-- tree, then the old value is thrown away.</a>

<a id="t₂′"></a><a id="1485" href="README.Data.Tree.AVL.html#1485" class="Function">t₂′</a> <a id="1489" class="Symbol">=</a> <a id="1491" href="Data.Tree.AVL.html#1911" class="Function">insert</a> <a id="1498" class="Number">1</a> <a id="1500" href="README.Data.Tree.AVL.html#1175" class="Function">v₁′</a> <a id="1504" href="README.Data.Tree.AVL.html#1351" class="Function">t₂</a>

<a id="1508" class="Comment">-- Deletion of the mapping for a certain key.</a>

<a id="t₃"></a><a id="1555" href="README.Data.Tree.AVL.html#1555" class="Function">t₃</a> <a id="1558" class="Symbol">=</a> <a id="1560" href="Data.Tree.AVL.html#2198" class="Function">delete</a> <a id="1567" class="Number">2</a> <a id="1569" href="README.Data.Tree.AVL.html#1351" class="Function">t₂</a>

<a id="1573" class="Comment">-- Conversion of a list of key-value mappings to a tree.</a>

<a id="1631" class="Keyword">open</a> <a id="1636" class="Keyword">import</a> <a id="1643" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="1658" class="Keyword">using</a> <a id="1664" class="Symbol">(</a><a id="1665" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">_∷_</a><a id="1668" class="Symbol">;</a> <a id="1670" href="Data.List.Base.html#7375" class="InductiveConstructor">[]</a><a id="1672" class="Symbol">)</a>

<a id="t₄"></a><a id="1675" href="README.Data.Tree.AVL.html#1675" class="Function">t₄</a> <a id="1678" class="Symbol">:</a> <a id="1680" href="README.Data.Tree.AVL.html#983" class="Function">Tree</a>
<a id="1685" href="README.Data.Tree.AVL.html#1675" class="Function">t₄</a> <a id="1688" class="Symbol">=</a> <a id="1690" href="Data.Tree.AVL.html#3324" class="Function">fromList</a> <a id="1699" class="Symbol">((</a><a id="1701" class="Number">2</a> <a id="1703" href="Data.Tree.AVL.Value.html#953" class="InductiveConstructor Operator">,</a> <a id="1705" href="README.Data.Tree.AVL.html#1193" class="Function">v₂</a><a id="1707" class="Symbol">)</a> <a id="1709" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1711" class="Symbol">(</a><a id="1712" class="Number">1</a> <a id="1714" href="Data.Tree.AVL.Value.html#953" class="InductiveConstructor Operator">,</a> <a id="1716" href="README.Data.Tree.AVL.html#1157" class="Function">v₁</a><a id="1718" class="Symbol">)</a> <a id="1720" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="1722" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="1724" class="Symbol">)</a>

<a id="1727" class="Comment">------------------------------------------------------------------------</a>
<a id="1800" class="Comment">-- Queries</a>

<a id="1812" class="Comment">-- Let us formulate queries as unit tests.</a>

<a id="1856" class="Keyword">open</a> <a id="1861" class="Keyword">import</a> <a id="1868" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1906" class="Keyword">using</a> <a id="1912" class="Symbol">(</a><a id="1913" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a><a id="1916" class="Symbol">;</a> <a id="1918" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="1922" class="Symbol">)</a>

<a id="1925" class="Comment">-- Searching for a key.</a>

<a id="1950" class="Keyword">open</a> <a id="1955" class="Keyword">import</a> <a id="1962" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a> <a id="1977" class="Keyword">using</a> <a id="1983" class="Symbol">(</a><a id="1984" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a><a id="1988" class="Symbol">;</a> <a id="1990" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a><a id="1995" class="Symbol">)</a>
<a id="1997" class="Keyword">open</a> <a id="2002" class="Keyword">import</a> <a id="2009" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="2025" class="Symbol">as</a> <a id="2028" class="Module">Maybe</a> <a id="2034" class="Keyword">using</a> <a id="2040" class="Symbol">(</a><a id="2041" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a><a id="2045" class="Symbol">;</a> <a id="2047" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a><a id="2054" class="Symbol">)</a>

<a id="q₀"></a><a id="2057" href="README.Data.Tree.AVL.html#2057" class="Function">q₀</a> <a id="2060" class="Symbol">:</a> <a id="2062" href="Data.Tree.AVL.html#2301" class="Function">lookup</a> <a id="2069" href="README.Data.Tree.AVL.html#1351" class="Function">t₂</a> <a id="2072" class="Number">2</a> <a id="2074" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2076" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2081" href="README.Data.Tree.AVL.html#1193" class="Function">v₂</a>
<a id="2084" href="README.Data.Tree.AVL.html#2057" class="Function">q₀</a> <a id="2087" class="Symbol">=</a> <a id="2089" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="q₁"></a><a id="2095" href="README.Data.Tree.AVL.html#2095" class="Function">q₁</a> <a id="2098" class="Symbol">:</a> <a id="2100" href="Data.Tree.AVL.html#2301" class="Function">lookup</a> <a id="2107" href="README.Data.Tree.AVL.html#1555" class="Function">t₃</a> <a id="2110" class="Number">2</a> <a id="2112" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2114" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>
<a id="2122" href="README.Data.Tree.AVL.html#2095" class="Function">q₁</a> <a id="2125" class="Symbol">=</a> <a id="2127" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="q₂"></a><a id="2133" href="README.Data.Tree.AVL.html#2133" class="Function">q₂</a> <a id="2136" class="Symbol">:</a> <a id="2138" class="Symbol">(</a><a id="2139" class="Number">3</a> <a id="2141" href="Data.Tree.AVL.html#5881" class="Function Operator">∈?</a> <a id="2144" href="README.Data.Tree.AVL.html#1351" class="Function">t₂</a><a id="2146" class="Symbol">)</a> <a id="2148" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2150" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a>
<a id="2156" href="README.Data.Tree.AVL.html#2133" class="Function">q₂</a> <a id="2159" class="Symbol">=</a> <a id="2161" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="q₃"></a><a id="2167" href="README.Data.Tree.AVL.html#2167" class="Function">q₃</a> <a id="2170" class="Symbol">:</a> <a id="2172" class="Symbol">(</a><a id="2173" class="Number">1</a> <a id="2175" href="Data.Tree.AVL.html#5881" class="Function Operator">∈?</a> <a id="2178" href="README.Data.Tree.AVL.html#1675" class="Function">t₄</a><a id="2180" class="Symbol">)</a> <a id="2182" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2184" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a>
<a id="2189" href="README.Data.Tree.AVL.html#2167" class="Function">q₃</a> <a id="2192" class="Symbol">=</a> <a id="2194" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="2200" class="Comment">-- Turning a tree into a sorted list of key-value pairs.</a>

<a id="q₄"></a><a id="2258" href="README.Data.Tree.AVL.html#2258" class="Function">q₄</a> <a id="2261" class="Symbol">:</a> <a id="2263" href="Data.Tree.AVL.html#3447" class="Function">toList</a> <a id="2270" href="README.Data.Tree.AVL.html#1273" class="Function">t₁</a> <a id="2273" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2275" class="Symbol">(</a><a id="2276" class="Number">2</a> <a id="2278" class="InductiveConstructor Operator">,</a> <a id="2280" href="README.Data.Tree.AVL.html#1193" class="Function">v₂</a><a id="2282" class="Symbol">)</a> <a id="2284" class="InductiveConstructor Operator">∷</a> <a id="2286" class="InductiveConstructor">[]</a>
<a id="2289" href="README.Data.Tree.AVL.html#2258" class="Function">q₄</a> <a id="2292" class="Symbol">=</a> <a id="2294" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="q₅"></a><a id="2300" href="README.Data.Tree.AVL.html#2300" class="Function">q₅</a> <a id="2303" class="Symbol">:</a> <a id="2305" href="Data.Tree.AVL.html#3447" class="Function">toList</a> <a id="2312" href="README.Data.Tree.AVL.html#1351" class="Function">t₂</a> <a id="2315" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2317" class="Symbol">(</a><a id="2318" class="Number">1</a> <a id="2320" class="InductiveConstructor Operator">,</a> <a id="2322" href="README.Data.Tree.AVL.html#1157" class="Function">v₁</a><a id="2324" class="Symbol">)</a> <a id="2326" class="InductiveConstructor Operator">∷</a> <a id="2328" class="Symbol">(</a><a id="2329" class="Number">2</a> <a id="2331" class="InductiveConstructor Operator">,</a> <a id="2333" href="README.Data.Tree.AVL.html#1193" class="Function">v₂</a><a id="2335" class="Symbol">)</a> <a id="2337" class="InductiveConstructor Operator">∷</a> <a id="2339" class="InductiveConstructor">[]</a>
<a id="2342" href="README.Data.Tree.AVL.html#2300" class="Function">q₅</a> <a id="2345" class="Symbol">=</a> <a id="2347" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="q₅′"></a><a id="2353" href="README.Data.Tree.AVL.html#2353" class="Function">q₅′</a> <a id="2357" class="Symbol">:</a> <a id="2359" href="Data.Tree.AVL.html#3447" class="Function">toList</a> <a id="2366" href="README.Data.Tree.AVL.html#1485" class="Function">t₂′</a> <a id="2370" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2372" class="Symbol">(</a><a id="2373" class="Number">1</a> <a id="2375" class="InductiveConstructor Operator">,</a> <a id="2377" href="README.Data.Tree.AVL.html#1175" class="Function">v₁′</a><a id="2380" class="Symbol">)</a> <a id="2382" class="InductiveConstructor Operator">∷</a> <a id="2384" class="Symbol">(</a><a id="2385" class="Number">2</a> <a id="2387" class="InductiveConstructor Operator">,</a> <a id="2389" href="README.Data.Tree.AVL.html#1193" class="Function">v₂</a><a id="2391" class="Symbol">)</a> <a id="2393" class="InductiveConstructor Operator">∷</a> <a id="2395" class="InductiveConstructor">[]</a>
<a id="2398" href="README.Data.Tree.AVL.html#2353" class="Function">q₅′</a> <a id="2402" class="Symbol">=</a> <a id="2404" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="2410" class="Comment">------------------------------------------------------------------------</a>
<a id="2483" class="Comment">-- Views</a>

<a id="2493" class="Comment">-- Partitioning a tree into the smallest element plus the rest, or the</a>
<a id="2564" class="Comment">-- largest element plus the rest.</a>

<a id="2599" class="Keyword">open</a> <a id="2604" class="Keyword">import</a> <a id="2611" href="Function.Base.html" class="Module">Function.Base</a> <a id="2625" class="Keyword">using</a> <a id="2631" class="Symbol">(</a><a id="2632" href="Function.Base.html#704" class="Function">id</a><a id="2634" class="Symbol">)</a>

<a id="v₆"></a><a id="2637" href="README.Data.Tree.AVL.html#2637" class="Function">v₆</a> <a id="2640" class="Symbol">:</a> <a id="2642" href="Data.Tree.AVL.html#2734" class="Function">headTail</a> <a id="2651" href="README.Data.Tree.AVL.html#1251" class="Function">t₀</a> <a id="2654" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2656" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>
<a id="2664" href="README.Data.Tree.AVL.html#2637" class="Function">v₆</a> <a id="2667" class="Symbol">=</a> <a id="2669" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="v₇"></a><a id="2675" href="README.Data.Tree.AVL.html#2675" class="Function">v₇</a> <a id="2678" class="Symbol">:</a> <a id="2680" href="Data.Maybe.Base.html#2049" class="Function">Maybe.map</a> <a id="2690" class="Symbol">(</a><a id="2691" href="Data.Product.Base.html#2362" class="Function">Prod.map₂</a> <a id="2701" href="Data.Tree.AVL.html#3447" class="Function">toList</a><a id="2707" class="Symbol">)</a> <a id="2709" class="Symbol">(</a><a id="2710" href="Data.Tree.AVL.html#2734" class="Function">headTail</a> <a id="2719" href="README.Data.Tree.AVL.html#1351" class="Function">t₂</a><a id="2721" class="Symbol">)</a> <a id="2723" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a>
     <a id="2730" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2735" class="Symbol">((</a><a id="2737" class="Number">1</a> <a id="2739" class="InductiveConstructor Operator">,</a> <a id="2741" href="README.Data.Tree.AVL.html#1157" class="Function">v₁</a><a id="2743" class="Symbol">)</a> <a id="2745" class="InductiveConstructor Operator">,</a> <a id="2747" class="Symbol">((</a><a id="2749" class="Number">2</a> <a id="2751" class="InductiveConstructor Operator">,</a> <a id="2753" href="README.Data.Tree.AVL.html#1193" class="Function">v₂</a><a id="2755" class="Symbol">)</a> <a id="2757" class="InductiveConstructor Operator">∷</a> <a id="2759" class="InductiveConstructor">[]</a><a id="2761" class="Symbol">))</a>
<a id="2764" href="README.Data.Tree.AVL.html#2675" class="Function">v₇</a> <a id="2767" class="Symbol">=</a> <a id="2769" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="v₈"></a><a id="2775" href="README.Data.Tree.AVL.html#2775" class="Function">v₈</a> <a id="2778" class="Symbol">:</a> <a id="2780" href="Data.Tree.AVL.html#2954" class="Function">initLast</a> <a id="2789" href="README.Data.Tree.AVL.html#1251" class="Function">t₀</a> <a id="2792" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2794" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>
<a id="2802" href="README.Data.Tree.AVL.html#2775" class="Function">v₈</a> <a id="2805" class="Symbol">=</a> <a id="2807" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="v₉"></a><a id="2813" href="README.Data.Tree.AVL.html#2813" class="Function">v₉</a> <a id="2816" class="Symbol">:</a> <a id="2818" href="Data.Maybe.Base.html#2049" class="Function">Maybe.map</a> <a id="2828" class="Symbol">(</a><a id="2829" href="Data.Product.Base.html#2312" class="Function">Prod.map₁</a> <a id="2839" href="Data.Tree.AVL.html#3447" class="Function">toList</a><a id="2845" class="Symbol">)</a> <a id="2847" class="Symbol">(</a><a id="2848" href="Data.Tree.AVL.html#2954" class="Function">initLast</a> <a id="2857" href="README.Data.Tree.AVL.html#1675" class="Function">t₄</a><a id="2859" class="Symbol">)</a> <a id="2861" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a>
     <a id="2868" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2873" class="Symbol">(((</a><a id="2876" class="Number">1</a> <a id="2878" class="InductiveConstructor Operator">,</a> <a id="2880" href="README.Data.Tree.AVL.html#1157" class="Function">v₁</a><a id="2882" class="Symbol">)</a> <a id="2884" class="InductiveConstructor Operator">∷</a> <a id="2886" class="InductiveConstructor">[]</a><a id="2888" class="Symbol">)</a> <a id="2890" href="Data.Product.Base.html#1686" class="Function Operator">,′</a> <a id="2893" class="Symbol">(</a><a id="2894" class="Number">2</a> <a id="2896" class="InductiveConstructor Operator">,</a> <a id="2898" href="README.Data.Tree.AVL.html#1193" class="Function">v₂</a><a id="2900" class="Symbol">))</a>
<a id="2903" href="README.Data.Tree.AVL.html#2813" class="Function">v₉</a> <a id="2906" class="Symbol">=</a> <a id="2908" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="2914" class="Comment">------------------------------------------------------------------------</a>
<a id="2987" class="Comment">-- Further reading</a>

<a id="3007" class="Comment">-- Variations of the AVL tree module are available:</a>

<a id="3060" class="Comment">-- • Finite maps with indexed keys and values.</a>

<a id="3108" class="Keyword">import</a> <a id="3115" href="Data.Tree.AVL.IndexedMap.html" class="Module">Data.Tree.AVL.IndexedMap</a>

<a id="3141" class="Comment">-- • Finite sets.</a>

<a id="3160" class="Keyword">import</a> <a id="3167" href="Data.Tree.AVL.Sets.html" class="Module">Data.Tree.AVL.Sets</a>
</pre></body></html>