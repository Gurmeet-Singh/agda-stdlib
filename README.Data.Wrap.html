<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.Wrap</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- An example of how to use `Wrap` to help term inference.</a>
<a id="165" class="Comment">------------------------------------------------------------------------</a>

<a id="239" class="Symbol">{-#</a> <a id="243" class="Keyword">OPTIONS</a> <a id="251" class="Pragma">--cubical-compatible</a> <a id="272" class="Pragma">--safe</a> <a id="279" class="Symbol">#-}</a>

<a id="284" class="Keyword">module</a> <a id="291" href="README.Data.Wrap.html" class="Module">README.Data.Wrap</a> <a id="308" class="Keyword">where</a>

<a id="315" class="Keyword">open</a> <a id="320" class="Keyword">import</a> <a id="327" href="Data.Wrap.html" class="Module">Data.Wrap</a>

<a id="338" class="Keyword">open</a> <a id="343" class="Keyword">import</a> <a id="350" href="Algebra.html" class="Module">Algebra</a>
<a id="358" class="Keyword">open</a> <a id="363" class="Keyword">import</a> <a id="370" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="379" class="Keyword">open</a> <a id="384" class="Keyword">import</a> <a id="391" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="411" class="Keyword">open</a> <a id="416" class="Keyword">import</a> <a id="423" href="Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="441" class="Keyword">using</a> <a id="447" class="Symbol">(</a><a id="448" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="451" class="Symbol">;</a> <a id="453" href="Data.Product.Base.html#852" class="Function">∃</a><a id="454" class="Symbol">;</a> <a id="456" href="Data.Product.Base.html#907" class="Function">∃₂</a><a id="458" class="Symbol">;</a> <a id="460" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="463" class="Symbol">)</a>
<a id="465" class="Keyword">open</a> <a id="470" class="Keyword">import</a> <a id="477" href="Level.html" class="Module">Level</a> <a id="483" class="Keyword">using</a> <a id="489" class="Symbol">(</a><a id="490" href="Agda.Primitive.html#591" class="Postulate">Level</a><a id="495" class="Symbol">)</a>
<a id="497" class="Keyword">open</a> <a id="502" class="Keyword">import</a> <a id="509" href="Relation.Binary.html" class="Module">Relation.Binary</a>

<a id="526" class="Keyword">private</a>
  <a id="536" class="Keyword">variable</a>
    <a id="549" href="README.Data.Wrap.html#549" class="Generalizable">c</a> <a id="551" href="README.Data.Wrap.html#551" class="Generalizable">ℓ</a> <a id="553" class="Symbol">:</a> <a id="555" href="Agda.Primitive.html#591" class="Postulate">Level</a>
    <a id="565" href="README.Data.Wrap.html#565" class="Generalizable">A</a> <a id="567" class="Symbol">:</a> <a id="569" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="573" href="README.Data.Wrap.html#549" class="Generalizable">c</a>
    <a id="579" href="README.Data.Wrap.html#579" class="Generalizable">m</a> <a id="581" href="README.Data.Wrap.html#581" class="Generalizable">n</a> <a id="583" class="Symbol">:</a> <a id="585" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>

<a id="588" class="Comment">------------------------------------------------------------------------</a>
<a id="661" class="Comment">-- `Wrap` for remembering instances</a>
<a id="697" class="Comment">------------------------------------------------------------------------</a>

<a id="771" class="Keyword">module</a> <a id="Instances"></a><a id="778" href="README.Data.Wrap.html#778" class="Module">Instances</a> <a id="788" class="Keyword">where</a>

  <a id="797" class="Comment">-- `Monoid.Carrier` gets the carrier set from a monoid, and thus has</a>
  <a id="868" class="Comment">-- type `Monoid c ℓ → Set c`.</a>
  <a id="900" class="Comment">-- Using `Wrap`, we can convert `Monoid.Carrier` into an equivalent</a>
  <a id="970" class="Comment">-- “wrapped” version: `MonoidEl`.</a>
  <a id="Instances.MonoidEl"></a><a id="1006" href="README.Data.Wrap.html#1006" class="Function">MonoidEl</a> <a id="1015" class="Symbol">:</a> <a id="1017" href="Algebra.Bundles.html#6016" class="Record">Monoid</a> <a id="1024" href="README.Data.Wrap.html#549" class="Generalizable">c</a> <a id="1026" href="README.Data.Wrap.html#551" class="Generalizable">ℓ</a> <a id="1028" class="Symbol">→</a> <a id="1030" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1034" href="README.Data.Wrap.html#549" class="Generalizable">c</a>
  <a id="1038" href="README.Data.Wrap.html#1006" class="Function">MonoidEl</a> <a id="1047" class="Symbol">=</a> <a id="1049" href="Data.Wrap.html#743" class="Function">Wrap</a> <a id="1054" href="Algebra.Bundles.html#6095" class="Field">Monoid.Carrier</a>

  <a id="1072" class="Comment">-- We can turn any monoid into the equivalent monoid where the elements</a>
  <a id="1146" class="Comment">-- and equations have been wrapped.</a>
  <a id="1184" class="Comment">-- The translation mainly consists of wrapping and unwrapping everything</a>
  <a id="1259" class="Comment">-- via the `Wrap` constructor, `[_]`.</a>
  <a id="1299" class="Comment">-- Notice that the equality field is wrapping the binary relation</a>
  <a id="1367" class="Comment">-- `_≈_ : (x y : Carrier) → Set ℓ`, giving an example of how `Wrap` works</a>
  <a id="1443" class="Comment">-- for arbitrary n-ary relations.</a>
  <a id="Instances.Wrap-monoid"></a><a id="1479" href="README.Data.Wrap.html#1479" class="Function">Wrap-monoid</a> <a id="1491" class="Symbol">:</a> <a id="1493" href="Algebra.Bundles.html#6016" class="Record">Monoid</a> <a id="1500" href="README.Data.Wrap.html#549" class="Generalizable">c</a> <a id="1502" href="README.Data.Wrap.html#551" class="Generalizable">ℓ</a> <a id="1504" class="Symbol">→</a> <a id="1506" href="Algebra.Bundles.html#6016" class="Record">Monoid</a> <a id="1513" href="README.Data.Wrap.html#549" class="Generalizable">c</a> <a id="1515" href="README.Data.Wrap.html#551" class="Generalizable">ℓ</a>
  <a id="1519" href="README.Data.Wrap.html#1479" class="Function">Wrap-monoid</a> <a id="1531" href="README.Data.Wrap.html#1531" class="Bound">M</a> <a id="1533" class="Symbol">=</a> <a id="1535" class="Keyword">record</a>
    <a id="1546" class="Symbol">{</a> <a id="1548" href="Algebra.Bundles.html#6095" class="Field">Carrier</a> <a id="1556" class="Symbol">=</a> <a id="1558" href="README.Data.Wrap.html#1006" class="Function">MonoidEl</a> <a id="1567" href="README.Data.Wrap.html#1531" class="Bound">M</a>
    <a id="1573" class="Symbol">;</a> <a id="1575" href="Algebra.Bundles.html#6116" class="Field Operator">_≈_</a> <a id="1579" class="Symbol">=</a> <a id="1581" class="Symbol">λ</a> <a id="1583" class="Symbol">(</a><a id="1584" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1586" href="README.Data.Wrap.html#1586" class="Bound">x</a> <a id="1588" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1589" class="Symbol">)</a> <a id="1591" class="Symbol">(</a><a id="1592" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1594" href="README.Data.Wrap.html#1594" class="Bound">y</a> <a id="1596" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1597" class="Symbol">)</a> <a id="1599" class="Symbol">→</a> <a id="1601" href="Data.Wrap.html#743" class="Function">Wrap</a> <a id="1606" href="Algebra.Bundles.html#6116" class="Field Operator">_≈_</a> <a id="1610" href="README.Data.Wrap.html#1586" class="Bound">x</a> <a id="1612" href="README.Data.Wrap.html#1594" class="Bound">y</a>
    <a id="1618" class="Symbol">;</a> <a id="1620" href="Algebra.Bundles.html#6145" class="Field Operator">_∙_</a> <a id="1624" class="Symbol">=</a> <a id="1626" class="Symbol">λ</a> <a id="1628" class="Symbol">(</a><a id="1629" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1631" href="README.Data.Wrap.html#1631" class="Bound">x</a> <a id="1633" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1634" class="Symbol">)</a> <a id="1636" class="Symbol">(</a><a id="1637" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1639" href="README.Data.Wrap.html#1639" class="Bound">y</a> <a id="1641" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1642" class="Symbol">)</a> <a id="1644" class="Symbol">→</a> <a id="1646" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1648" href="README.Data.Wrap.html#1631" class="Bound">x</a> <a id="1650" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="1652" href="README.Data.Wrap.html#1639" class="Bound">y</a> <a id="1654" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
    <a id="1660" class="Symbol">;</a> <a id="1662" href="Algebra.Bundles.html#6172" class="Field">ε</a> <a id="1664" class="Symbol">=</a> <a id="1666" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1668" href="Algebra.Bundles.html#6172" class="Field">ε</a> <a id="1670" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
    <a id="1676" class="Symbol">;</a> <a id="1678" href="Algebra.Bundles.html#6195" class="Field">isMonoid</a> <a id="1687" class="Symbol">=</a> <a id="1689" class="Keyword">record</a>
      <a id="1702" class="Symbol">{</a> <a id="1704" href="Algebra.Structures.html#4035" class="Field">isSemigroup</a> <a id="1716" class="Symbol">=</a> <a id="1718" class="Keyword">record</a>
        <a id="1733" class="Symbol">{</a> <a id="1735" href="Algebra.Structures.html#2953" class="Field">isMagma</a> <a id="1743" class="Symbol">=</a> <a id="1745" class="Keyword">record</a>
          <a id="1762" class="Symbol">{</a> <a id="1764" href="Algebra.Structures.html#1277" class="Field">isEquivalence</a> <a id="1778" class="Symbol">=</a> <a id="1780" class="Keyword">record</a>
            <a id="1799" class="Symbol">{</a> <a id="1801" href="Relation.Binary.Structures.html#1596" class="Field">refl</a> <a id="1806" class="Symbol">=</a> <a id="1808" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1810" href="Relation.Binary.Structures.html#1596" class="Function">refl</a> <a id="1815" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
            <a id="1829" class="Symbol">;</a> <a id="1831" href="Relation.Binary.Structures.html#1622" class="Field">sym</a> <a id="1835" class="Symbol">=</a> <a id="1837" class="Symbol">λ</a> <a id="1839" class="Symbol">(</a><a id="1840" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1842" href="README.Data.Wrap.html#1842" class="Bound">xy</a> <a id="1845" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1846" class="Symbol">)</a> <a id="1848" class="Symbol">→</a> <a id="1850" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1852" href="Relation.Binary.Structures.html#1622" class="Function">sym</a> <a id="1856" href="README.Data.Wrap.html#1842" class="Bound">xy</a> <a id="1859" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
            <a id="1873" class="Symbol">;</a> <a id="1875" href="Relation.Binary.Structures.html#1648" class="Field">trans</a> <a id="1881" class="Symbol">=</a> <a id="1883" class="Symbol">λ</a> <a id="1885" class="Symbol">(</a><a id="1886" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1888" href="README.Data.Wrap.html#1888" class="Bound">xy</a> <a id="1891" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1892" class="Symbol">)</a> <a id="1894" class="Symbol">(</a><a id="1895" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1897" href="README.Data.Wrap.html#1897" class="Bound">yz</a> <a id="1900" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1901" class="Symbol">)</a> <a id="1903" class="Symbol">→</a> <a id="1905" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1907" href="Relation.Binary.Structures.html#1648" class="Function">trans</a> <a id="1913" href="README.Data.Wrap.html#1888" class="Bound">xy</a> <a id="1916" href="README.Data.Wrap.html#1897" class="Bound">yz</a> <a id="1919" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
            <a id="1933" class="Symbol">}</a>
          <a id="1945" class="Symbol">;</a> <a id="1947" href="Algebra.Structures.html#1315" class="Field">∙-cong</a> <a id="1954" class="Symbol">=</a> <a id="1956" class="Symbol">λ</a> <a id="1958" class="Symbol">(</a><a id="1959" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1961" href="README.Data.Wrap.html#1961" class="Bound">xx</a> <a id="1964" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1965" class="Symbol">)</a> <a id="1967" class="Symbol">(</a><a id="1968" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1970" href="README.Data.Wrap.html#1970" class="Bound">yy</a> <a id="1973" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="1974" class="Symbol">)</a> <a id="1976" class="Symbol">→</a> <a id="1978" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="1980" href="Algebra.Structures.html#1315" class="Function">∙-cong</a> <a id="1987" href="README.Data.Wrap.html#1961" class="Bound">xx</a> <a id="1990" href="README.Data.Wrap.html#1970" class="Bound">yy</a> <a id="1993" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
          <a id="2005" class="Symbol">}</a>
        <a id="2015" class="Symbol">;</a> <a id="2017" href="Algebra.Structures.html#2977" class="Field">assoc</a> <a id="2023" class="Symbol">=</a> <a id="2025" class="Symbol">λ</a> <a id="2027" class="Symbol">(</a><a id="2028" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2030" href="README.Data.Wrap.html#2030" class="Bound">x</a> <a id="2032" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2033" class="Symbol">)</a> <a id="2035" class="Symbol">(</a><a id="2036" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2038" href="README.Data.Wrap.html#2038" class="Bound">y</a> <a id="2040" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2041" class="Symbol">)</a> <a id="2043" class="Symbol">(</a><a id="2044" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2046" href="README.Data.Wrap.html#2046" class="Bound">z</a> <a id="2048" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2049" class="Symbol">)</a> <a id="2051" class="Symbol">→</a> <a id="2053" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2055" href="Algebra.Structures.html#2977" class="Function">assoc</a> <a id="2061" href="README.Data.Wrap.html#2030" class="Bound">x</a> <a id="2063" href="README.Data.Wrap.html#2038" class="Bound">y</a> <a id="2065" href="README.Data.Wrap.html#2046" class="Bound">z</a> <a id="2067" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>
        <a id="2077" class="Symbol">}</a>
      <a id="2085" class="Symbol">;</a> <a id="2087" href="Algebra.Structures.html#4067" class="Field">identity</a> <a id="2096" class="Symbol">=</a> <a id="2098" class="Symbol">(λ</a> <a id="2101" class="Symbol">(</a><a id="2102" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2104" href="README.Data.Wrap.html#2104" class="Bound">x</a> <a id="2106" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2107" class="Symbol">)</a> <a id="2109" class="Symbol">→</a> <a id="2111" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2113" href="Algebra.Structures.html#4136" class="Function">identityˡ</a> <a id="2123" href="README.Data.Wrap.html#2104" class="Bound">x</a> <a id="2125" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2126" class="Symbol">)</a>
                 <a id="2145" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2147" class="Symbol">(λ</a> <a id="2150" class="Symbol">(</a><a id="2151" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2153" href="README.Data.Wrap.html#2153" class="Bound">x</a> <a id="2155" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2156" class="Symbol">)</a> <a id="2158" class="Symbol">→</a> <a id="2160" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="2162" href="Algebra.Structures.html#4197" class="Function">identityʳ</a> <a id="2172" href="README.Data.Wrap.html#2153" class="Bound">x</a> <a id="2174" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="2175" class="Symbol">)</a>
      <a id="2183" class="Symbol">}</a>
    <a id="2189" class="Symbol">}</a>
    <a id="2195" class="Keyword">where</a> <a id="2201" class="Keyword">open</a> <a id="2206" href="Algebra.Bundles.html#6016" class="Module">Monoid</a> <a id="2213" href="README.Data.Wrap.html#1531" class="Bound">M</a>

  <a id="2218" class="Comment">-- Usually, we would only open one monoid at a time.</a>
  <a id="2273" class="Comment">-- If we were to open two monoids `M` and `N` simultaneously, Agda would</a>
  <a id="2348" class="Comment">-- get confused whenever it came across, for example, `_∙_`, not knowing</a>
  <a id="2423" class="Comment">-- whether it came from `M` or `N`.</a>
  <a id="2461" class="Comment">-- This is true whether or not `M` and `N` can be disambiguated by some</a>
  <a id="2535" class="Comment">-- other means (such as by their `Carrier`s).</a>

  <a id="2584" class="Comment">-- However, with wrapped monoids, we are going to remember the monoid</a>
  <a id="2656" class="Comment">-- while checking any monoid expressions, so we can afford to have just</a>
  <a id="2730" class="Comment">-- one, polymorphic, version of `_∙_` visible globally.</a>
  <a id="2788" class="Keyword">open</a> <a id="2793" class="Keyword">module</a> <a id="Instances.Wrap-monoid"></a><a id="2800" href="README.Data.Wrap.html#2800" class="Module">Wrap-monoid</a> <a id="2812" class="Symbol">{</a><a id="2813" href="README.Data.Wrap.html#2813" class="Bound">c</a> <a id="2815" href="README.Data.Wrap.html#2815" class="Bound">ℓ</a><a id="2816" class="Symbol">}</a> <a id="2818" class="Symbol">{</a><a id="2819" href="README.Data.Wrap.html#2819" class="Bound">M</a> <a id="2821" class="Symbol">:</a> <a id="2823" href="Algebra.Bundles.html#6016" class="Record">Monoid</a> <a id="2830" href="README.Data.Wrap.html#2813" class="Bound">c</a> <a id="2832" href="README.Data.Wrap.html#2815" class="Bound">ℓ</a><a id="2833" class="Symbol">}</a> <a id="2835" class="Symbol">=</a> <a id="2837" href="Algebra.Bundles.html#6016" class="Module">Monoid</a> <a id="2844" class="Symbol">(</a><a id="2845" href="README.Data.Wrap.html#1479" class="Function">Wrap-monoid</a> <a id="2857" href="README.Data.Wrap.html#2819" class="Bound">M</a><a id="2858" class="Symbol">)</a>

  <a id="2863" class="Comment">-- Now we can test out this construct on some existing monoids.</a>

  <a id="2930" class="Keyword">open</a> <a id="2935" class="Keyword">import</a> <a id="2942" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>

  <a id="2965" class="Comment">-- Notice that, while the following two definitions appear to be defined</a>
  <a id="3040" class="Comment">-- by the same expression, their types are genuinely different.</a>
  <a id="3106" class="Comment">-- Whereas `Carrier +-0-monoid = ℕ = Carrier *-1-monoid`, `MonoidEl M`</a>
  <a id="3179" class="Comment">-- does not compute, and thus</a>
  <a id="3211" class="Comment">-- `MonoidEl +-0-monoid ≠ MonoidEl *-1-monoid` definitionally.</a>
  <a id="3276" class="Comment">-- This lets us use the respective monoids when checking the respective</a>
  <a id="3350" class="Comment">-- definitions.</a>

  <a id="Instances.test-+"></a><a id="3369" href="README.Data.Wrap.html#3369" class="Function">test-+</a> <a id="3376" class="Symbol">:</a> <a id="3378" href="README.Data.Wrap.html#1006" class="Function">MonoidEl</a> <a id="3387" href="Data.Nat.Properties.html#16398" class="Function">+-0-monoid</a>
  <a id="3400" href="README.Data.Wrap.html#3369" class="Function">test-+</a> <a id="3407" class="Symbol">=</a> <a id="3409" class="Symbol">(</a><a id="3410" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="3412" class="Number">3</a> <a id="3414" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a> <a id="3416" href="Algebra.Bundles.html#6145" class="Function Operator">∙</a> <a id="3418" href="Algebra.Bundles.html#6172" class="Function">ε</a><a id="3419" class="Symbol">)</a> <a id="3421" href="Algebra.Bundles.html#6145" class="Function Operator">∙</a> <a id="3423" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="3425" class="Number">2</a> <a id="3427" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>

  <a id="Instances.test-*"></a><a id="3432" href="README.Data.Wrap.html#3432" class="Function">test-*</a> <a id="3439" class="Symbol">:</a> <a id="3441" href="README.Data.Wrap.html#1006" class="Function">MonoidEl</a> <a id="3450" href="Data.Nat.Properties.html#23918" class="Function">*-1-monoid</a>
  <a id="3463" href="README.Data.Wrap.html#3432" class="Function">test-*</a> <a id="3470" class="Symbol">=</a> <a id="3472" class="Symbol">(</a><a id="3473" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="3475" class="Number">3</a> <a id="3477" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a> <a id="3479" href="Algebra.Bundles.html#6145" class="Function Operator">∙</a> <a id="3481" href="Algebra.Bundles.html#6172" class="Function">ε</a><a id="3482" class="Symbol">)</a> <a id="3484" href="Algebra.Bundles.html#6145" class="Function Operator">∙</a> <a id="3486" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="3488" class="Number">2</a> <a id="3490" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>

  <a id="3495" class="Comment">-- The reader is invited to normalise these two definitions</a>
  <a id="3557" class="Comment">-- (`C-c C-n`, then type in the name).</a>
  <a id="3598" class="Comment">-- `test-+` is interpreted using (ℕ, +, 0), and thus computes to `[ 5 ]`.</a>
  <a id="3674" class="Comment">-- Meanwhile, `test-*` is interpreted using (ℕ, *, 1), and thus computes</a>
  <a id="3749" class="Comment">-- to `[ 6 ]`.</a>

<a id="3765" class="Comment">------------------------------------------------------------------------</a>
<a id="3838" class="Comment">-- `Wrap` for dealing with functions spoiling unification</a>
<a id="3896" class="Comment">------------------------------------------------------------------------</a>

<a id="3970" class="Keyword">module</a> <a id="Unification"></a><a id="3977" href="README.Data.Wrap.html#3977" class="Module">Unification</a> <a id="3989" class="Keyword">where</a>

  <a id="3998" class="Keyword">open</a> <a id="4003" class="Keyword">import</a> <a id="4010" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

  <a id="4051" class="Keyword">module</a> <a id="Unification.Naïve"></a><a id="4058" href="README.Data.Wrap.html#4058" class="Module">Naïve</a> <a id="4064" class="Keyword">where</a>

    <a id="4075" class="Comment">-- We want to work with factorisations of natural numbers in a</a>
    <a id="4142" class="Comment">-- “proof-relevant” style. We could draw out `Factor m n o` as</a>
    <a id="4209" class="Comment">--   m</a>
    <a id="4220" class="Comment">--  /*\</a>
    <a id="4232" class="Comment">-- n   o.</a>

    <a id="Unification.Naïve.Factor"></a><a id="4247" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="4254" class="Symbol">:</a> <a id="4256" class="Symbol">(</a><a id="4257" href="README.Data.Wrap.html#4257" class="Bound">m</a> <a id="4259" href="README.Data.Wrap.html#4259" class="Bound">n</a> <a id="4261" href="README.Data.Wrap.html#4261" class="Bound">o</a> <a id="4263" class="Symbol">:</a> <a id="4265" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4266" class="Symbol">)</a> <a id="4268" class="Symbol">→</a> <a id="4270" href="Agda.Primitive.html#320" class="Primitive">Set</a>
    <a id="4278" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="4285" href="README.Data.Wrap.html#4285" class="Bound">m</a> <a id="4287" href="README.Data.Wrap.html#4287" class="Bound">n</a> <a id="4289" href="README.Data.Wrap.html#4289" class="Bound">o</a> <a id="4291" class="Symbol">=</a> <a id="4293" href="README.Data.Wrap.html#4285" class="Bound">m</a> <a id="4295" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4297" href="README.Data.Wrap.html#4287" class="Bound">n</a> <a id="4299" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="4301" href="README.Data.Wrap.html#4289" class="Bound">o</a>

    <a id="4308" class="Comment">-- We can prove a basic lemma about `Factor`: the following tree rotation</a>
    <a id="4386" class="Comment">-- can be done, due to associativity of `_*_`.</a>
    <a id="4437" class="Comment">--      m             m</a>
    <a id="4465" class="Comment">--     /*\           /*\</a>
    <a id="4494" class="Comment">--   no   p  ----&gt;  n   op</a>
    <a id="4525" class="Comment">--  /*\                 /*\</a>
    <a id="4557" class="Comment">-- n   o               o   p</a>

    <a id="Unification.Naïve.assoc-→"></a><a id="4591" href="README.Data.Wrap.html#4591" class="Function">assoc-→</a> <a id="4599" class="Symbol">:</a> <a id="4601" class="Symbol">∀</a> <a id="4603" class="Symbol">{</a><a id="4604" href="README.Data.Wrap.html#4604" class="Bound">m</a> <a id="4606" href="README.Data.Wrap.html#4606" class="Bound">n</a> <a id="4608" href="README.Data.Wrap.html#4608" class="Bound">o</a> <a id="4610" href="README.Data.Wrap.html#4610" class="Bound">p</a><a id="4611" class="Symbol">}</a> <a id="4613" class="Symbol">→</a>
              <a id="4629" class="Symbol">(</a><a id="4630" href="Data.Product.Base.html#852" class="Function">∃</a> <a id="4632" class="Symbol">λ</a> <a id="4634" href="README.Data.Wrap.html#4634" class="Bound">no</a> <a id="4637" class="Symbol">→</a> <a id="4639" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="4646" href="README.Data.Wrap.html#4604" class="Bound">m</a> <a id="4648" href="README.Data.Wrap.html#4634" class="Bound">no</a> <a id="4651" href="README.Data.Wrap.html#4610" class="Bound">p</a> <a id="4653" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="4655" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="4662" href="README.Data.Wrap.html#4634" class="Bound">no</a> <a id="4665" href="README.Data.Wrap.html#4606" class="Bound">n</a> <a id="4667" href="README.Data.Wrap.html#4608" class="Bound">o</a><a id="4668" class="Symbol">)</a> <a id="4670" class="Symbol">→</a>
              <a id="4686" class="Symbol">(</a><a id="4687" href="Data.Product.Base.html#852" class="Function">∃</a> <a id="4689" class="Symbol">λ</a> <a id="4691" href="README.Data.Wrap.html#4691" class="Bound">op</a> <a id="4694" class="Symbol">→</a> <a id="4696" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="4703" href="README.Data.Wrap.html#4604" class="Bound">m</a> <a id="4705" href="README.Data.Wrap.html#4606" class="Bound">n</a> <a id="4707" href="README.Data.Wrap.html#4691" class="Bound">op</a> <a id="4710" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="4712" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="4719" href="README.Data.Wrap.html#4691" class="Bound">op</a> <a id="4722" href="README.Data.Wrap.html#4608" class="Bound">o</a> <a id="4724" href="README.Data.Wrap.html#4610" class="Bound">p</a><a id="4725" class="Symbol">)</a>
    <a id="4731" href="README.Data.Wrap.html#4591" class="Function">assoc-→</a> <a id="4739" class="Symbol">{</a><a id="4740" href="README.Data.Wrap.html#4740" class="Bound">m</a><a id="4741" class="Symbol">}</a> <a id="4743" class="Symbol">{</a><a id="4744" href="README.Data.Wrap.html#4744" class="Bound">n</a><a id="4745" class="Symbol">}</a> <a id="4747" class="Symbol">{</a><a id="4748" href="README.Data.Wrap.html#4748" class="Bound">o</a><a id="4749" class="Symbol">}</a> <a id="4751" class="Symbol">{</a><a id="4752" href="README.Data.Wrap.html#4752" class="Bound">p</a><a id="4753" class="Symbol">}</a> <a id="4755" class="Symbol">(</a><a id="4756" class="DottedPattern Symbol">._</a> <a id="4759" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4761" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="4766" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4768" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a><a id="4772" class="Symbol">)</a> <a id="4774" class="Symbol">=</a> <a id="4776" class="Symbol">_</a> <a id="4778" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4780" href="Data.Nat.Properties.html#22029" class="Function">*-assoc</a> <a id="4788" href="README.Data.Wrap.html#4744" class="Bound">n</a> <a id="4790" href="README.Data.Wrap.html#4748" class="Bound">o</a> <a id="4792" href="README.Data.Wrap.html#4752" class="Bound">p</a> <a id="4794" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4796" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

    <a id="4806" class="Comment">-- We must give at least some arguments to `*-assoc`, as Agda is unable to</a>
    <a id="4885" class="Comment">-- unify `? * ? * ?` with `n * o * p`, as `_*_` is a function and not</a>
    <a id="4959" class="Comment">-- necessarily injective (and indeed not injective when one of its</a>
    <a id="5030" class="Comment">-- arguments is 0).</a>

    <a id="5055" class="Comment">-- We now want to use this lemma in a more complex proof:</a>
    <a id="5117" class="Comment">--         m            m</a>
    <a id="5147" class="Comment">--        /*\          /*\</a>
    <a id="5178" class="Comment">--     nop   q        n   opq</a>
    <a id="5212" class="Comment">--     /*\      ----&gt;     /*\</a>
    <a id="5246" class="Comment">--   no   p              o   pq</a>
    <a id="5282" class="Comment">--  /*\                      /*\</a>
    <a id="5319" class="Comment">-- n   o                    p   q</a>

    <a id="Unification.Naïve.test"></a><a id="5358" href="README.Data.Wrap.html#5358" class="Function">test</a> <a id="5363" class="Symbol">:</a> <a id="5365" class="Symbol">∀</a> <a id="5367" class="Symbol">{</a><a id="5368" href="README.Data.Wrap.html#5368" class="Bound">m</a> <a id="5370" href="README.Data.Wrap.html#5370" class="Bound">n</a> <a id="5372" href="README.Data.Wrap.html#5372" class="Bound">o</a> <a id="5374" href="README.Data.Wrap.html#5374" class="Bound">p</a> <a id="5376" href="README.Data.Wrap.html#5376" class="Bound">q</a><a id="5377" class="Symbol">}</a> <a id="5379" class="Symbol">→</a>
           <a id="5392" class="Symbol">(</a><a id="5393" href="Data.Product.Base.html#907" class="Function">∃₂</a> <a id="5396" class="Symbol">λ</a> <a id="5398" href="README.Data.Wrap.html#5398" class="Bound">no</a> <a id="5401" href="README.Data.Wrap.html#5401" class="Bound">nop</a> <a id="5405" class="Symbol">→</a> <a id="5407" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="5414" href="README.Data.Wrap.html#5368" class="Bound">m</a> <a id="5416" href="README.Data.Wrap.html#5401" class="Bound">nop</a> <a id="5420" href="README.Data.Wrap.html#5376" class="Bound">q</a> <a id="5422" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5424" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="5431" href="README.Data.Wrap.html#5401" class="Bound">nop</a> <a id="5435" href="README.Data.Wrap.html#5398" class="Bound">no</a> <a id="5438" href="README.Data.Wrap.html#5374" class="Bound">p</a> <a id="5440" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5442" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="5449" href="README.Data.Wrap.html#5398" class="Bound">no</a> <a id="5452" href="README.Data.Wrap.html#5370" class="Bound">n</a> <a id="5454" href="README.Data.Wrap.html#5372" class="Bound">o</a><a id="5455" class="Symbol">)</a> <a id="5457" class="Symbol">→</a>
           <a id="5470" class="Symbol">(</a><a id="5471" href="Data.Product.Base.html#907" class="Function">∃₂</a> <a id="5474" class="Symbol">λ</a> <a id="5476" href="README.Data.Wrap.html#5476" class="Bound">pq</a> <a id="5479" href="README.Data.Wrap.html#5479" class="Bound">opq</a> <a id="5483" class="Symbol">→</a> <a id="5485" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="5492" href="README.Data.Wrap.html#5368" class="Bound">m</a> <a id="5494" href="README.Data.Wrap.html#5370" class="Bound">n</a> <a id="5496" href="README.Data.Wrap.html#5479" class="Bound">opq</a> <a id="5500" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5502" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="5509" href="README.Data.Wrap.html#5479" class="Bound">opq</a> <a id="5513" href="README.Data.Wrap.html#5372" class="Bound">o</a> <a id="5515" href="README.Data.Wrap.html#5476" class="Bound">pq</a> <a id="5518" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5520" href="README.Data.Wrap.html#4247" class="Function">Factor</a> <a id="5527" href="README.Data.Wrap.html#5476" class="Bound">pq</a> <a id="5530" href="README.Data.Wrap.html#5374" class="Bound">p</a> <a id="5532" href="README.Data.Wrap.html#5376" class="Bound">q</a><a id="5533" class="Symbol">)</a>
    <a id="5539" href="README.Data.Wrap.html#5358" class="Function">test</a> <a id="5544" class="Symbol">{</a><a id="5545" class="Argument">n</a> <a id="5547" class="Symbol">=</a> <a id="5549" href="README.Data.Wrap.html#5549" class="Bound">n</a><a id="5550" class="Symbol">}</a> <a id="5552" class="Symbol">(</a><a id="5553" href="README.Data.Wrap.html#5553" class="Bound">no</a> <a id="5556" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5558" href="README.Data.Wrap.html#5558" class="Bound">nop</a> <a id="5562" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5564" href="README.Data.Wrap.html#5564" class="Bound">fm</a> <a id="5567" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5569" href="README.Data.Wrap.html#5569" class="Bound">fnop</a> <a id="5574" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5576" href="README.Data.Wrap.html#5576" class="Bound">fno</a><a id="5579" class="Symbol">)</a> <a id="5581" class="Symbol">=</a>
      <a id="5589" class="Keyword">let</a> <a id="5593" class="Symbol">_</a> <a id="5595" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5597" href="README.Data.Wrap.html#5597" class="Bound">fm</a> <a id="5600" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5602" href="README.Data.Wrap.html#5602" class="Bound">fpq</a> <a id="5606" class="Symbol">=</a> <a id="5608" href="README.Data.Wrap.html#4591" class="Function">assoc-→</a> <a id="5616" class="Symbol">{</a><a id="5617" class="Argument">n</a> <a id="5619" class="Symbol">=</a> <a id="5621" href="README.Data.Wrap.html#5553" class="Bound">no</a><a id="5623" class="Symbol">}</a> <a id="5625" class="Symbol">(_</a> <a id="5628" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5630" href="README.Data.Wrap.html#5564" class="Bound">fm</a> <a id="5633" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5635" href="README.Data.Wrap.html#5569" class="Bound">fnop</a><a id="5639" class="Symbol">)</a> <a id="5641" class="Keyword">in</a>
      <a id="5650" class="Keyword">let</a> <a id="5654" class="Symbol">_</a> <a id="5656" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5658" href="README.Data.Wrap.html#5658" class="Bound">fm</a> <a id="5661" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5663" href="README.Data.Wrap.html#5663" class="Bound">fopq</a> <a id="5668" class="Symbol">=</a> <a id="5670" href="README.Data.Wrap.html#4591" class="Function">assoc-→</a> <a id="5678" class="Symbol">{</a><a id="5679" class="Argument">n</a> <a id="5681" class="Symbol">=</a> <a id="5683" href="README.Data.Wrap.html#5549" class="Bound">n</a><a id="5684" class="Symbol">}</a> <a id="5686" class="Symbol">(_</a> <a id="5689" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5691" href="README.Data.Wrap.html#5597" class="Bound">fm</a> <a id="5694" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5696" href="README.Data.Wrap.html#5576" class="Bound">fno</a><a id="5699" class="Symbol">)</a> <a id="5701" class="Keyword">in</a>
      <a id="5710" class="Symbol">_</a> <a id="5712" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5714" class="Symbol">_</a> <a id="5716" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5718" href="README.Data.Wrap.html#5658" class="Bound">fm</a> <a id="5721" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5723" href="README.Data.Wrap.html#5663" class="Bound">fopq</a> <a id="5728" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5730" href="README.Data.Wrap.html#5602" class="Bound">fpq</a>

    <a id="5739" class="Comment">-- This works okay, but where we have written `{n = no}` and similar, we</a>
    <a id="5816" class="Comment">-- are being forced to deal with details we don&#39;t really care about. Agda</a>
    <a id="5894" class="Comment">-- should be able to fill in the vertices given part of a tree, but can&#39;t</a>
    <a id="5972" class="Comment">-- due to similar reasons as before: `Factor ? ? ?` doesn&#39;t unify against</a>
    <a id="6050" class="Comment">-- `Factor m no p`, because both instances of `Factor` compute and we&#39;re</a>
    <a id="6127" class="Comment">-- left trying to unify `? * ?` against `no * p`.</a>

  <a id="6180" class="Keyword">module</a> <a id="Unification.Wrapped"></a><a id="6187" href="README.Data.Wrap.html#6187" class="Module">Wrapped</a> <a id="6195" class="Keyword">where</a>

    <a id="6206" class="Comment">-- We can use `Wrap` to stop the computation of `Factor`.</a>

    <a id="Unification.Wrapped.Factor"></a><a id="6269" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="6276" class="Symbol">:</a> <a id="6278" class="Symbol">(</a><a id="6279" href="README.Data.Wrap.html#6279" class="Bound">m</a> <a id="6281" href="README.Data.Wrap.html#6281" class="Bound">n</a> <a id="6283" href="README.Data.Wrap.html#6283" class="Bound">o</a> <a id="6285" class="Symbol">:</a> <a id="6287" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="6288" class="Symbol">)</a> <a id="6290" class="Symbol">→</a> <a id="6292" href="Agda.Primitive.html#320" class="Primitive">Set</a>
    <a id="6300" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="6307" class="Symbol">=</a> <a id="6309" href="Data.Wrap.html#743" class="Function">Wrap</a> <a id="6314" class="Symbol">λ</a> <a id="6316" href="README.Data.Wrap.html#6316" class="Bound">m</a> <a id="6318" href="README.Data.Wrap.html#6318" class="Bound">n</a> <a id="6320" href="README.Data.Wrap.html#6320" class="Bound">o</a> <a id="6322" class="Symbol">→</a> <a id="6324" href="README.Data.Wrap.html#6316" class="Bound">m</a> <a id="6326" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="6328" href="README.Data.Wrap.html#6318" class="Bound">n</a> <a id="6330" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="6332" href="README.Data.Wrap.html#6320" class="Bound">o</a>

    <a id="6339" class="Comment">-- Because `assoc-→` needs access to the implementation of `Factor`, the</a>
    <a id="6416" class="Comment">-- proof is exactly as before except for using `[_]` to wrap and unwrap.</a>

    <a id="Unification.Wrapped.assoc-→"></a><a id="6494" href="README.Data.Wrap.html#6494" class="Function">assoc-→</a> <a id="6502" class="Symbol">:</a> <a id="6504" class="Symbol">∀</a> <a id="6506" class="Symbol">{</a><a id="6507" href="README.Data.Wrap.html#6507" class="Bound">m</a> <a id="6509" href="README.Data.Wrap.html#6509" class="Bound">n</a> <a id="6511" href="README.Data.Wrap.html#6511" class="Bound">o</a> <a id="6513" href="README.Data.Wrap.html#6513" class="Bound">p</a><a id="6514" class="Symbol">}</a> <a id="6516" class="Symbol">→</a>
              <a id="6532" class="Symbol">(</a><a id="6533" href="Data.Product.Base.html#852" class="Function">∃</a> <a id="6535" class="Symbol">λ</a> <a id="6537" href="README.Data.Wrap.html#6537" class="Bound">no</a> <a id="6540" class="Symbol">→</a> <a id="6542" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="6549" href="README.Data.Wrap.html#6507" class="Bound">m</a> <a id="6551" href="README.Data.Wrap.html#6537" class="Bound">no</a> <a id="6554" href="README.Data.Wrap.html#6513" class="Bound">p</a> <a id="6556" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6558" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="6565" href="README.Data.Wrap.html#6537" class="Bound">no</a> <a id="6568" href="README.Data.Wrap.html#6509" class="Bound">n</a> <a id="6570" href="README.Data.Wrap.html#6511" class="Bound">o</a><a id="6571" class="Symbol">)</a> <a id="6573" class="Symbol">→</a>
              <a id="6589" class="Symbol">(</a><a id="6590" href="Data.Product.Base.html#852" class="Function">∃</a> <a id="6592" class="Symbol">λ</a> <a id="6594" href="README.Data.Wrap.html#6594" class="Bound">op</a> <a id="6597" class="Symbol">→</a> <a id="6599" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="6606" href="README.Data.Wrap.html#6507" class="Bound">m</a> <a id="6608" href="README.Data.Wrap.html#6509" class="Bound">n</a> <a id="6610" href="README.Data.Wrap.html#6594" class="Bound">op</a> <a id="6613" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6615" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="6622" href="README.Data.Wrap.html#6594" class="Bound">op</a> <a id="6625" href="README.Data.Wrap.html#6511" class="Bound">o</a> <a id="6627" href="README.Data.Wrap.html#6513" class="Bound">p</a><a id="6628" class="Symbol">)</a>
    <a id="6634" href="README.Data.Wrap.html#6494" class="Function">assoc-→</a> <a id="6642" class="Symbol">{</a><a id="6643" href="README.Data.Wrap.html#6643" class="Bound">m</a><a id="6644" class="Symbol">}</a> <a id="6646" class="Symbol">{</a><a id="6647" href="README.Data.Wrap.html#6647" class="Bound">n</a><a id="6648" class="Symbol">}</a> <a id="6650" class="Symbol">{</a><a id="6651" href="README.Data.Wrap.html#6651" class="Bound">o</a><a id="6652" class="Symbol">}</a> <a id="6654" class="Symbol">{</a><a id="6655" href="README.Data.Wrap.html#6655" class="Bound">p</a><a id="6656" class="Symbol">}</a> <a id="6658" class="Symbol">(</a><a id="6659" class="DottedPattern Symbol">._</a> <a id="6662" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6664" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="6666" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="6671" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a> <a id="6673" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6675" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="6677" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="6682" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a><a id="6683" class="Symbol">)</a> <a id="6685" class="Symbol">=</a>
      <a id="6693" class="Symbol">_</a> <a id="6695" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6697" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="6699" href="Data.Nat.Properties.html#22029" class="Function">*-assoc</a> <a id="6707" href="README.Data.Wrap.html#6647" class="Bound">n</a> <a id="6709" href="README.Data.Wrap.html#6651" class="Bound">o</a> <a id="6711" href="README.Data.Wrap.html#6655" class="Bound">p</a> <a id="6713" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a> <a id="6715" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6717" href="Data.Wrap.html#685" class="InductiveConstructor Operator">[</a> <a id="6719" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="6724" href="Data.Wrap.html#685" class="InductiveConstructor Operator">]</a>

    <a id="6731" class="Comment">-- The difference is that now we have our basic lemma, the complex proof</a>
    <a id="6808" class="Comment">-- can work purely in terms of `Factor` trees. In particular,</a>
    <a id="6874" class="Comment">-- `Factor ? ? ?` now does unify with `Factor m no p`, so we don&#39;t have to</a>
    <a id="6953" class="Comment">-- give `no` explicitly again.</a>

    <a id="Unification.Wrapped.test"></a><a id="6989" href="README.Data.Wrap.html#6989" class="Function">test</a> <a id="6994" class="Symbol">:</a> <a id="6996" class="Symbol">∀</a> <a id="6998" class="Symbol">{</a><a id="6999" href="README.Data.Wrap.html#6999" class="Bound">m</a> <a id="7001" href="README.Data.Wrap.html#7001" class="Bound">n</a> <a id="7003" href="README.Data.Wrap.html#7003" class="Bound">o</a> <a id="7005" href="README.Data.Wrap.html#7005" class="Bound">p</a> <a id="7007" href="README.Data.Wrap.html#7007" class="Bound">q</a><a id="7008" class="Symbol">}</a> <a id="7010" class="Symbol">→</a>
           <a id="7023" class="Symbol">(</a><a id="7024" href="Data.Product.Base.html#907" class="Function">∃₂</a> <a id="7027" class="Symbol">λ</a> <a id="7029" href="README.Data.Wrap.html#7029" class="Bound">no</a> <a id="7032" href="README.Data.Wrap.html#7032" class="Bound">nop</a> <a id="7036" class="Symbol">→</a> <a id="7038" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="7045" href="README.Data.Wrap.html#6999" class="Bound">m</a> <a id="7047" href="README.Data.Wrap.html#7032" class="Bound">nop</a> <a id="7051" href="README.Data.Wrap.html#7007" class="Bound">q</a> <a id="7053" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7055" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="7062" href="README.Data.Wrap.html#7032" class="Bound">nop</a> <a id="7066" href="README.Data.Wrap.html#7029" class="Bound">no</a> <a id="7069" href="README.Data.Wrap.html#7005" class="Bound">p</a> <a id="7071" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7073" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="7080" href="README.Data.Wrap.html#7029" class="Bound">no</a> <a id="7083" href="README.Data.Wrap.html#7001" class="Bound">n</a> <a id="7085" href="README.Data.Wrap.html#7003" class="Bound">o</a><a id="7086" class="Symbol">)</a> <a id="7088" class="Symbol">→</a>
           <a id="7101" class="Symbol">(</a><a id="7102" href="Data.Product.Base.html#907" class="Function">∃₂</a> <a id="7105" class="Symbol">λ</a> <a id="7107" href="README.Data.Wrap.html#7107" class="Bound">pq</a> <a id="7110" href="README.Data.Wrap.html#7110" class="Bound">opq</a> <a id="7114" class="Symbol">→</a> <a id="7116" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="7123" href="README.Data.Wrap.html#6999" class="Bound">m</a> <a id="7125" href="README.Data.Wrap.html#7001" class="Bound">n</a> <a id="7127" href="README.Data.Wrap.html#7110" class="Bound">opq</a> <a id="7131" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7133" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="7140" href="README.Data.Wrap.html#7110" class="Bound">opq</a> <a id="7144" href="README.Data.Wrap.html#7003" class="Bound">o</a> <a id="7146" href="README.Data.Wrap.html#7107" class="Bound">pq</a> <a id="7149" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7151" href="README.Data.Wrap.html#6269" class="Function">Factor</a> <a id="7158" href="README.Data.Wrap.html#7107" class="Bound">pq</a> <a id="7161" href="README.Data.Wrap.html#7005" class="Bound">p</a> <a id="7163" href="README.Data.Wrap.html#7007" class="Bound">q</a><a id="7164" class="Symbol">)</a>
    <a id="7170" href="README.Data.Wrap.html#6989" class="Function">test</a> <a id="7175" class="Symbol">(_</a> <a id="7178" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7180" class="Symbol">_</a> <a id="7182" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7184" href="README.Data.Wrap.html#7184" class="Bound">fm</a> <a id="7187" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7189" href="README.Data.Wrap.html#7189" class="Bound">fnop</a> <a id="7194" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7196" href="README.Data.Wrap.html#7196" class="Bound">fno</a><a id="7199" class="Symbol">)</a> <a id="7201" class="Symbol">=</a>
      <a id="7209" class="Keyword">let</a> <a id="7213" class="Symbol">_</a> <a id="7215" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7217" href="README.Data.Wrap.html#7217" class="Bound">fm</a> <a id="7220" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7222" href="README.Data.Wrap.html#7222" class="Bound">fpq</a> <a id="7226" class="Symbol">=</a> <a id="7228" href="README.Data.Wrap.html#6494" class="Function">assoc-→</a> <a id="7236" class="Symbol">(_</a> <a id="7239" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7241" href="README.Data.Wrap.html#7184" class="Bound">fm</a> <a id="7244" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7246" href="README.Data.Wrap.html#7189" class="Bound">fnop</a><a id="7250" class="Symbol">)</a> <a id="7252" class="Keyword">in</a>
      <a id="7261" class="Keyword">let</a> <a id="7265" class="Symbol">_</a> <a id="7267" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7269" href="README.Data.Wrap.html#7269" class="Bound">fm</a> <a id="7272" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7274" href="README.Data.Wrap.html#7274" class="Bound">fopq</a> <a id="7279" class="Symbol">=</a> <a id="7281" href="README.Data.Wrap.html#6494" class="Function">assoc-→</a> <a id="7289" class="Symbol">(_</a> <a id="7292" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7294" href="README.Data.Wrap.html#7217" class="Bound">fm</a> <a id="7297" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7299" href="README.Data.Wrap.html#7196" class="Bound">fno</a><a id="7302" class="Symbol">)</a> <a id="7304" class="Keyword">in</a>
      <a id="7313" class="Symbol">_</a> <a id="7315" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7317" class="Symbol">_</a> <a id="7319" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7321" href="README.Data.Wrap.html#7269" class="Bound">fm</a> <a id="7324" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7326" href="README.Data.Wrap.html#7274" class="Bound">fopq</a> <a id="7331" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7333" href="README.Data.Wrap.html#7222" class="Bound">fpq</a>
</pre></body></html>