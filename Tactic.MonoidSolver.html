<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.MonoidSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Reflection-based solver for monoid equalities</a>
<a id="155" class="Comment">------------------------------------------------------------------------</a>
<a id="228" class="Comment">--</a>
<a id="231" class="Comment">-- This solver automates the construction of proofs of equivalences</a>
<a id="299" class="Comment">-- between monoid expressions.</a>
<a id="330" class="Comment">-- When called like so:</a>
<a id="354" class="Comment">--</a>
<a id="357" class="Comment">--   proof : ∀ x y z → (x ∙ y) ∙ z ≈ x ∙ (y ∙ z) ∙ ε</a>
<a id="410" class="Comment">--   proof x y z = solve mon</a>
<a id="439" class="Comment">--</a>
<a id="442" class="Comment">-- The following diagram describes what happens under the hood:</a>
<a id="506" class="Comment">--</a>
<a id="509" class="Comment">--            ┌▸x ∙ (y ∙ (z ∙ ε)) ════ x ∙ (y ∙ (z ∙ ε))◂┐</a>
<a id="568" class="Comment">--            │         ║                      ║         │</a>
<a id="627" class="Comment">--            │         ║                      ║         │</a>
<a id="686" class="Comment">--          [_⇓]        ║                      ║        [_⇓]</a>
<a id="747" class="Comment">--          ╱           ║                      ║          ╲</a>
<a id="807" class="Comment">--         ╱            ║                      ║           ╲</a>
<a id="868" class="Comment">-- (x ∙′ y) ∙′ z      homo                   homo    x ∙′ (y ∙′ z) ∙′ ε′</a>
<a id="941" class="Comment">--   ▴     ╲            ║                      ║           ╱       ▴</a>
<a id="1010" class="Comment">--   │      ╲           ║                      ║          ╱        │</a>
<a id="1079" class="Comment">--   │       [_↓]       ║                      ║        [_↓]       │</a>
<a id="1148" class="Comment">--   │        │         ║                      ║         │         │</a>
<a id="1217" class="Comment">--   │        │         ║                      ║         │         │</a>
<a id="1286" class="Comment">--   │        └───▸(x ∙ y) ∙ z          x ∙ (y ∙ z) ∙ ε◂─┘         │</a>
<a id="1355" class="Comment">--   │                  │                      │                   │</a>
<a id="1424" class="Comment">--   │                  │                      │                   │</a>
<a id="1493" class="Comment">--   └────reflection────┘                      └───reflection──────┘</a>
<a id="1562" class="Comment">--</a>
<a id="1565" class="Comment">-- The actual output—the proof constructed by the solver—is represented</a>
<a id="1637" class="Comment">-- by the double-lined path (══).</a>
<a id="1671" class="Comment">--</a>
<a id="1674" class="Comment">-- We start at the bottom, with our two expressions.</a>
<a id="1727" class="Comment">-- Through reflection, we convert these two expressions to their AST</a>
<a id="1796" class="Comment">-- representations, in the Expr type.</a>
<a id="1834" class="Comment">-- We then can evaluate the AST in two ways: one simply gives us back</a>
<a id="1904" class="Comment">-- the two expressions we put in ([_↓]), and the other normalises</a>
<a id="1970" class="Comment">-- ([_⇓]).</a>
<a id="1981" class="Comment">-- We use the homo function to prove equivalence between these two</a>
<a id="2048" class="Comment">-- forms: joining up these two proofs gives us the desired overall</a>
<a id="2115" class="Comment">-- proof.</a>

<a id="2126" class="Comment">-- Note: What&#39;s going on with the Monoid parameter?</a>
<a id="2178" class="Comment">--</a>
<a id="2181" class="Comment">-- This module is not parameterised over a monoid, which is contrary</a>
<a id="2250" class="Comment">-- to what you might expect. Instead, we take the monoid record as an</a>
<a id="2320" class="Comment">-- argument to the solve macro, and then pass it around as an</a>
<a id="2382" class="Comment">-- argument wherever we need it.</a>
<a id="2415" class="Comment">--</a>
<a id="2418" class="Comment">-- We need to get the monoid record at the call site, not the import</a>
<a id="2487" class="Comment">-- site, to ensure that it&#39;s consistent with the rest of the context.</a>
<a id="2557" class="Comment">-- For instance, if we wanted to produce `x ∙ y` using the monoid record</a>
<a id="2630" class="Comment">-- as imported, we would run into problems:</a>
<a id="2674" class="Comment">-- * If we tried to just reflect on the expression itself</a>
<a id="2732" class="Comment">--   (quoteTerm (x ∙ y)) we would likely get some de Bruijn indices</a>
<a id="2800" class="Comment">--   wrong (in x and y), and ∙ might not even be in scope where the</a>
<a id="2868" class="Comment">--   user wants us to solve! If they&#39;re solving an expression like</a>
<a id="2935" class="Comment">--   x + (y + z), they can pass in the +-0-monoid, but don&#39;t have to</a>
<a id="3004" class="Comment">--   open it themselves.</a>
<a id="3029" class="Comment">-- * If instead we tried to construct a term which accesses the _∙_</a>
<a id="3097" class="Comment">--   field on the reflection of the record, we&#39;d run into similar</a>
<a id="3163" class="Comment">--   problems again. While the record is a parameter for us, it might</a>
<a id="3233" class="Comment">--   not be for the user.</a>
<a id="3259" class="Comment">-- Basically, we need the Monoid we&#39;re looking at to be exactly the</a>
<a id="3327" class="Comment">-- same as the one the user is looking at, and in order to do that we</a>
<a id="3397" class="Comment">-- quote it at the call site.</a>

<a id="3428" class="Symbol">{-#</a> <a id="3432" class="Keyword">OPTIONS</a> <a id="3440" class="Pragma">--cubical-compatible</a> <a id="3461" class="Pragma">--safe</a> <a id="3468" class="Symbol">#-}</a>

<a id="3473" class="Keyword">module</a> <a id="3480" href="Tactic.MonoidSolver.html" class="Module">Tactic.MonoidSolver</a> <a id="3500" class="Keyword">where</a>

<a id="3507" class="Keyword">open</a> <a id="3512" class="Keyword">import</a> <a id="3519" href="Algebra.html" class="Module">Algebra</a>
<a id="3527" class="Keyword">open</a> <a id="3532" class="Keyword">import</a> <a id="3539" href="Function.Base.html" class="Module">Function.Base</a> <a id="3553" class="Keyword">using</a> <a id="3559" class="Symbol">(</a><a id="3560" href="Function.Base.html#4339" class="Function Operator">_⟨_⟩_</a><a id="3565" class="Symbol">)</a>

<a id="3568" class="Keyword">open</a> <a id="3573" class="Keyword">import</a> <a id="3580" href="Data.Bool.html" class="Module">Data.Bool</a>         <a id="3598" class="Symbol">as</a> <a id="3601" class="Module">Bool</a>    <a id="3609" class="Keyword">using</a> <a id="3615" class="Symbol">(</a><a id="3616" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="3620" class="Symbol">;</a> <a id="3622" href="Data.Bool.Base.html#1053" class="Function Operator">_∨_</a><a id="3625" class="Symbol">;</a> <a id="3627" href="Data.Bool.Base.html#1292" class="Function Operator">if_then_else_</a><a id="3640" class="Symbol">)</a>
<a id="3642" class="Keyword">open</a> <a id="3647" class="Keyword">import</a> <a id="3654" href="Data.Maybe.html" class="Module">Data.Maybe</a>        <a id="3672" class="Symbol">as</a> <a id="3675" class="Module">Maybe</a>   <a id="3683" class="Keyword">using</a> <a id="3689" class="Symbol">(</a><a id="3690" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a><a id="3695" class="Symbol">;</a> <a id="3697" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a><a id="3701" class="Symbol">;</a> <a id="3703" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a><a id="3710" class="Symbol">;</a> <a id="3712" href="Data.Maybe.Base.html#1391" class="Function">maybe</a><a id="3717" class="Symbol">)</a>
<a id="3719" class="Keyword">open</a> <a id="3724" class="Keyword">import</a> <a id="3731" href="Data.List.Base.html" class="Module">Data.List.Base</a>    <a id="3749" class="Symbol">as</a> <a id="3752" class="Module">List</a>    <a id="3760" class="Keyword">using</a> <a id="3766" class="Symbol">(</a><a id="3767" href="Agda.Builtin.List.html#130" class="Datatype">List</a><a id="3771" class="Symbol">;</a> <a id="3773" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">_∷_</a><a id="3776" class="Symbol">;</a> <a id="3778" href="Data.List.Base.html#7375" class="InductiveConstructor">[]</a><a id="3780" class="Symbol">)</a>
<a id="3782" class="Keyword">open</a> <a id="3787" class="Keyword">import</a> <a id="3794" href="Data.Nat.html" class="Module">Data.Nat</a>          <a id="3812" class="Symbol">as</a> <a id="3815" class="Module">ℕ</a>       <a id="3823" class="Keyword">using</a> <a id="3829" class="Symbol">(</a><a id="3830" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="3831" class="Symbol">;</a> <a id="3833" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="3836" class="Symbol">;</a> <a id="3838" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="3842" class="Symbol">)</a>
<a id="3844" class="Keyword">open</a> <a id="3849" class="Keyword">import</a> <a id="3856" href="Data.Product.html" class="Module">Data.Product</a>      <a id="3874" class="Symbol">as</a> <a id="3877" class="Module">Product</a> <a id="3885" class="Keyword">using</a> <a id="3891" class="Symbol">(</a><a id="3892" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="3895" class="Symbol">;</a> <a id="3897" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="3900" class="Symbol">)</a>

<a id="3903" class="Keyword">open</a> <a id="3908" class="Keyword">import</a> <a id="3915" href="Reflection.AST.html" class="Module">Reflection.AST</a>
<a id="3930" class="Keyword">open</a> <a id="3935" class="Keyword">import</a> <a id="3942" href="Reflection.AST.Term.html" class="Module">Reflection.AST.Term</a>
<a id="3962" class="Keyword">open</a> <a id="3967" class="Keyword">import</a> <a id="3974" href="Reflection.AST.Argument.html" class="Module">Reflection.AST.Argument</a>
<a id="3998" class="Keyword">import</a> <a id="4005" href="Reflection.AST.Name.html" class="Module">Reflection.AST.Name</a> <a id="4025" class="Symbol">as</a> <a id="4028" class="Module">Name</a>
<a id="4033" class="Keyword">open</a> <a id="4038" class="Keyword">import</a> <a id="4045" href="Reflection.TCM.html" class="Module">Reflection.TCM</a>
<a id="4060" class="Keyword">open</a> <a id="4065" class="Keyword">import</a> <a id="4072" href="Reflection.TCM.Syntax.html" class="Module">Reflection.TCM.Syntax</a>

<a id="4095" class="Keyword">import</a> <a id="4102" href="Relation.Binary.Reasoning.Setoid.html" class="Module">Relation.Binary.Reasoning.Setoid</a> <a id="4135" class="Symbol">as</a> <a id="4138" class="Module">SetoidReasoning</a>

<a id="4155" class="Comment">----------------------------------------------------------------------</a>
<a id="4226" class="Comment">-- The Expr type with homomorphism proofs</a>
<a id="4268" class="Comment">----------------------------------------------------------------------</a>

<a id="4340" class="Keyword">infixl</a> <a id="4347" class="Number">7</a> <a id="4349" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">_∙′_</a>
<a id="4354" class="Keyword">data</a> <a id="Expr"></a><a id="4359" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4364" class="Symbol">{</a><a id="4365" href="Tactic.MonoidSolver.html#4365" class="Bound">a</a><a id="4366" class="Symbol">}</a> <a id="4368" class="Symbol">(</a><a id="4369" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a> <a id="4371" class="Symbol">:</a> <a id="4373" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="4377" href="Tactic.MonoidSolver.html#4365" class="Bound">a</a><a id="4378" class="Symbol">)</a> <a id="4380" class="Symbol">:</a> <a id="4382" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="4386" href="Tactic.MonoidSolver.html#4365" class="Bound">a</a> <a id="4388" class="Keyword">where</a>
  <a id="Expr._∙′_"></a><a id="4396" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">_∙′_</a>  <a id="4402" class="Symbol">:</a> <a id="4404" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4409" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a> <a id="4411" class="Symbol">→</a> <a id="4413" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4418" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a> <a id="4420" class="Symbol">→</a> <a id="4422" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4427" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a>
  <a id="Expr.ε′"></a><a id="4431" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a>    <a id="4437" class="Symbol">:</a> <a id="4439" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4444" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a>
  <a id="Expr.[_↑]"></a><a id="4448" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[_↑]</a>  <a id="4454" class="Symbol">:</a> <a id="4456" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a> <a id="4458" class="Symbol">→</a> <a id="4460" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4465" href="Tactic.MonoidSolver.html#4369" class="Bound">A</a>

<a id="4468" class="Keyword">module</a> <a id="4475" href="Tactic.MonoidSolver.html#4475" class="Module">_</a> <a id="4477" class="Symbol">{</a><a id="4478" href="Tactic.MonoidSolver.html#4478" class="Bound">m₁</a> <a id="4481" href="Tactic.MonoidSolver.html#4481" class="Bound">m₂</a><a id="4483" class="Symbol">}</a> <a id="4485" class="Symbol">(</a><a id="4486" href="Tactic.MonoidSolver.html#4486" class="Bound">monoid</a> <a id="4493" class="Symbol">:</a> <a id="4495" href="Algebra.Bundles.html#6016" class="Record">Monoid</a> <a id="4502" href="Tactic.MonoidSolver.html#4478" class="Bound">m₁</a> <a id="4505" href="Tactic.MonoidSolver.html#4481" class="Bound">m₂</a><a id="4507" class="Symbol">)</a> <a id="4509" class="Keyword">where</a>

  <a id="4518" class="Keyword">open</a> <a id="4523" href="Algebra.Bundles.html#6016" class="Module">Monoid</a> <a id="4530" href="Tactic.MonoidSolver.html#4486" class="Bound">monoid</a>
  <a id="4539" class="Keyword">open</a> <a id="4544" href="Relation.Binary.Reasoning.Setoid.html" class="Module">SetoidReasoning</a> <a id="4560" href="Algebra.Structures.html#1390" class="Function">setoid</a>

  <a id="4570" class="Comment">-- Convert the AST to an expression (i.e. evaluate it) without</a>
  <a id="4635" class="Comment">-- normalising.</a>
  <a id="4653" href="Tactic.MonoidSolver.html#4653" class="Function Operator">[_↓]</a> <a id="4658" class="Symbol">:</a> <a id="4660" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="4665" href="Algebra.Bundles.html#6095" class="Field">Carrier</a> <a id="4673" class="Symbol">→</a> <a id="4675" href="Algebra.Bundles.html#6095" class="Field">Carrier</a>
  <a id="4685" href="Tactic.MonoidSolver.html#4653" class="Function Operator">[</a> <a id="4687" href="Tactic.MonoidSolver.html#4687" class="Bound">x</a> <a id="4689" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="4692" href="Tactic.MonoidSolver.html#4692" class="Bound">y</a>  <a id="4695" href="Tactic.MonoidSolver.html#4653" class="Function Operator">↓]</a> <a id="4698" class="Symbol">=</a> <a id="4700" href="Tactic.MonoidSolver.html#4653" class="Function Operator">[</a> <a id="4702" href="Tactic.MonoidSolver.html#4687" class="Bound">x</a> <a id="4704" href="Tactic.MonoidSolver.html#4653" class="Function Operator">↓]</a> <a id="4707" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="4709" href="Tactic.MonoidSolver.html#4653" class="Function Operator">[</a> <a id="4711" href="Tactic.MonoidSolver.html#4692" class="Bound">y</a> <a id="4713" href="Tactic.MonoidSolver.html#4653" class="Function Operator">↓]</a>
  <a id="4718" href="Tactic.MonoidSolver.html#4653" class="Function Operator">[</a> <a id="4720" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a>      <a id="4728" href="Tactic.MonoidSolver.html#4653" class="Function Operator">↓]</a> <a id="4731" class="Symbol">=</a> <a id="4733" href="Algebra.Bundles.html#6172" class="Field">ε</a>
  <a id="4737" href="Tactic.MonoidSolver.html#4653" class="Function Operator">[</a> <a id="4739" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[</a> <a id="4741" href="Tactic.MonoidSolver.html#4741" class="Bound">x</a> <a id="4743" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">↑]</a>  <a id="4747" href="Tactic.MonoidSolver.html#4653" class="Function Operator">↓]</a> <a id="4750" class="Symbol">=</a> <a id="4752" href="Tactic.MonoidSolver.html#4741" class="Bound">x</a>

  <a id="4757" class="Comment">-- Convert an AST to an expression (i.e. evaluate it) while</a>
  <a id="4819" class="Comment">-- normalising.</a>
  <a id="4837" class="Comment">--</a>
  <a id="4842" class="Comment">-- This first function actually converts an AST to the Cayley</a>
  <a id="4906" class="Comment">-- representation of the underlying monoid.</a>
  <a id="4952" class="Comment">-- This obeys the monoid laws up to beta-eta equality, which is the</a>
  <a id="5022" class="Comment">-- property which gives us the &quot;normalising&quot; behaviour we want.</a>
  <a id="5088" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[_⇓]′</a> <a id="5094" class="Symbol">:</a> <a id="5096" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="5101" href="Algebra.Bundles.html#6095" class="Field">Carrier</a> <a id="5109" class="Symbol">→</a> <a id="5111" href="Algebra.Bundles.html#6095" class="Field">Carrier</a> <a id="5119" class="Symbol">→</a> <a id="5121" href="Algebra.Bundles.html#6095" class="Field">Carrier</a>
  <a id="5131" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5133" href="Tactic.MonoidSolver.html#5133" class="Bound">x</a> <a id="5135" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="5138" href="Tactic.MonoidSolver.html#5138" class="Bound">y</a>  <a id="5141" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5145" href="Tactic.MonoidSolver.html#5145" class="Bound">z</a> <a id="5147" class="Symbol">=</a> <a id="5149" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5151" href="Tactic.MonoidSolver.html#5133" class="Bound">x</a> <a id="5153" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5157" class="Symbol">(</a><a id="5158" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5160" href="Tactic.MonoidSolver.html#5138" class="Bound">y</a> <a id="5162" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5166" href="Tactic.MonoidSolver.html#5145" class="Bound">z</a><a id="5167" class="Symbol">)</a>
  <a id="5171" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5173" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a>      <a id="5181" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5185" href="Tactic.MonoidSolver.html#5185" class="Bound">y</a> <a id="5187" class="Symbol">=</a> <a id="5189" href="Tactic.MonoidSolver.html#5185" class="Bound">y</a>
  <a id="5193" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5195" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[</a> <a id="5197" href="Tactic.MonoidSolver.html#5197" class="Bound">x</a> <a id="5199" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">↑]</a>  <a id="5203" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5207" href="Tactic.MonoidSolver.html#5207" class="Bound">y</a> <a id="5209" class="Symbol">=</a> <a id="5211" href="Tactic.MonoidSolver.html#5197" class="Bound">x</a> <a id="5213" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5215" href="Tactic.MonoidSolver.html#5207" class="Bound">y</a>

  <a id="5220" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[_⇓]</a> <a id="5225" class="Symbol">:</a> <a id="5227" href="Tactic.MonoidSolver.html#4359" class="Datatype">Expr</a> <a id="5232" href="Algebra.Bundles.html#6095" class="Field">Carrier</a> <a id="5240" class="Symbol">→</a> <a id="5242" href="Algebra.Bundles.html#6095" class="Field">Carrier</a>
  <a id="5252" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5254" href="Tactic.MonoidSolver.html#5254" class="Bound">x</a> <a id="5256" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5259" class="Symbol">=</a> <a id="5261" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5263" href="Tactic.MonoidSolver.html#5254" class="Bound">x</a> <a id="5265" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5269" href="Algebra.Bundles.html#6172" class="Field">ε</a>

  <a id="5274" href="Tactic.MonoidSolver.html#5274" class="Function">homo′</a> <a id="5280" class="Symbol">:</a> <a id="5282" class="Symbol">∀</a> <a id="5284" href="Tactic.MonoidSolver.html#5284" class="Bound">x</a> <a id="5286" href="Tactic.MonoidSolver.html#5286" class="Bound">y</a> <a id="5288" class="Symbol">→</a> <a id="5290" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5292" href="Tactic.MonoidSolver.html#5284" class="Bound">x</a> <a id="5294" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5297" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5299" href="Tactic.MonoidSolver.html#5286" class="Bound">y</a> <a id="5301" href="Algebra.Bundles.html#6116" class="Field Operator">≈</a> <a id="5303" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5305" href="Tactic.MonoidSolver.html#5284" class="Bound">x</a> <a id="5307" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5311" href="Tactic.MonoidSolver.html#5286" class="Bound">y</a>
  <a id="5315" href="Tactic.MonoidSolver.html#5274" class="Function">homo′</a> <a id="5321" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a> <a id="5324" href="Tactic.MonoidSolver.html#5324" class="Bound">y</a>       <a id="5332" class="Symbol">=</a> <a id="5334" href="Algebra.Structures.html#4136" class="Function">identityˡ</a> <a id="5344" href="Tactic.MonoidSolver.html#5324" class="Bound">y</a>
  <a id="5348" href="Tactic.MonoidSolver.html#5274" class="Function">homo′</a> <a id="5354" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[</a> <a id="5356" href="Tactic.MonoidSolver.html#5356" class="Bound">x</a> <a id="5358" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">↑]</a> <a id="5361" href="Tactic.MonoidSolver.html#5361" class="Bound">y</a>   <a id="5365" class="Symbol">=</a> <a id="5367" href="Algebra.Structures.html#1526" class="Function">∙-congʳ</a> <a id="5375" class="Symbol">(</a><a id="5376" href="Algebra.Structures.html#4197" class="Function">identityʳ</a> <a id="5386" href="Tactic.MonoidSolver.html#5356" class="Bound">x</a><a id="5387" class="Symbol">)</a>
  <a id="5391" href="Tactic.MonoidSolver.html#5274" class="Function">homo′</a> <a id="5397" class="Symbol">(</a><a id="5398" href="Tactic.MonoidSolver.html#5398" class="Bound">x</a> <a id="5400" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="5403" href="Tactic.MonoidSolver.html#5403" class="Bound">y</a><a id="5404" class="Symbol">)</a> <a id="5406" href="Tactic.MonoidSolver.html#5406" class="Bound">z</a> <a id="5408" class="Symbol">=</a> <a id="5410" href="Relation.Binary.Reasoning.Base.Single.html#1925" class="Function Operator">begin</a>
    <a id="5420" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5422" href="Tactic.MonoidSolver.html#5398" class="Bound">x</a> <a id="5424" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="5427" href="Tactic.MonoidSolver.html#5403" class="Bound">y</a> <a id="5429" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5432" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5434" href="Tactic.MonoidSolver.html#5406" class="Bound">z</a>       <a id="5442" href="Relation.Binary.Reasoning.Base.Single.html#2479" class="Function Operator">≡⟨⟩</a>
    <a id="5450" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5452" href="Tactic.MonoidSolver.html#5398" class="Bound">x</a> <a id="5454" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5458" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5460" href="Tactic.MonoidSolver.html#5403" class="Bound">y</a> <a id="5462" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5465" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5467" href="Tactic.MonoidSolver.html#5406" class="Bound">z</a>    <a id="5472" href="Relation.Binary.Reasoning.Setoid.html#1162" class="Function">≈˘⟨</a> <a id="5476" href="Algebra.Structures.html#1526" class="Function">∙-congʳ</a> <a id="5484" class="Symbol">(</a><a id="5485" href="Tactic.MonoidSolver.html#5274" class="Function">homo′</a> <a id="5491" href="Tactic.MonoidSolver.html#5398" class="Bound">x</a> <a id="5493" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5495" href="Tactic.MonoidSolver.html#5403" class="Bound">y</a> <a id="5497" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a><a id="5499" class="Symbol">)</a> <a id="5501" href="Relation.Binary.Reasoning.Setoid.html#1162" class="Function">⟩</a>
    <a id="5507" class="Symbol">(</a><a id="5508" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5510" href="Tactic.MonoidSolver.html#5398" class="Bound">x</a> <a id="5512" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5515" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5517" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5519" href="Tactic.MonoidSolver.html#5403" class="Bound">y</a> <a id="5521" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a><a id="5523" class="Symbol">)</a> <a id="5525" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5527" href="Tactic.MonoidSolver.html#5406" class="Bound">z</a> <a id="5529" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">≈⟨</a> <a id="5532" href="Algebra.Structures.html#2977" class="Function">assoc</a> <a id="5538" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5540" href="Tactic.MonoidSolver.html#5398" class="Bound">x</a> <a id="5542" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5545" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5547" href="Tactic.MonoidSolver.html#5403" class="Bound">y</a> <a id="5549" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5552" href="Tactic.MonoidSolver.html#5406" class="Bound">z</a> <a id="5554" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">⟩</a>
    <a id="5560" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5562" href="Tactic.MonoidSolver.html#5398" class="Bound">x</a> <a id="5564" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5567" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5569" class="Symbol">(</a><a id="5570" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5572" href="Tactic.MonoidSolver.html#5403" class="Bound">y</a> <a id="5574" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5577" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5579" href="Tactic.MonoidSolver.html#5406" class="Bound">z</a><a id="5580" class="Symbol">)</a> <a id="5582" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">≈⟨</a> <a id="5585" href="Algebra.Structures.html#1465" class="Function">∙-congˡ</a> <a id="5593" class="Symbol">(</a><a id="5594" href="Tactic.MonoidSolver.html#5274" class="Function">homo′</a> <a id="5600" href="Tactic.MonoidSolver.html#5403" class="Bound">y</a> <a id="5602" href="Tactic.MonoidSolver.html#5406" class="Bound">z</a><a id="5603" class="Symbol">)</a> <a id="5605" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">⟩</a>
    <a id="5611" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5613" href="Tactic.MonoidSolver.html#5398" class="Bound">x</a> <a id="5615" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5618" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5620" class="Symbol">(</a><a id="5621" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5623" href="Tactic.MonoidSolver.html#5403" class="Bound">y</a> <a id="5625" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5629" href="Tactic.MonoidSolver.html#5406" class="Bound">z</a><a id="5630" class="Symbol">)</a>  <a id="5633" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">≈⟨</a> <a id="5636" href="Tactic.MonoidSolver.html#5274" class="Function">homo′</a> <a id="5642" href="Tactic.MonoidSolver.html#5398" class="Bound">x</a> <a id="5644" class="Symbol">(</a><a id="5645" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5647" href="Tactic.MonoidSolver.html#5403" class="Bound">y</a> <a id="5649" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5653" href="Tactic.MonoidSolver.html#5406" class="Bound">z</a><a id="5654" class="Symbol">)</a> <a id="5656" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">⟩</a>
    <a id="5662" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5664" href="Tactic.MonoidSolver.html#5398" class="Bound">x</a> <a id="5666" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5670" class="Symbol">(</a><a id="5671" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5673" href="Tactic.MonoidSolver.html#5403" class="Bound">y</a> <a id="5675" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5679" href="Tactic.MonoidSolver.html#5406" class="Bound">z</a><a id="5680" class="Symbol">)</a>   <a id="5684" href="Relation.Binary.Reasoning.Base.Single.html#2564" class="Function Operator">∎</a>

  <a id="5689" href="Tactic.MonoidSolver.html#5689" class="Function">homo</a> <a id="5694" class="Symbol">:</a> <a id="5696" class="Symbol">∀</a> <a id="5698" href="Tactic.MonoidSolver.html#5698" class="Bound">x</a> <a id="5700" class="Symbol">→</a> <a id="5702" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5704" href="Tactic.MonoidSolver.html#5698" class="Bound">x</a> <a id="5706" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5709" href="Algebra.Bundles.html#6116" class="Field Operator">≈</a> <a id="5711" href="Tactic.MonoidSolver.html#4653" class="Function Operator">[</a> <a id="5713" href="Tactic.MonoidSolver.html#5698" class="Bound">x</a> <a id="5715" href="Tactic.MonoidSolver.html#4653" class="Function Operator">↓]</a>
  <a id="5720" href="Tactic.MonoidSolver.html#5689" class="Function">homo</a> <a id="5725" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a>       <a id="5734" class="Symbol">=</a> <a id="5736" href="Relation.Binary.Structures.html#1596" class="Function">refl</a>
  <a id="5743" href="Tactic.MonoidSolver.html#5689" class="Function">homo</a> <a id="5748" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[</a> <a id="5750" href="Tactic.MonoidSolver.html#5750" class="Bound">x</a> <a id="5752" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">↑]</a>   <a id="5757" class="Symbol">=</a> <a id="5759" href="Algebra.Structures.html#4197" class="Function">identityʳ</a> <a id="5769" href="Tactic.MonoidSolver.html#5750" class="Bound">x</a>
  <a id="5773" href="Tactic.MonoidSolver.html#5689" class="Function">homo</a> <a id="5778" class="Symbol">(</a><a id="5779" href="Tactic.MonoidSolver.html#5779" class="Bound">x</a> <a id="5781" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="5784" href="Tactic.MonoidSolver.html#5784" class="Bound">y</a><a id="5785" class="Symbol">)</a> <a id="5787" class="Symbol">=</a> <a id="5789" href="Relation.Binary.Reasoning.Base.Single.html#1925" class="Function Operator">begin</a>
    <a id="5799" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5801" href="Tactic.MonoidSolver.html#5779" class="Bound">x</a> <a id="5803" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">∙′</a> <a id="5806" href="Tactic.MonoidSolver.html#5784" class="Bound">y</a> <a id="5808" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a>     <a id="5815" href="Relation.Binary.Reasoning.Base.Single.html#2479" class="Function Operator">≡⟨⟩</a>
    <a id="5823" href="Tactic.MonoidSolver.html#5088" class="Function Operator">[</a> <a id="5825" href="Tactic.MonoidSolver.html#5779" class="Bound">x</a> <a id="5827" href="Tactic.MonoidSolver.html#5088" class="Function Operator">⇓]′</a> <a id="5831" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5833" href="Tactic.MonoidSolver.html#5784" class="Bound">y</a> <a id="5835" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a>  <a id="5839" href="Relation.Binary.Reasoning.Setoid.html#1162" class="Function">≈˘⟨</a> <a id="5843" href="Tactic.MonoidSolver.html#5274" class="Function">homo′</a> <a id="5849" href="Tactic.MonoidSolver.html#5779" class="Bound">x</a> <a id="5851" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5853" href="Tactic.MonoidSolver.html#5784" class="Bound">y</a> <a id="5855" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5858" href="Relation.Binary.Reasoning.Setoid.html#1162" class="Function">⟩</a>
    <a id="5864" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5866" href="Tactic.MonoidSolver.html#5779" class="Bound">x</a> <a id="5868" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5871" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5873" href="Tactic.MonoidSolver.html#5220" class="Function Operator">[</a> <a id="5875" href="Tactic.MonoidSolver.html#5784" class="Bound">y</a> <a id="5877" href="Tactic.MonoidSolver.html#5220" class="Function Operator">⇓]</a> <a id="5880" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">≈⟨</a> <a id="5883" href="Algebra.Structures.html#1315" class="Function">∙-cong</a> <a id="5890" class="Symbol">(</a><a id="5891" href="Tactic.MonoidSolver.html#5689" class="Function">homo</a> <a id="5896" href="Tactic.MonoidSolver.html#5779" class="Bound">x</a><a id="5897" class="Symbol">)</a> <a id="5899" class="Symbol">(</a><a id="5900" href="Tactic.MonoidSolver.html#5689" class="Function">homo</a> <a id="5905" href="Tactic.MonoidSolver.html#5784" class="Bound">y</a><a id="5906" class="Symbol">)</a> <a id="5908" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">⟩</a>
    <a id="5914" href="Tactic.MonoidSolver.html#4653" class="Function Operator">[</a> <a id="5916" href="Tactic.MonoidSolver.html#5779" class="Bound">x</a> <a id="5918" href="Tactic.MonoidSolver.html#4653" class="Function Operator">↓]</a> <a id="5921" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5923" href="Tactic.MonoidSolver.html#4653" class="Function Operator">[</a> <a id="5925" href="Tactic.MonoidSolver.html#5784" class="Bound">y</a> <a id="5927" href="Tactic.MonoidSolver.html#4653" class="Function Operator">↓]</a> <a id="5930" href="Relation.Binary.Reasoning.Base.Single.html#2564" class="Function Operator">∎</a>

<a id="5933" class="Comment">----------------------------------------------------------------------</a>
<a id="6004" class="Comment">-- Helpers for reflection</a>
<a id="6030" class="Comment">----------------------------------------------------------------------</a>

<a id="getArgs"></a><a id="6102" href="Tactic.MonoidSolver.html#6102" class="Function">getArgs</a> <a id="6110" class="Symbol">:</a> <a id="6112" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="6117" class="Symbol">→</a> <a id="6119" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="6125" class="Symbol">(</a><a id="6126" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="6131" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6133" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="6137" class="Symbol">)</a>
<a id="6139" href="Tactic.MonoidSolver.html#6102" class="Function">getArgs</a> <a id="6147" class="Symbol">(</a><a id="6148" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6152" class="Symbol">_</a> <a id="6154" href="Tactic.MonoidSolver.html#6154" class="Bound">xs</a><a id="6156" class="Symbol">)</a> <a id="6158" class="Symbol">=</a> <a id="6160" href="Tactic.MonoidSolver.html#6176" class="Function">go</a> <a id="6163" href="Tactic.MonoidSolver.html#6154" class="Bound">xs</a>
  <a id="6168" class="Keyword">where</a>
  <a id="6176" href="Tactic.MonoidSolver.html#6176" class="Function">go</a> <a id="6179" class="Symbol">:</a> <a id="6181" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="6186" class="Symbol">(</a><a id="6187" href="Agda.Builtin.Reflection.html#3679" class="Datatype">Arg</a> <a id="6191" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="6195" class="Symbol">)</a> <a id="6197" class="Symbol">→</a> <a id="6199" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="6205" class="Symbol">(</a><a id="6206" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="6211" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6213" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="6217" class="Symbol">)</a>
  <a id="6221" href="Tactic.MonoidSolver.html#6176" class="Function">go</a> <a id="6224" class="Symbol">(</a><a id="6225" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="6230" href="Tactic.MonoidSolver.html#6230" class="Bound">x</a> <a id="6232" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="6234" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="6239" href="Tactic.MonoidSolver.html#6239" class="Bound">y</a> <a id="6241" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="6243" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="6245" class="Symbol">)</a> <a id="6247" class="Symbol">=</a> <a id="6249" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="6254" class="Symbol">(</a><a id="6255" href="Tactic.MonoidSolver.html#6230" class="Bound">x</a> <a id="6257" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6259" href="Tactic.MonoidSolver.html#6239" class="Bound">y</a><a id="6260" class="Symbol">)</a>
  <a id="6264" href="Tactic.MonoidSolver.html#6176" class="CatchallClause Function">go</a><a id="6266" class="CatchallClause"> </a><a id="6267" class="CatchallClause Symbol">(</a><a id="6268" href="Tactic.MonoidSolver.html#6268" class="CatchallClause Bound">x</a><a id="6269" class="CatchallClause"> </a><a id="6270" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="6271" class="CatchallClause"> </a><a id="6272" href="Tactic.MonoidSolver.html#6272" class="CatchallClause Bound">xs</a><a id="6274" class="CatchallClause Symbol">)</a>               <a id="6290" class="Symbol">=</a> <a id="6292" href="Tactic.MonoidSolver.html#6176" class="Function">go</a> <a id="6295" href="Tactic.MonoidSolver.html#6272" class="Bound">xs</a>
  <a id="6300" href="Tactic.MonoidSolver.html#6176" class="CatchallClause Function">go</a><a id="6302" class="CatchallClause"> </a><a id="6303" class="CatchallClause Symbol">_</a>                      <a id="6326" class="Symbol">=</a> <a id="6328" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>
<a id="6336" href="Tactic.MonoidSolver.html#6102" class="CatchallClause Function">getArgs</a><a id="6343" class="CatchallClause"> </a><a id="6344" class="CatchallClause Symbol">_</a> <a id="6346" class="Symbol">=</a> <a id="6348" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>

<a id="6357" class="Comment">----------------------------------------------------------------------</a>
<a id="6428" class="Comment">-- Getting monoid names</a>
<a id="6452" class="Comment">----------------------------------------------------------------------</a>

<a id="6524" class="Comment">-- We try to be flexible here, by matching two kinds of names.</a>
<a id="6587" class="Comment">-- The first is the field accessor for the monoid record itself.</a>
<a id="6652" class="Comment">-- However, users will likely want to use the solver with</a>
<a id="6710" class="Comment">-- expressions like:</a>
<a id="6731" class="Comment">--</a>
<a id="6734" class="Comment">--   xs ++ (ys ++ zs) ≡ (xs ++ ys) ++ zs</a>
<a id="6775" class="Comment">--</a>
<a id="6778" class="Comment">-- So we also evaluate the field accessor to find functions like ++.</a>

<a id="6848" class="Keyword">record</a> <a id="MonoidNames"></a><a id="6855" href="Tactic.MonoidSolver.html#6855" class="Record">MonoidNames</a> <a id="6867" class="Symbol">:</a> <a id="6869" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="6873" class="Keyword">where</a>
  <a id="6881" class="Keyword">field</a>
    <a id="MonoidNames.is-∙"></a><a id="6891" href="Tactic.MonoidSolver.html#6891" class="Field">is-∙</a> <a id="6896" class="Symbol">:</a> <a id="6898" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="6903" class="Symbol">→</a> <a id="6905" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>
    <a id="MonoidNames.is-ε"></a><a id="6914" href="Tactic.MonoidSolver.html#6914" class="Field">is-ε</a> <a id="6919" class="Symbol">:</a> <a id="6921" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="6926" class="Symbol">→</a> <a id="6928" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>

<a id="buildMatcher"></a><a id="6934" href="Tactic.MonoidSolver.html#6934" class="Function">buildMatcher</a> <a id="6947" class="Symbol">:</a> <a id="6949" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="6954" class="Symbol">→</a> <a id="6956" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="6962" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="6967" class="Symbol">→</a> <a id="6969" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="6974" class="Symbol">→</a> <a id="6976" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>
<a id="6981" href="Tactic.MonoidSolver.html#6934" class="Function">buildMatcher</a> <a id="6994" href="Tactic.MonoidSolver.html#6994" class="Bound">n</a> <a id="6996" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>  <a id="7005" href="Tactic.MonoidSolver.html#7005" class="Bound">x</a> <a id="7007" class="Symbol">=</a> <a id="7009" href="Tactic.MonoidSolver.html#6994" class="Bound">n</a> <a id="7011" href="Agda.Builtin.Reflection.html#522" class="Primitive Operator">Name.≡ᵇ</a> <a id="7019" href="Tactic.MonoidSolver.html#7005" class="Bound">x</a>
<a id="7021" href="Tactic.MonoidSolver.html#6934" class="Function">buildMatcher</a> <a id="7034" href="Tactic.MonoidSolver.html#7034" class="Bound">n</a> <a id="7036" class="Symbol">(</a><a id="7037" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="7042" href="Tactic.MonoidSolver.html#7042" class="Bound">m</a><a id="7043" class="Symbol">)</a> <a id="7045" href="Tactic.MonoidSolver.html#7045" class="Bound">x</a> <a id="7047" class="Symbol">=</a> <a id="7049" href="Tactic.MonoidSolver.html#7034" class="Bound">n</a> <a id="7051" href="Agda.Builtin.Reflection.html#522" class="Primitive Operator">Name.≡ᵇ</a> <a id="7059" href="Tactic.MonoidSolver.html#7045" class="Bound">x</a> <a id="7061" href="Data.Bool.Base.html#1053" class="Function Operator">∨</a> <a id="7063" href="Tactic.MonoidSolver.html#7042" class="Bound">m</a> <a id="7065" href="Agda.Builtin.Reflection.html#522" class="Primitive Operator">Name.≡ᵇ</a> <a id="7073" href="Tactic.MonoidSolver.html#7045" class="Bound">x</a>

<a id="findMonoidNames"></a><a id="7076" href="Tactic.MonoidSolver.html#7076" class="Function">findMonoidNames</a> <a id="7092" class="Symbol">:</a> <a id="7094" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7099" class="Symbol">→</a> <a id="7101" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="7104" href="Tactic.MonoidSolver.html#6855" class="Record">MonoidNames</a>
<a id="7116" href="Tactic.MonoidSolver.html#7076" class="Function">findMonoidNames</a> <a id="7132" href="Tactic.MonoidSolver.html#7132" class="Bound">mon</a> <a id="7136" class="Symbol">=</a> <a id="7138" class="Keyword">do</a>
  <a id="7143" href="Tactic.MonoidSolver.html#7143" class="Bound">∙-altName</a> <a id="7153" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7155" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="7165" class="Symbol">(</a><a id="7166" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="7170" class="Symbol">(</a><a id="7171" class="Keyword">quote</a> <a id="7177" href="Algebra.Bundles.html#6145" class="Field Operator">Monoid._∙_</a><a id="7187" class="Symbol">)</a> <a id="7189" class="Symbol">(</a><a id="7190" class="Number">2</a> <a id="7192" href="Reflection.AST.Term.html#2962" class="Function Operator">⋯⟅∷⟆</a> <a id="7197" href="Tactic.MonoidSolver.html#7132" class="Bound">mon</a> <a id="7201" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7205" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7207" class="Symbol">))</a>
  <a id="7212" href="Tactic.MonoidSolver.html#7212" class="Bound">ε-altName</a> <a id="7222" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7224" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="7234" class="Symbol">(</a><a id="7235" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="7239" class="Symbol">(</a><a id="7240" class="Keyword">quote</a> <a id="7246" href="Algebra.Bundles.html#6172" class="Field">Monoid.ε</a><a id="7254" class="Symbol">)</a>   <a id="7258" class="Symbol">(</a><a id="7259" class="Number">2</a> <a id="7261" href="Reflection.AST.Term.html#2962" class="Function Operator">⋯⟅∷⟆</a> <a id="7266" href="Tactic.MonoidSolver.html#7132" class="Bound">mon</a> <a id="7270" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7274" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7276" class="Symbol">))</a>
  <a id="7281" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="7286" class="Keyword">record</a>
    <a id="7297" class="Symbol">{</a> <a id="7299" href="Tactic.MonoidSolver.html#6891" class="Field">is-∙</a> <a id="7304" class="Symbol">=</a> <a id="7306" href="Tactic.MonoidSolver.html#6934" class="Function">buildMatcher</a> <a id="7319" class="Symbol">(</a><a id="7320" class="Keyword">quote</a> <a id="7326" href="Algebra.Bundles.html#6145" class="Field Operator">Monoid._∙_</a><a id="7336" class="Symbol">)</a> <a id="7338" class="Symbol">(</a><a id="7339" href="Reflection.AST.Term.html#2330" class="Function">getName</a> <a id="7347" href="Tactic.MonoidSolver.html#7143" class="Bound">∙-altName</a><a id="7356" class="Symbol">)</a>
    <a id="7362" class="Symbol">;</a> <a id="7364" href="Tactic.MonoidSolver.html#6914" class="Field">is-ε</a> <a id="7369" class="Symbol">=</a> <a id="7371" href="Tactic.MonoidSolver.html#6934" class="Function">buildMatcher</a> <a id="7384" class="Symbol">(</a><a id="7385" class="Keyword">quote</a> <a id="7391" href="Algebra.Bundles.html#6172" class="Field">Monoid.ε</a><a id="7399" class="Symbol">)</a>   <a id="7403" class="Symbol">(</a><a id="7404" href="Reflection.AST.Term.html#2330" class="Function">getName</a> <a id="7412" href="Tactic.MonoidSolver.html#7212" class="Bound">ε-altName</a><a id="7421" class="Symbol">)</a>
    <a id="7427" class="Symbol">}</a>

<a id="7430" class="Comment">----------------------------------------------------------------------</a>
<a id="7501" class="Comment">-- Building Expr</a>
<a id="7518" class="Comment">----------------------------------------------------------------------</a>

<a id="7590" class="Comment">-- We now define a function that takes an AST representing the LHS</a>
<a id="7657" class="Comment">-- or RHS of the equation to solve and converts it into an AST</a>
<a id="7720" class="Comment">-- respresenting the corresponding Expr.</a>

<a id="″ε″"></a><a id="7762" href="Tactic.MonoidSolver.html#7762" class="Function">″ε″</a> <a id="7766" class="Symbol">:</a> <a id="7768" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="7773" href="Tactic.MonoidSolver.html#7762" class="Function">″ε″</a> <a id="7777" class="Symbol">=</a> <a id="7779" class="Keyword">quote</a> <a id="7785" href="Tactic.MonoidSolver.html#4431" class="InductiveConstructor">ε′</a> <a id="7788" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="7790" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="7794" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="7796" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>

<a id="[_↑]′"></a><a id="7800" href="Tactic.MonoidSolver.html#7800" class="Function Operator">[_↑]′</a> <a id="7806" class="Symbol">:</a> <a id="7808" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7813" class="Symbol">→</a> <a id="7815" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="7820" href="Tactic.MonoidSolver.html#7800" class="Function Operator">[</a> <a id="7822" href="Tactic.MonoidSolver.html#7822" class="Bound">t</a> <a id="7824" href="Tactic.MonoidSolver.html#7800" class="Function Operator">↑]′</a> <a id="7828" class="Symbol">=</a> <a id="7830" class="Keyword">quote</a> <a id="7836" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[_↑]</a> <a id="7841" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="7843" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="7847" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="7849" class="Symbol">(</a><a id="7850" href="Tactic.MonoidSolver.html#7822" class="Bound">t</a> <a id="7852" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7856" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7858" class="Symbol">)</a>

<a id="7861" class="Keyword">module</a> <a id="7868" href="Tactic.MonoidSolver.html#7868" class="Module">_</a> <a id="7870" class="Symbol">(</a><a id="7871" href="Tactic.MonoidSolver.html#7871" class="Bound">names</a> <a id="7877" class="Symbol">:</a> <a id="7879" href="Tactic.MonoidSolver.html#6855" class="Record">MonoidNames</a><a id="7890" class="Symbol">)</a> <a id="7892" class="Keyword">where</a>

 <a id="7900" class="Keyword">open</a> <a id="7905" href="Tactic.MonoidSolver.html#6855" class="Module">MonoidNames</a> <a id="7917" href="Tactic.MonoidSolver.html#7871" class="Bound">names</a>

 <a id="7925" class="Keyword">mutual</a>
  <a id="7934" href="Tactic.MonoidSolver.html#7934" class="Function">″∙″</a> <a id="7938" class="Symbol">:</a> <a id="7940" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="7945" class="Symbol">(</a><a id="7946" href="Agda.Builtin.Reflection.html#3679" class="Datatype">Arg</a> <a id="7950" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="7954" class="Symbol">)</a> <a id="7956" class="Symbol">→</a> <a id="7958" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="7965" href="Tactic.MonoidSolver.html#7934" class="Function">″∙″</a> <a id="7969" class="Symbol">(</a><a id="7970" href="Tactic.MonoidSolver.html#7970" class="Bound">x</a> <a id="7972" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7976" href="Tactic.MonoidSolver.html#7976" class="Bound">y</a> <a id="7978" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7982" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7984" class="Symbol">)</a> <a id="7986" class="Symbol">=</a> <a id="7988" class="Keyword">quote</a> <a id="7994" href="Tactic.MonoidSolver.html#4396" class="InductiveConstructor Operator">_∙′_</a> <a id="7999" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="8001" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="8005" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="8007" href="Tactic.MonoidSolver.html#8110" class="Function">buildExpr</a> <a id="8017" href="Tactic.MonoidSolver.html#7970" class="Bound">x</a> <a id="8019" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8023" href="Tactic.MonoidSolver.html#8110" class="Function">buildExpr</a> <a id="8033" href="Tactic.MonoidSolver.html#7976" class="Bound">y</a> <a id="8035" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8039" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>
  <a id="8044" href="Tactic.MonoidSolver.html#7934" class="CatchallClause Function">″∙″</a><a id="8047" class="CatchallClause"> </a><a id="8048" class="CatchallClause Symbol">(</a><a id="8049" href="Tactic.MonoidSolver.html#8049" class="CatchallClause Bound">x</a><a id="8050" class="CatchallClause"> </a><a id="8051" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="8052" class="CatchallClause"> </a><a id="8053" href="Tactic.MonoidSolver.html#8053" class="CatchallClause Bound">xs</a><a id="8055" class="CatchallClause Symbol">)</a>         <a id="8065" class="Symbol">=</a> <a id="8067" href="Tactic.MonoidSolver.html#7934" class="Function">″∙″</a> <a id="8071" href="Tactic.MonoidSolver.html#8053" class="Bound">xs</a>
  <a id="8076" href="Tactic.MonoidSolver.html#7934" class="CatchallClause Function">″∙″</a><a id="8079" class="CatchallClause"> </a><a id="8080" class="CatchallClause Symbol">_</a>                <a id="8097" class="Symbol">=</a> <a id="8099" href="Agda.Builtin.Reflection.html#5271" class="InductiveConstructor">unknown</a>

  <a id="8110" href="Tactic.MonoidSolver.html#8110" class="Function">buildExpr</a> <a id="8120" class="Symbol">:</a> <a id="8122" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8127" class="Symbol">→</a> <a id="8129" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="8136" href="Tactic.MonoidSolver.html#8110" class="Function">buildExpr</a> <a id="8146" href="Tactic.MonoidSolver.html#8146" class="Bound">t</a><a id="8147" class="Symbol">@(</a><a id="8149" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="8153" href="Tactic.MonoidSolver.html#8153" class="Bound">n</a> <a id="8155" href="Tactic.MonoidSolver.html#8155" class="Bound">xs</a><a id="8157" class="Symbol">)</a> <a id="8159" class="Symbol">=</a>
    <a id="8165" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8168" href="Tactic.MonoidSolver.html#6891" class="Field">is-∙</a> <a id="8173" href="Tactic.MonoidSolver.html#8153" class="Bound">n</a>
      <a id="8181" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8186" href="Tactic.MonoidSolver.html#7934" class="Function">″∙″</a> <a id="8190" href="Tactic.MonoidSolver.html#8155" class="Bound">xs</a>
    <a id="8197" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="8202" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8205" href="Tactic.MonoidSolver.html#6914" class="Field">is-ε</a> <a id="8210" href="Tactic.MonoidSolver.html#8153" class="Bound">n</a>
      <a id="8218" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8223" href="Tactic.MonoidSolver.html#7762" class="Function">″ε″</a>
    <a id="8231" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
      <a id="8242" href="Tactic.MonoidSolver.html#7800" class="Function Operator">[</a> <a id="8244" href="Tactic.MonoidSolver.html#8146" class="Bound">t</a> <a id="8246" href="Tactic.MonoidSolver.html#7800" class="Function Operator">↑]′</a>
  <a id="8252" href="Tactic.MonoidSolver.html#8110" class="Function">buildExpr</a> <a id="8262" href="Tactic.MonoidSolver.html#8262" class="Bound">t</a><a id="8263" class="Symbol">@(</a><a id="8265" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="8269" href="Tactic.MonoidSolver.html#8269" class="Bound">n</a> <a id="8271" href="Tactic.MonoidSolver.html#8271" class="Bound">xs</a><a id="8273" class="Symbol">)</a> <a id="8275" class="Symbol">=</a>
    <a id="8281" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8284" href="Tactic.MonoidSolver.html#6891" class="Field">is-∙</a> <a id="8289" href="Tactic.MonoidSolver.html#8269" class="Bound">n</a>
      <a id="8297" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8302" href="Tactic.MonoidSolver.html#7934" class="Function">″∙″</a> <a id="8306" href="Tactic.MonoidSolver.html#8271" class="Bound">xs</a>
    <a id="8313" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="8318" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8321" href="Tactic.MonoidSolver.html#6914" class="Field">is-ε</a> <a id="8326" href="Tactic.MonoidSolver.html#8269" class="Bound">n</a>
      <a id="8334" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8339" href="Tactic.MonoidSolver.html#7762" class="Function">″ε″</a>
    <a id="8347" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="8352" href="Tactic.MonoidSolver.html#7800" class="Function Operator">[</a> <a id="8354" href="Tactic.MonoidSolver.html#8262" class="Bound">t</a> <a id="8356" href="Tactic.MonoidSolver.html#7800" class="Function Operator">↑]′</a>
  <a id="8362" href="Tactic.MonoidSolver.html#8110" class="CatchallClause Function">buildExpr</a><a id="8371" class="CatchallClause"> </a><a id="8372" href="Tactic.MonoidSolver.html#8372" class="CatchallClause Bound">t</a> <a id="8374" class="Symbol">=</a> <a id="8376" class="Keyword">quote</a> <a id="8382" href="Tactic.MonoidSolver.html#4448" class="InductiveConstructor Operator">[_↑]</a> <a id="8387" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="8389" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="8393" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="8395" class="Symbol">(</a><a id="8396" href="Tactic.MonoidSolver.html#8372" class="Bound">t</a> <a id="8398" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8402" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="8404" class="Symbol">)</a>

<a id="8407" class="Comment">----------------------------------------------------------------------</a>
<a id="8478" class="Comment">-- Constructing the solution</a>
<a id="8507" class="Comment">----------------------------------------------------------------------</a>

<a id="8579" class="Comment">-- This function joins up the two homomorphism proofs. It constructs</a>
<a id="8648" class="Comment">-- a proof of the following form:</a>
<a id="8682" class="Comment">--</a>
<a id="8685" class="Comment">--   trans (sym (homo x)) (homo y)</a>
<a id="8720" class="Comment">--</a>
<a id="8723" class="Comment">-- where x and y are the Expr representations of each side of the</a>
<a id="8789" class="Comment">-- goal equation.</a>

<a id="constructSoln"></a><a id="8808" href="Tactic.MonoidSolver.html#8808" class="Function">constructSoln</a> <a id="8822" class="Symbol">:</a> <a id="8824" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8829" class="Symbol">→</a> <a id="8831" href="Tactic.MonoidSolver.html#6855" class="Record">MonoidNames</a> <a id="8843" class="Symbol">→</a> <a id="8845" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8850" class="Symbol">→</a> <a id="8852" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8857" class="Symbol">→</a> <a id="8859" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="8864" href="Tactic.MonoidSolver.html#8808" class="Function">constructSoln</a> <a id="8878" href="Tactic.MonoidSolver.html#8878" class="Bound">mon</a> <a id="8882" href="Tactic.MonoidSolver.html#8882" class="Bound">names</a> <a id="8888" href="Tactic.MonoidSolver.html#8888" class="Bound">lhs</a> <a id="8892" href="Tactic.MonoidSolver.html#8892" class="Bound">rhs</a> <a id="8896" class="Symbol">=</a>
  <a id="8900" class="Keyword">quote</a> <a id="8906" href="Relation.Binary.Structures.html#1648" class="Function">Monoid.trans</a> <a id="8919" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="8921" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="8925" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="8927" class="Number">2</a> <a id="8929" href="Reflection.AST.Term.html#2962" class="Function Operator">⋯⟅∷⟆</a> <a id="8934" href="Tactic.MonoidSolver.html#8878" class="Bound">mon</a> <a id="8938" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="8946" class="Symbol">(</a><a id="8947" class="Keyword">quote</a> <a id="8953" href="Relation.Binary.Structures.html#1622" class="Function">Monoid.sym</a> <a id="8964" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="8966" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="8970" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="8972" class="Number">2</a> <a id="8974" href="Reflection.AST.Term.html#2962" class="Function Operator">⋯⟅∷⟆</a> <a id="8979" href="Tactic.MonoidSolver.html#8878" class="Bound">mon</a> <a id="8983" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
       <a id="8994" class="Symbol">(</a><a id="8995" class="Keyword">quote</a> <a id="9001" href="Tactic.MonoidSolver.html#5689" class="Function">homo</a> <a id="9006" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="9008" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="9012" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="9014" class="Number">2</a> <a id="9016" href="Reflection.AST.Term.html#2962" class="Function Operator">⋯⟅∷⟆</a> <a id="9021" href="Tactic.MonoidSolver.html#8878" class="Bound">mon</a> <a id="9025" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9029" href="Tactic.MonoidSolver.html#8110" class="Function">buildExpr</a> <a id="9039" href="Tactic.MonoidSolver.html#8882" class="Bound">names</a> <a id="9045" href="Tactic.MonoidSolver.html#8888" class="Bound">lhs</a> <a id="9049" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9053" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9055" class="Symbol">)</a> <a id="9057" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9061" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9063" class="Symbol">)</a>
    <a id="9069" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="9077" class="Symbol">(</a><a id="9078" class="Keyword">quote</a> <a id="9084" href="Tactic.MonoidSolver.html#5689" class="Function">homo</a> <a id="9089" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="9091" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="9095" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="9097" class="Number">2</a> <a id="9099" href="Reflection.AST.Term.html#2962" class="Function Operator">⋯⟅∷⟆</a> <a id="9104" href="Tactic.MonoidSolver.html#8878" class="Bound">mon</a> <a id="9108" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9112" href="Tactic.MonoidSolver.html#8110" class="Function">buildExpr</a> <a id="9122" href="Tactic.MonoidSolver.html#8882" class="Bound">names</a> <a id="9128" href="Tactic.MonoidSolver.html#8892" class="Bound">rhs</a> <a id="9132" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9136" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9138" class="Symbol">)</a> <a id="9140" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="9148" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>

<a id="9152" class="Comment">----------------------------------------------------------------------</a>
<a id="9223" class="Comment">-- Macro</a>
<a id="9232" class="Comment">----------------------------------------------------------------------</a>

<a id="solve-macro"></a><a id="9304" href="Tactic.MonoidSolver.html#9304" class="Function">solve-macro</a> <a id="9316" class="Symbol">:</a> <a id="9318" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9323" class="Symbol">→</a> <a id="9325" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9330" class="Symbol">→</a> <a id="9332" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="9335" class="Symbol">_</a>
<a id="9337" href="Tactic.MonoidSolver.html#9304" class="Function">solve-macro</a> <a id="9349" href="Tactic.MonoidSolver.html#9349" class="Bound">mon</a> <a id="9353" href="Tactic.MonoidSolver.html#9353" class="Bound">hole</a> <a id="9358" class="Symbol">=</a> <a id="9360" class="Keyword">do</a>
  <a id="9365" href="Tactic.MonoidSolver.html#9365" class="Bound">hole′</a> <a id="9371" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9373" href="Agda.Builtin.Reflection.html#8555" class="Postulate">inferType</a> <a id="9383" href="Tactic.MonoidSolver.html#9353" class="Bound">hole</a> <a id="9388" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="9392" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a>
  <a id="9404" href="Tactic.MonoidSolver.html#9404" class="Bound">names</a> <a id="9410" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9412" href="Tactic.MonoidSolver.html#7076" class="Function">findMonoidNames</a> <a id="9428" href="Tactic.MonoidSolver.html#9349" class="Bound">mon</a>
  <a id="9434" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="9439" class="Symbol">(</a><a id="9440" href="Tactic.MonoidSolver.html#9440" class="Bound">lhs</a> <a id="9444" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="9446" href="Tactic.MonoidSolver.html#9446" class="Bound">rhs</a><a id="9449" class="Symbol">)</a> <a id="9451" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9453" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="9458" class="Symbol">(</a><a id="9459" href="Tactic.MonoidSolver.html#6102" class="Function">getArgs</a> <a id="9467" href="Tactic.MonoidSolver.html#9365" class="Bound">hole′</a><a id="9472" class="Symbol">)</a>
    <a id="9478" class="Keyword">where</a> <a id="9484" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a> <a id="9492" class="Symbol">→</a> <a id="9494" href="Agda.Builtin.Reflection.html#8492" class="Postulate">typeError</a> <a id="9504" class="Symbol">(</a><a id="9505" href="Agda.Builtin.Reflection.html#7931" class="InductiveConstructor">termErr</a> <a id="9513" href="Tactic.MonoidSolver.html#9365" class="Bound">hole′</a> <a id="9519" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="9521" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9523" class="Symbol">)</a>
  <a id="9527" class="Keyword">let</a> <a id="9531" href="Tactic.MonoidSolver.html#9531" class="Bound">soln</a> <a id="9536" class="Symbol">=</a> <a id="9538" href="Tactic.MonoidSolver.html#8808" class="Function">constructSoln</a> <a id="9552" href="Tactic.MonoidSolver.html#9349" class="Bound">mon</a> <a id="9556" href="Tactic.MonoidSolver.html#9404" class="Bound">names</a> <a id="9562" href="Tactic.MonoidSolver.html#9440" class="Bound">lhs</a> <a id="9566" href="Tactic.MonoidSolver.html#9446" class="Bound">rhs</a>
  <a id="9572" href="Agda.Builtin.Reflection.html#8452" class="Postulate">unify</a> <a id="9578" href="Tactic.MonoidSolver.html#9353" class="Bound">hole</a> <a id="9583" href="Tactic.MonoidSolver.html#9531" class="Bound">soln</a>

<a id="9589" class="Keyword">macro</a>
  <a id="solve"></a><a id="9597" href="Tactic.MonoidSolver.html#9597" class="Function">solve</a> <a id="9603" class="Symbol">:</a> <a id="9605" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9610" class="Symbol">→</a> <a id="9612" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9617" class="Symbol">→</a> <a id="9619" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="9622" class="Symbol">_</a>
  <a id="9626" href="Tactic.MonoidSolver.html#9597" class="Function">solve</a> <a id="9632" class="Symbol">=</a> <a id="9634" href="Tactic.MonoidSolver.html#9304" class="Function">solve-macro</a>
</pre></body></html>