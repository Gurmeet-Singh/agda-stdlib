<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Case</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the case expressions can be used with anonymous</a>
<a id="178" class="Comment">-- pattern-matching lambda abstractions</a>
<a id="218" class="Comment">------------------------------------------------------------------------</a>

<a id="292" class="Symbol">{-#</a> <a id="296" class="Keyword">OPTIONS</a> <a id="304" class="Pragma">--cubical-compatible</a> <a id="325" class="Pragma">--safe</a> <a id="332" class="Symbol">#-}</a>

<a id="337" class="Keyword">module</a> <a id="344" href="README.Case.html" class="Module">README.Case</a> <a id="356" class="Keyword">where</a>

<a id="363" class="Keyword">open</a> <a id="368" class="Keyword">import</a> <a id="375" href="Data.Fin.html" class="Module">Data.Fin</a>   <a id="386" class="Keyword">hiding</a> <a id="393" class="Symbol">(</a><a id="394" href="Data.Fin.Base.html#6645" class="Function">pred</a><a id="398" class="Symbol">)</a>
<a id="400" class="Keyword">open</a> <a id="405" class="Keyword">import</a> <a id="412" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="423" class="Keyword">hiding</a> <a id="430" class="Symbol">(</a><a id="431" href="Data.Maybe.Base.html#1935" class="Function">from-just</a><a id="440" class="Symbol">)</a>
<a id="442" class="Keyword">open</a> <a id="447" class="Keyword">import</a> <a id="454" href="Data.Nat.html" class="Module">Data.Nat</a>   <a id="465" class="Keyword">hiding</a> <a id="472" class="Symbol">(</a><a id="473" href="Data.Nat.Base.html#3280" class="Function">pred</a><a id="477" class="Symbol">)</a>
<a id="479" class="Keyword">open</a> <a id="484" class="Keyword">import</a> <a id="491" href="Data.Product.html" class="Module">Data.Product</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Function.Base.html" class="Module">Function.Base</a> <a id="530" class="Keyword">using</a> <a id="536" class="Symbol">(</a><a id="537" href="Function.Base.html#4062" class="Function Operator">case_of_</a><a id="545" class="Symbol">;</a> <a id="547" href="Function.Base.html#2980" class="Function Operator">case_return_of_</a><a id="562" class="Symbol">)</a>
<a id="564" class="Keyword">open</a> <a id="569" class="Keyword">import</a> <a id="576" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="593" class="Keyword">open</a> <a id="598" class="Keyword">import</a> <a id="605" href="Relation.Binary.html" class="Module">Relation.Binary</a>
<a id="621" class="Keyword">open</a> <a id="626" class="Keyword">import</a> <a id="633" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="672" class="Comment">------------------------------------------------------------------------</a>
<a id="745" class="Comment">-- Different types of pattern-matching lambdas</a>

<a id="793" class="Comment">-- absurd pattern</a>

<a id="empty"></a><a id="812" href="README.Case.html#812" class="Function">empty</a> <a id="818" class="Symbol">:</a> <a id="820" class="Symbol">∀</a> <a id="822" class="Symbol">{</a><a id="823" href="README.Case.html#823" class="Bound">a</a><a id="824" class="Symbol">}</a> <a id="826" class="Symbol">{</a><a id="827" href="README.Case.html#827" class="Bound">A</a> <a id="829" class="Symbol">:</a> <a id="831" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="835" href="README.Case.html#823" class="Bound">a</a><a id="836" class="Symbol">}</a> <a id="838" class="Symbol">→</a> <a id="840" href="Data.Fin.Base.html#1312" class="Datatype">Fin</a> <a id="844" class="Number">0</a> <a id="846" class="Symbol">→</a> <a id="848" href="README.Case.html#827" class="Bound">A</a>
<a id="850" href="README.Case.html#812" class="Function">empty</a> <a id="856" href="README.Case.html#856" class="Bound">i</a> <a id="858" class="Symbol">=</a> <a id="860" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="865" href="README.Case.html#856" class="Bound">i</a> <a id="867" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="870" class="Symbol">λ</a> <a id="872" class="Symbol">()</a>

<a id="876" class="Comment">-- {}-delimited and ;-separated list of clauses</a>
<a id="924" class="Comment">-- Note that they do not need to be on different lines</a>

<a id="pred"></a><a id="980" href="README.Case.html#980" class="Function">pred</a> <a id="985" class="Symbol">:</a> <a id="987" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="989" class="Symbol">→</a> <a id="991" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="993" href="README.Case.html#980" class="Function">pred</a> <a id="998" href="README.Case.html#998" class="Bound">n</a> <a id="1000" class="Symbol">=</a> <a id="1002" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="1007" href="README.Case.html#998" class="Bound">n</a> <a id="1009" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="1012" class="Symbol">λ</a>
  <a id="1016" class="Symbol">{</a> <a id="1018" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="1026" class="Symbol">→</a> <a id="1028" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="1035" class="Symbol">;</a> <a id="1037" class="Symbol">(</a><a id="1038" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1042" href="README.Case.html#1042" class="Bound">n</a><a id="1043" class="Symbol">)</a> <a id="1045" class="Symbol">→</a> <a id="1047" href="README.Case.html#1042" class="Bound">n</a>
  <a id="1051" class="Symbol">}</a>

<a id="1054" class="Comment">-- where-introduced and indentation-identified block of list of clauses</a>

<a id="from-just"></a><a id="1127" href="README.Case.html#1127" class="Function">from-just</a> <a id="1137" class="Symbol">:</a> <a id="1139" class="Symbol">∀</a> <a id="1141" class="Symbol">{</a><a id="1142" href="README.Case.html#1142" class="Bound">a</a><a id="1143" class="Symbol">}</a> <a id="1145" class="Symbol">{</a><a id="1146" href="README.Case.html#1146" class="Bound">A</a> <a id="1148" class="Symbol">:</a> <a id="1150" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1154" href="README.Case.html#1142" class="Bound">a</a><a id="1155" class="Symbol">}</a> <a id="1157" class="Symbol">(</a><a id="1158" href="README.Case.html#1158" class="Bound">x</a> <a id="1160" class="Symbol">:</a> <a id="1162" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="1168" href="README.Case.html#1146" class="Bound">A</a><a id="1169" class="Symbol">)</a> <a id="1171" class="Symbol">→</a> <a id="1173" href="Data.Maybe.Base.html#1847" class="Function">From-just</a> <a id="1183" href="README.Case.html#1158" class="Bound">x</a>
<a id="1185" href="README.Case.html#1127" class="Function">from-just</a> <a id="1195" href="README.Case.html#1195" class="Bound">x</a> <a id="1197" class="Symbol">=</a> <a id="1199" href="Function.Base.html#2980" class="Function Operator">case</a> <a id="1204" href="README.Case.html#1195" class="Bound">x</a> <a id="1206" href="Function.Base.html#2980" class="Function Operator">return</a> <a id="1213" href="Data.Maybe.Base.html#1847" class="Function">From-just</a> <a id="1223" href="Function.Base.html#2980" class="Function Operator">of</a> <a id="1226" class="Symbol">λ</a> <a id="1228" class="Keyword">where</a>
  <a id="1236" class="Symbol">(</a><a id="1237" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="1242" href="README.Case.html#1242" class="Bound">x</a><a id="1243" class="Symbol">)</a> <a id="1245" class="Symbol">→</a> <a id="1247" href="README.Case.html#1242" class="Bound">x</a>
  <a id="1251" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>  <a id="1260" class="Symbol">→</a> <a id="1262" class="Symbol">_</a>

<a id="1265" class="Comment">------------------------------------------------------------------------</a>
<a id="1338" class="Comment">-- We can define some recursive functions with case</a>

<a id="plus"></a><a id="1391" href="README.Case.html#1391" class="Function">plus</a> <a id="1396" class="Symbol">:</a> <a id="1398" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1400" class="Symbol">→</a> <a id="1402" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1404" class="Symbol">→</a> <a id="1406" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="1408" href="README.Case.html#1391" class="Function">plus</a> <a id="1413" href="README.Case.html#1413" class="Bound">m</a> <a id="1415" href="README.Case.html#1415" class="Bound">n</a> <a id="1417" class="Symbol">=</a> <a id="1419" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="1424" href="README.Case.html#1413" class="Bound">m</a> <a id="1426" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="1429" class="Symbol">λ</a>
   <a id="1434" class="Symbol">{</a> <a id="1436" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="1444" class="Symbol">→</a> <a id="1446" href="README.Case.html#1415" class="Bound">n</a>
   <a id="1451" class="Symbol">;</a> <a id="1453" class="Symbol">(</a><a id="1454" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1458" href="README.Case.html#1458" class="Bound">m</a><a id="1459" class="Symbol">)</a> <a id="1461" class="Symbol">→</a> <a id="1463" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1467" class="Symbol">(</a><a id="1468" href="README.Case.html#1391" class="Function">plus</a> <a id="1473" href="README.Case.html#1458" class="Bound">m</a> <a id="1475" href="README.Case.html#1415" class="Bound">n</a><a id="1476" class="Symbol">)</a>
   <a id="1481" class="Symbol">}</a>

<a id="div2"></a><a id="1484" href="README.Case.html#1484" class="Function">div2</a> <a id="1489" class="Symbol">:</a> <a id="1491" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1493" class="Symbol">→</a> <a id="1495" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="1497" href="README.Case.html#1484" class="Function">div2</a> <a id="1502" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="1510" class="Symbol">=</a> <a id="1512" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
<a id="1517" href="README.Case.html#1484" class="Function">div2</a> <a id="1522" class="Symbol">(</a><a id="1523" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1527" href="README.Case.html#1527" class="Bound">m</a><a id="1528" class="Symbol">)</a> <a id="1530" class="Symbol">=</a> <a id="1532" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="1537" href="README.Case.html#1527" class="Bound">m</a> <a id="1539" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="1542" class="Symbol">λ</a> <a id="1544" class="Keyword">where</a>
  <a id="1552" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>     <a id="1561" class="Symbol">→</a> <a id="1563" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="1570" class="Symbol">(</a><a id="1571" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1575" href="README.Case.html#1575" class="Bound">m′</a><a id="1577" class="Symbol">)</a> <a id="1579" class="Symbol">→</a> <a id="1581" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1585" class="Symbol">(</a><a id="1586" href="README.Case.html#1484" class="Function">div2</a> <a id="1591" href="README.Case.html#1575" class="Bound">m′</a><a id="1593" class="Symbol">)</a>


<a id="1597" class="Comment">-- Note that some natural uses of case are rejected by the termination</a>
<a id="1668" class="Comment">-- checker:</a>

<a id="1681" class="Comment">-- module _ {a} {A : Set a} (eq? : Decidable {A = A} _≡_) where</a>

<a id="1746" class="Comment">--  pairBy : List A → List (A ⊎ (A × A))</a>
<a id="1787" class="Comment">--  pairBy []           = []</a>
<a id="1816" class="Comment">--  pairBy (x ∷ [])     = inj₁ x ∷ []</a>
<a id="1854" class="Comment">--  pairBy (x ∷ y ∷ xs) = case eq? x y of λ where</a>
<a id="1904" class="Comment">--    (yes _) → inj₂ (x , y) ∷ pairBy xs</a>
<a id="1945" class="Comment">--    (no _)  → inj₁ x ∷ pairBy (y ∷ xs)</a>
</pre></body></html>