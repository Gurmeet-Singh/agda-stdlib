<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Case</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the case expressions can be used with anonymous</a>
<a id="178" class="Comment">-- pattern-matching lambda abstractions</a>
<a id="218" class="Comment">------------------------------------------------------------------------</a>

<a id="292" class="Symbol">{-#</a> <a id="296" class="Keyword">OPTIONS</a> <a id="304" class="Pragma">--cubical-compatible</a> <a id="325" class="Pragma">--safe</a> <a id="332" class="Symbol">#-}</a>

<a id="337" class="Keyword">module</a> <a id="344" href="README.Case.html" class="Module">README.Case</a> <a id="356" class="Keyword">where</a>

<a id="363" class="Keyword">open</a> <a id="368" class="Keyword">import</a> <a id="375" href="Data.Fin.html" class="Module">Data.Fin</a>   <a id="386" class="Keyword">hiding</a> <a id="393" class="Symbol">(</a><a id="394" href="Data.Fin.Base.html#6645" class="Function">pred</a><a id="398" class="Symbol">)</a>
<a id="400" class="Keyword">open</a> <a id="405" class="Keyword">import</a> <a id="412" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="423" class="Keyword">hiding</a> <a id="430" class="Symbol">(</a><a id="431" href="Data.Maybe.Base.html#1935" class="Function">from-just</a><a id="440" class="Symbol">)</a>
<a id="442" class="Keyword">open</a> <a id="447" class="Keyword">import</a> <a id="454" href="Data.Nat.html" class="Module">Data.Nat</a>   <a id="465" class="Keyword">hiding</a> <a id="472" class="Symbol">(</a><a id="473" href="Data.Nat.Base.html#3280" class="Function">pred</a><a id="477" class="Symbol">)</a>
<a id="479" class="Keyword">open</a> <a id="484" class="Keyword">import</a> <a id="491" href="Data.Product.html" class="Module">Data.Product</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Function.Base.html" class="Module">Function.Base</a> <a id="530" class="Keyword">using</a> <a id="536" class="Symbol">(</a><a id="537" href="Function.Base.html#4062" class="Function Operator">case_of_</a><a id="545" class="Symbol">;</a> <a id="547" href="Function.Base.html#2980" class="Function Operator">case_return_of_</a><a id="562" class="Symbol">)</a>
<a id="564" class="Keyword">open</a> <a id="569" class="Keyword">import</a> <a id="576" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="593" class="Keyword">open</a> <a id="598" class="Keyword">import</a> <a id="605" href="Relation.Binary.html" class="Module">Relation.Binary</a>

<a id="622" class="Comment">------------------------------------------------------------------------</a>
<a id="695" class="Comment">-- Different types of pattern-matching lambdas</a>

<a id="743" class="Comment">-- absurd pattern</a>

<a id="empty"></a><a id="762" href="README.Case.html#762" class="Function">empty</a> <a id="768" class="Symbol">:</a> <a id="770" class="Symbol">∀</a> <a id="772" class="Symbol">{</a><a id="773" href="README.Case.html#773" class="Bound">a</a><a id="774" class="Symbol">}</a> <a id="776" class="Symbol">{</a><a id="777" href="README.Case.html#777" class="Bound">A</a> <a id="779" class="Symbol">:</a> <a id="781" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="785" href="README.Case.html#773" class="Bound">a</a><a id="786" class="Symbol">}</a> <a id="788" class="Symbol">→</a> <a id="790" href="Data.Fin.Base.html#1312" class="Datatype">Fin</a> <a id="794" class="Number">0</a> <a id="796" class="Symbol">→</a> <a id="798" href="README.Case.html#777" class="Bound">A</a>
<a id="800" href="README.Case.html#762" class="Function">empty</a> <a id="806" href="README.Case.html#806" class="Bound">i</a> <a id="808" class="Symbol">=</a> <a id="810" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="815" href="README.Case.html#806" class="Bound">i</a> <a id="817" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="820" class="Symbol">λ</a> <a id="822" class="Symbol">()</a>

<a id="826" class="Comment">-- {}-delimited and ;-separated list of clauses</a>
<a id="874" class="Comment">-- Note that they do not need to be on different lines</a>

<a id="pred"></a><a id="930" href="README.Case.html#930" class="Function">pred</a> <a id="935" class="Symbol">:</a> <a id="937" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="939" class="Symbol">→</a> <a id="941" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="943" href="README.Case.html#930" class="Function">pred</a> <a id="948" href="README.Case.html#948" class="Bound">n</a> <a id="950" class="Symbol">=</a> <a id="952" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="957" href="README.Case.html#948" class="Bound">n</a> <a id="959" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="962" class="Symbol">λ</a>
  <a id="966" class="Symbol">{</a> <a id="968" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="976" class="Symbol">→</a> <a id="978" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="985" class="Symbol">;</a> <a id="987" class="Symbol">(</a><a id="988" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="992" href="README.Case.html#992" class="Bound">n</a><a id="993" class="Symbol">)</a> <a id="995" class="Symbol">→</a> <a id="997" href="README.Case.html#992" class="Bound">n</a>
  <a id="1001" class="Symbol">}</a>

<a id="1004" class="Comment">-- where-introduced and indentation-identified block of list of clauses</a>

<a id="from-just"></a><a id="1077" href="README.Case.html#1077" class="Function">from-just</a> <a id="1087" class="Symbol">:</a> <a id="1089" class="Symbol">∀</a> <a id="1091" class="Symbol">{</a><a id="1092" href="README.Case.html#1092" class="Bound">a</a><a id="1093" class="Symbol">}</a> <a id="1095" class="Symbol">{</a><a id="1096" href="README.Case.html#1096" class="Bound">A</a> <a id="1098" class="Symbol">:</a> <a id="1100" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1104" href="README.Case.html#1092" class="Bound">a</a><a id="1105" class="Symbol">}</a> <a id="1107" class="Symbol">(</a><a id="1108" href="README.Case.html#1108" class="Bound">x</a> <a id="1110" class="Symbol">:</a> <a id="1112" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="1118" href="README.Case.html#1096" class="Bound">A</a><a id="1119" class="Symbol">)</a> <a id="1121" class="Symbol">→</a> <a id="1123" href="Data.Maybe.Base.html#1847" class="Function">From-just</a> <a id="1133" href="README.Case.html#1108" class="Bound">x</a>
<a id="1135" href="README.Case.html#1077" class="Function">from-just</a> <a id="1145" href="README.Case.html#1145" class="Bound">x</a> <a id="1147" class="Symbol">=</a> <a id="1149" href="Function.Base.html#2980" class="Function Operator">case</a> <a id="1154" href="README.Case.html#1145" class="Bound">x</a> <a id="1156" href="Function.Base.html#2980" class="Function Operator">return</a> <a id="1163" href="Data.Maybe.Base.html#1847" class="Function">From-just</a> <a id="1173" href="Function.Base.html#2980" class="Function Operator">of</a> <a id="1176" class="Symbol">λ</a> <a id="1178" class="Keyword">where</a>
  <a id="1186" class="Symbol">(</a><a id="1187" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="1192" href="README.Case.html#1192" class="Bound">x</a><a id="1193" class="Symbol">)</a> <a id="1195" class="Symbol">→</a> <a id="1197" href="README.Case.html#1192" class="Bound">x</a>
  <a id="1201" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>  <a id="1210" class="Symbol">→</a> <a id="1212" class="Symbol">_</a>

<a id="1215" class="Comment">------------------------------------------------------------------------</a>
<a id="1288" class="Comment">-- We can define some recursive functions with case</a>

<a id="plus"></a><a id="1341" href="README.Case.html#1341" class="Function">plus</a> <a id="1346" class="Symbol">:</a> <a id="1348" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1350" class="Symbol">→</a> <a id="1352" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1354" class="Symbol">→</a> <a id="1356" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="1358" href="README.Case.html#1341" class="Function">plus</a> <a id="1363" href="README.Case.html#1363" class="Bound">m</a> <a id="1365" href="README.Case.html#1365" class="Bound">n</a> <a id="1367" class="Symbol">=</a> <a id="1369" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="1374" href="README.Case.html#1363" class="Bound">m</a> <a id="1376" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="1379" class="Symbol">λ</a>
   <a id="1384" class="Symbol">{</a> <a id="1386" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="1394" class="Symbol">→</a> <a id="1396" href="README.Case.html#1365" class="Bound">n</a>
   <a id="1401" class="Symbol">;</a> <a id="1403" class="Symbol">(</a><a id="1404" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1408" href="README.Case.html#1408" class="Bound">m</a><a id="1409" class="Symbol">)</a> <a id="1411" class="Symbol">→</a> <a id="1413" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1417" class="Symbol">(</a><a id="1418" href="README.Case.html#1341" class="Function">plus</a> <a id="1423" href="README.Case.html#1408" class="Bound">m</a> <a id="1425" href="README.Case.html#1365" class="Bound">n</a><a id="1426" class="Symbol">)</a>
   <a id="1431" class="Symbol">}</a>

<a id="div2"></a><a id="1434" href="README.Case.html#1434" class="Function">div2</a> <a id="1439" class="Symbol">:</a> <a id="1441" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1443" class="Symbol">→</a> <a id="1445" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="1447" href="README.Case.html#1434" class="Function">div2</a> <a id="1452" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="1460" class="Symbol">=</a> <a id="1462" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
<a id="1467" href="README.Case.html#1434" class="Function">div2</a> <a id="1472" class="Symbol">(</a><a id="1473" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1477" href="README.Case.html#1477" class="Bound">m</a><a id="1478" class="Symbol">)</a> <a id="1480" class="Symbol">=</a> <a id="1482" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="1487" href="README.Case.html#1477" class="Bound">m</a> <a id="1489" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="1492" class="Symbol">λ</a> <a id="1494" class="Keyword">where</a>
  <a id="1502" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>     <a id="1511" class="Symbol">→</a> <a id="1513" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="1520" class="Symbol">(</a><a id="1521" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1525" href="README.Case.html#1525" class="Bound">m′</a><a id="1527" class="Symbol">)</a> <a id="1529" class="Symbol">→</a> <a id="1531" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1535" class="Symbol">(</a><a id="1536" href="README.Case.html#1434" class="Function">div2</a> <a id="1541" href="README.Case.html#1525" class="Bound">m′</a><a id="1543" class="Symbol">)</a>


<a id="1547" class="Comment">-- Note that some natural uses of case are rejected by the termination</a>
<a id="1618" class="Comment">-- checker:</a>

<a id="1631" class="Comment">-- module _ {a} {A : Set a} (eq? : Decidable {A = A} _≡_) where</a>

<a id="1696" class="Comment">--  pairBy : List A → List (A ⊎ (A × A))</a>
<a id="1737" class="Comment">--  pairBy []           = []</a>
<a id="1766" class="Comment">--  pairBy (x ∷ [])     = inj₁ x ∷ []</a>
<a id="1804" class="Comment">--  pairBy (x ∷ y ∷ xs) = case eq? x y of λ where</a>
<a id="1854" class="Comment">--    (yes _) → inj₂ (x , y) ∷ pairBy xs</a>
<a id="1895" class="Comment">--    (no _)  → inj₁ x ∷ pairBy (y ∷ xs)</a>
</pre></body></html>