<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Case</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the case expressions can be used with anonymous</a>
<a id="178" class="Comment">-- pattern-matching lambda abstractions</a>
<a id="218" class="Comment">------------------------------------------------------------------------</a>

<a id="292" class="Symbol">{-#</a> <a id="296" class="Keyword">OPTIONS</a> <a id="304" class="Pragma">--cubical-compatible</a> <a id="325" class="Pragma">--safe</a> <a id="332" class="Symbol">#-}</a>

<a id="337" class="Keyword">module</a> <a id="344" href="README.Case.html" class="Module">README.Case</a> <a id="356" class="Keyword">where</a>

<a id="363" class="Keyword">open</a> <a id="368" class="Keyword">import</a> <a id="375" href="Data.Fin.html" class="Module">Data.Fin</a>   <a id="386" class="Keyword">hiding</a> <a id="393" class="Symbol">(</a><a id="394" href="Data.Fin.Base.html#6645" class="Function">pred</a><a id="398" class="Symbol">)</a>
<a id="400" class="Keyword">open</a> <a id="405" class="Keyword">import</a> <a id="412" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="423" class="Keyword">hiding</a> <a id="430" class="Symbol">(</a><a id="431" href="Data.Maybe.Base.html#1935" class="Function">from-just</a><a id="440" class="Symbol">)</a>
<a id="442" class="Keyword">open</a> <a id="447" class="Keyword">import</a> <a id="454" href="Data.Nat.html" class="Module">Data.Nat</a>   <a id="465" class="Keyword">hiding</a> <a id="472" class="Symbol">(</a><a id="473" href="Data.Nat.Base.html#3280" class="Function">pred</a><a id="477" class="Symbol">)</a>
<a id="479" class="Keyword">open</a> <a id="484" class="Keyword">import</a> <a id="491" href="Function.Base.html" class="Module">Function.Base</a> <a id="505" class="Keyword">using</a> <a id="511" class="Symbol">(</a><a id="512" href="Function.Base.html#4062" class="Function Operator">case_of_</a><a id="520" class="Symbol">;</a> <a id="522" href="Function.Base.html#2980" class="Function Operator">case_return_of_</a><a id="537" class="Symbol">)</a>
<a id="539" class="Keyword">open</a> <a id="544" class="Keyword">import</a> <a id="551" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="568" class="Keyword">open</a> <a id="573" class="Keyword">import</a> <a id="580" href="Relation.Binary.html" class="Module">Relation.Binary</a>

<a id="597" class="Comment">------------------------------------------------------------------------</a>
<a id="670" class="Comment">-- Different types of pattern-matching lambdas</a>

<a id="718" class="Comment">-- absurd pattern</a>

<a id="empty"></a><a id="737" href="README.Case.html#737" class="Function">empty</a> <a id="743" class="Symbol">:</a> <a id="745" class="Symbol">∀</a> <a id="747" class="Symbol">{</a><a id="748" href="README.Case.html#748" class="Bound">a</a><a id="749" class="Symbol">}</a> <a id="751" class="Symbol">{</a><a id="752" href="README.Case.html#752" class="Bound">A</a> <a id="754" class="Symbol">:</a> <a id="756" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="760" href="README.Case.html#748" class="Bound">a</a><a id="761" class="Symbol">}</a> <a id="763" class="Symbol">→</a> <a id="765" href="Data.Fin.Base.html#1312" class="Datatype">Fin</a> <a id="769" class="Number">0</a> <a id="771" class="Symbol">→</a> <a id="773" href="README.Case.html#752" class="Bound">A</a>
<a id="775" href="README.Case.html#737" class="Function">empty</a> <a id="781" href="README.Case.html#781" class="Bound">i</a> <a id="783" class="Symbol">=</a> <a id="785" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="790" href="README.Case.html#781" class="Bound">i</a> <a id="792" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="795" class="Symbol">λ</a> <a id="797" class="Symbol">()</a>

<a id="801" class="Comment">-- {}-delimited and ;-separated list of clauses</a>
<a id="849" class="Comment">-- Note that they do not need to be on different lines</a>

<a id="pred"></a><a id="905" href="README.Case.html#905" class="Function">pred</a> <a id="910" class="Symbol">:</a> <a id="912" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="914" class="Symbol">→</a> <a id="916" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="918" href="README.Case.html#905" class="Function">pred</a> <a id="923" href="README.Case.html#923" class="Bound">n</a> <a id="925" class="Symbol">=</a> <a id="927" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="932" href="README.Case.html#923" class="Bound">n</a> <a id="934" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="937" class="Symbol">λ</a>
  <a id="941" class="Symbol">{</a> <a id="943" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="951" class="Symbol">→</a> <a id="953" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="960" class="Symbol">;</a> <a id="962" class="Symbol">(</a><a id="963" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="967" href="README.Case.html#967" class="Bound">n</a><a id="968" class="Symbol">)</a> <a id="970" class="Symbol">→</a> <a id="972" href="README.Case.html#967" class="Bound">n</a>
  <a id="976" class="Symbol">}</a>

<a id="979" class="Comment">-- where-introduced and indentation-identified block of list of clauses</a>

<a id="from-just"></a><a id="1052" href="README.Case.html#1052" class="Function">from-just</a> <a id="1062" class="Symbol">:</a> <a id="1064" class="Symbol">∀</a> <a id="1066" class="Symbol">{</a><a id="1067" href="README.Case.html#1067" class="Bound">a</a><a id="1068" class="Symbol">}</a> <a id="1070" class="Symbol">{</a><a id="1071" href="README.Case.html#1071" class="Bound">A</a> <a id="1073" class="Symbol">:</a> <a id="1075" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1079" href="README.Case.html#1067" class="Bound">a</a><a id="1080" class="Symbol">}</a> <a id="1082" class="Symbol">(</a><a id="1083" href="README.Case.html#1083" class="Bound">x</a> <a id="1085" class="Symbol">:</a> <a id="1087" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="1093" href="README.Case.html#1071" class="Bound">A</a><a id="1094" class="Symbol">)</a> <a id="1096" class="Symbol">→</a> <a id="1098" href="Data.Maybe.Base.html#1847" class="Function">From-just</a> <a id="1108" href="README.Case.html#1083" class="Bound">x</a>
<a id="1110" href="README.Case.html#1052" class="Function">from-just</a> <a id="1120" href="README.Case.html#1120" class="Bound">x</a> <a id="1122" class="Symbol">=</a> <a id="1124" href="Function.Base.html#2980" class="Function Operator">case</a> <a id="1129" href="README.Case.html#1120" class="Bound">x</a> <a id="1131" href="Function.Base.html#2980" class="Function Operator">return</a> <a id="1138" href="Data.Maybe.Base.html#1847" class="Function">From-just</a> <a id="1148" href="Function.Base.html#2980" class="Function Operator">of</a> <a id="1151" class="Symbol">λ</a> <a id="1153" class="Keyword">where</a>
  <a id="1161" class="Symbol">(</a><a id="1162" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="1167" href="README.Case.html#1167" class="Bound">x</a><a id="1168" class="Symbol">)</a> <a id="1170" class="Symbol">→</a> <a id="1172" href="README.Case.html#1167" class="Bound">x</a>
  <a id="1176" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>  <a id="1185" class="Symbol">→</a> <a id="1187" class="Symbol">_</a>

<a id="1190" class="Comment">------------------------------------------------------------------------</a>
<a id="1263" class="Comment">-- We can define some recursive functions with case</a>

<a id="plus"></a><a id="1316" href="README.Case.html#1316" class="Function">plus</a> <a id="1321" class="Symbol">:</a> <a id="1323" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1325" class="Symbol">→</a> <a id="1327" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1329" class="Symbol">→</a> <a id="1331" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="1333" href="README.Case.html#1316" class="Function">plus</a> <a id="1338" href="README.Case.html#1338" class="Bound">m</a> <a id="1340" href="README.Case.html#1340" class="Bound">n</a> <a id="1342" class="Symbol">=</a> <a id="1344" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="1349" href="README.Case.html#1338" class="Bound">m</a> <a id="1351" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="1354" class="Symbol">λ</a>
   <a id="1359" class="Symbol">{</a> <a id="1361" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="1369" class="Symbol">→</a> <a id="1371" href="README.Case.html#1340" class="Bound">n</a>
   <a id="1376" class="Symbol">;</a> <a id="1378" class="Symbol">(</a><a id="1379" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1383" href="README.Case.html#1383" class="Bound">m</a><a id="1384" class="Symbol">)</a> <a id="1386" class="Symbol">→</a> <a id="1388" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1392" class="Symbol">(</a><a id="1393" href="README.Case.html#1316" class="Function">plus</a> <a id="1398" href="README.Case.html#1383" class="Bound">m</a> <a id="1400" href="README.Case.html#1340" class="Bound">n</a><a id="1401" class="Symbol">)</a>
   <a id="1406" class="Symbol">}</a>

<a id="div2"></a><a id="1409" href="README.Case.html#1409" class="Function">div2</a> <a id="1414" class="Symbol">:</a> <a id="1416" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1418" class="Symbol">→</a> <a id="1420" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="1422" href="README.Case.html#1409" class="Function">div2</a> <a id="1427" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="1435" class="Symbol">=</a> <a id="1437" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
<a id="1442" href="README.Case.html#1409" class="Function">div2</a> <a id="1447" class="Symbol">(</a><a id="1448" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1452" href="README.Case.html#1452" class="Bound">m</a><a id="1453" class="Symbol">)</a> <a id="1455" class="Symbol">=</a> <a id="1457" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="1462" href="README.Case.html#1452" class="Bound">m</a> <a id="1464" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="1467" class="Symbol">λ</a> <a id="1469" class="Keyword">where</a>
  <a id="1477" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>     <a id="1486" class="Symbol">→</a> <a id="1488" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>
  <a id="1495" class="Symbol">(</a><a id="1496" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1500" href="README.Case.html#1500" class="Bound">m′</a><a id="1502" class="Symbol">)</a> <a id="1504" class="Symbol">→</a> <a id="1506" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1510" class="Symbol">(</a><a id="1511" href="README.Case.html#1409" class="Function">div2</a> <a id="1516" href="README.Case.html#1500" class="Bound">m′</a><a id="1518" class="Symbol">)</a>


<a id="1522" class="Comment">-- Note that some natural uses of case are rejected by the termination</a>
<a id="1593" class="Comment">-- checker:</a>

<a id="1606" class="Comment">-- module _ {a} {A : Set a} (eq? : Decidable {A = A} _≡_) where</a>

<a id="1671" class="Comment">--  pairBy : List A → List (A ⊎ (A × A))</a>
<a id="1712" class="Comment">--  pairBy []           = []</a>
<a id="1741" class="Comment">--  pairBy (x ∷ [])     = inj₁ x ∷ []</a>
<a id="1779" class="Comment">--  pairBy (x ∷ y ∷ xs) = case eq? x y of λ where</a>
<a id="1829" class="Comment">--    (yes _) → inj₂ (x , y) ∷ pairBy xs</a>
<a id="1870" class="Comment">--    (no _)  → inj₁ x ∷ pairBy (y ∷ xs)</a>
</pre></body></html>