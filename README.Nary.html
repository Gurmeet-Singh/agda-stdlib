<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Nary</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the generic n-ary operations the stdlib provides</a>
<a id="179" class="Comment">-- can be used</a>
<a id="194" class="Comment">------------------------------------------------------------------------</a>

<a id="268" class="Symbol">{-#</a> <a id="272" class="Keyword">OPTIONS</a> <a id="280" class="Pragma">--cubical-compatible</a> <a id="301" class="Pragma">--safe</a> <a id="308" class="Symbol">#-}</a>

<a id="313" class="Keyword">module</a> <a id="320" href="README.Nary.html" class="Module">README.Nary</a> <a id="332" class="Keyword">where</a>

<a id="339" class="Keyword">open</a> <a id="344" class="Keyword">import</a> <a id="351" href="Level.html" class="Module">Level</a> <a id="357" class="Keyword">using</a> <a id="363" class="Symbol">(</a><a id="364" href="Agda.Primitive.html#591" class="Postulate">Level</a><a id="369" class="Symbol">)</a>
<a id="371" class="Keyword">open</a> <a id="376" class="Keyword">import</a> <a id="383" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="397" class="Keyword">open</a> <a id="402" class="Keyword">import</a> <a id="409" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="429" class="Keyword">open</a> <a id="434" class="Keyword">import</a> <a id="441" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="450" class="Keyword">using</a> <a id="456" class="Symbol">(</a><a id="457" href="Data.Fin.Base.html#1312" class="Datatype">Fin</a><a id="460" class="Symbol">;</a> <a id="462" href="Data.Fin.Base.html#2005" class="Function">fromℕ</a><a id="467" class="Symbol">;</a> <a id="469" href="Data.Fin.html#739" class="Function Operator">#_</a><a id="471" class="Symbol">;</a> <a id="473" href="Data.Fin.Base.html#3276" class="Function">inject₁</a><a id="480" class="Symbol">)</a>
<a id="482" class="Keyword">open</a> <a id="487" class="Keyword">import</a> <a id="494" href="Data.List.html" class="Module">Data.List</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Data.List.Properties.html" class="Module">Data.List.Properties</a>
<a id="537" class="Keyword">open</a> <a id="542" class="Keyword">import</a> <a id="549" href="Data.Product.html" class="Module">Data.Product</a> <a id="562" class="Keyword">using</a> <a id="568" class="Symbol">(</a><a id="569" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="572" class="Symbol">;</a> <a id="574" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="577" class="Symbol">)</a>
<a id="579" class="Keyword">open</a> <a id="584" class="Keyword">import</a> <a id="591" href="Data.Sum.Base.html" class="Module">Data.Sum.Base</a> <a id="605" class="Keyword">using</a> <a id="611" class="Symbol">(</a><a id="612" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a><a id="616" class="Symbol">;</a> <a id="618" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a><a id="622" class="Symbol">)</a>
<a id="624" class="Keyword">open</a> <a id="629" class="Keyword">import</a> <a id="636" href="Function.html" class="Module">Function</a>
<a id="645" class="Keyword">open</a> <a id="650" class="Keyword">import</a> <a id="657" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="674" class="Keyword">open</a> <a id="679" class="Keyword">import</a> <a id="686" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="702" class="Keyword">using</a> <a id="708" class="Symbol">(</a><a id="709" class="Keyword">module</a> <a id="716" href="Relation.Binary.Definitions.html#2791" class="Module">Tri</a><a id="719" class="Symbol">);</a> <a id="722" class="Keyword">open</a> <a id="727" href="Relation.Binary.Definitions.html#2791" class="Module">Tri</a>
<a id="731" class="Keyword">open</a> <a id="736" class="Keyword">import</a> <a id="743" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="782" class="Keyword">private</a>
  <a id="792" class="Keyword">variable</a>
    <a id="805" href="README.Nary.html#805" class="Generalizable">a</a> <a id="807" href="README.Nary.html#807" class="Generalizable">b</a> <a id="809" href="README.Nary.html#809" class="Generalizable">c</a> <a id="811" href="README.Nary.html#811" class="Generalizable">d</a> <a id="813" href="README.Nary.html#813" class="Generalizable">e</a> <a id="815" class="Symbol">:</a> <a id="817" href="Agda.Primitive.html#591" class="Postulate">Level</a>
    <a id="827" href="README.Nary.html#827" class="Generalizable">A</a> <a id="829" class="Symbol">:</a> <a id="831" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="835" href="README.Nary.html#805" class="Generalizable">a</a>
    <a id="841" href="README.Nary.html#841" class="Generalizable">B</a> <a id="843" class="Symbol">:</a> <a id="845" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="849" href="README.Nary.html#807" class="Generalizable">b</a>
    <a id="855" href="README.Nary.html#855" class="Generalizable">C</a> <a id="857" class="Symbol">:</a> <a id="859" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="863" href="README.Nary.html#809" class="Generalizable">c</a>
    <a id="869" href="README.Nary.html#869" class="Generalizable">D</a> <a id="871" class="Symbol">:</a> <a id="873" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="877" href="README.Nary.html#811" class="Generalizable">d</a>
    <a id="883" href="README.Nary.html#883" class="Generalizable">E</a> <a id="885" class="Symbol">:</a> <a id="887" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="891" href="README.Nary.html#813" class="Generalizable">e</a>

<a id="894" class="Comment">------------------------------------------------------------------------</a>
<a id="967" class="Comment">-- Introduction</a>
<a id="983" class="Comment">------------------------------------------------------------------------</a>

<a id="1057" class="Comment">-- Function.Nary.NonDependent and Data.Product.N-ary.Heterogeneous provide</a>
<a id="1132" class="Comment">-- a generic representation of n-ary heterogeneous (non dependent) products</a>
<a id="1208" class="Comment">-- and the corresponding types of (non-dependent) n-ary functions. The</a>
<a id="1279" class="Comment">-- representation works well with inference thus allowing us to use generic</a>
<a id="1355" class="Comment">-- combinators to manipulate such functions.</a>

<a id="1401" class="Keyword">open</a> <a id="1406" class="Keyword">import</a> <a id="1413" href="Data.Product.Nary.NonDependent.html" class="Module">Data.Product.Nary.NonDependent</a>
<a id="1444" class="Keyword">open</a> <a id="1449" class="Keyword">import</a> <a id="1456" href="Function.Nary.NonDependent.html" class="Module">Function.Nary.NonDependent</a>
<a id="1483" class="Keyword">open</a> <a id="1488" class="Keyword">import</a> <a id="1495" href="Relation.Nary.html" class="Module">Relation.Nary</a>


<a id="1511" class="Comment">------------------------------------------------------------------------</a>
<a id="1584" class="Comment">-- Generalised equality-manipulating combinators</a>
<a id="1633" class="Comment">------------------------------------------------------------------------</a>

<a id="1707" class="Comment">-- By default the standard library provides users with (we are leaving out</a>
<a id="1782" class="Comment">-- the implicit arguments here):</a>
<a id="1815" class="Comment">--</a>
<a id="1818" class="Comment">-- cong   : (f : A₁      → B) → a₁ ≡ b₁           → f a₁   ≡ f b₁</a>
<a id="1884" class="Comment">-- cong₂  : (f : A₁ → A₂ → B) → a₁ ≡ b₁ → a₂ ≡ b₂ → f a₁ a₂ ≡ f b₁ b₂</a>
<a id="1954" class="Comment">--</a>
<a id="1957" class="Comment">-- and</a>
<a id="1964" class="Comment">--</a>
<a id="1967" class="Comment">-- subst  : (P : A₁      → Set p) → a₁ ≡ b₁           → P a₁    → P b₁</a>
<a id="2038" class="Comment">-- subst₂ : (P : A₁ → A₂ → Set p) → a₁ ≡ b₁ → a₂ ≡ b₂ → P a₁ a₂ → P b₁ b₂</a>
<a id="2112" class="Comment">--</a>
<a id="2115" class="Comment">-- This pattern can be generalised to any natural number `n`. Thanks to our</a>
<a id="2191" class="Comment">-- library for n-ary functions, we can write the types and implementations</a>
<a id="2266" class="Comment">-- of `congₙ` and `substₙ`.</a>

<a id="2295" class="Comment">------------------------------------------------------------------------</a>
<a id="2368" class="Comment">-- congₙ : ∀ n (f : A₁ → ⋯ → Aₙ → B) →</a>
<a id="2407" class="Comment">--         a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → f a₁ ⋯ aₙ ≡ f b₁ ⋯ bₙ</a>

<a id="2463" class="Comment">-- It may be used directly to prove something:</a>

<a id="2511" href="README.Nary.html#2511" class="Function">_</a> <a id="2513" class="Symbol">:</a> <a id="2515" class="Symbol">∀</a> <a id="2517" class="Symbol">(</a><a id="2518" href="README.Nary.html#2518" class="Bound">as</a> <a id="2521" href="README.Nary.html#2521" class="Bound">bs</a> <a id="2524" href="README.Nary.html#2524" class="Bound">cs</a> <a id="2527" class="Symbol">:</a> <a id="2529" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="2534" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2535" class="Symbol">)</a> <a id="2537" class="Symbol">→</a>
       <a id="2546" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2550" class="Symbol">(</a><a id="2551" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2555" class="Symbol">(</a><a id="2556" href="README.Nary.html#2518" class="Bound">as</a> <a id="2559" href="Data.List.Base.html#1943" class="Function Operator">++</a> <a id="2562" class="InductiveConstructor">[]</a><a id="2564" class="Symbol">)</a> <a id="2566" class="Symbol">(</a><a id="2567" href="Data.List.Base.html#1620" class="Function">map</a> <a id="2571" href="Function.Base.html#704" class="Function">id</a> <a id="2574" href="README.Nary.html#2524" class="Bound">cs</a><a id="2576" class="Symbol">))</a> <a id="2579" class="Symbol">(</a><a id="2580" href="Data.List.Base.html#7001" class="Function">reverse</a> <a id="2588" class="Symbol">(</a><a id="2589" href="Data.List.Base.html#7001" class="Function">reverse</a> <a id="2597" href="README.Nary.html#2521" class="Bound">bs</a><a id="2599" class="Symbol">))</a>
     <a id="2607" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2609" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2613" class="Symbol">(</a><a id="2614" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2618" href="README.Nary.html#2518" class="Bound">as</a> <a id="2621" href="README.Nary.html#2524" class="Bound">cs</a><a id="2623" class="Symbol">)</a> <a id="2625" href="README.Nary.html#2521" class="Bound">bs</a>
<a id="2628" class="Symbol">_</a> <a id="2630" class="Symbol">=</a> <a id="2632" class="Symbol">λ</a> <a id="2634" href="README.Nary.html#2634" class="Bound">as</a> <a id="2637" href="README.Nary.html#2637" class="Bound">bs</a> <a id="2640" href="README.Nary.html#2640" class="Bound">cs</a> <a id="2643" class="Symbol">→</a> <a id="2645" href="Function.Nary.NonDependent.html#2024" class="Function">congₙ</a> <a id="2651" class="Number">3</a> <a id="2653" class="Symbol">(λ</a> <a id="2656" href="README.Nary.html#2656" class="Bound">as</a> <a id="2659" href="README.Nary.html#2659" class="Bound">bs</a> <a id="2662" class="Symbol">→</a> <a id="2664" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2668" class="Symbol">(</a><a id="2669" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2673" href="README.Nary.html#2656" class="Bound">as</a> <a id="2676" href="README.Nary.html#2659" class="Bound">bs</a><a id="2678" class="Symbol">))</a>
                         <a id="2706" class="Symbol">(</a><a id="2707" href="Data.List.Properties.html#5768" class="Function">++-identityʳ</a> <a id="2720" href="README.Nary.html#2634" class="Bound">as</a><a id="2722" class="Symbol">)</a>
                         <a id="2749" class="Symbol">(</a><a id="2750" href="Data.List.Properties.html#3023" class="Function">map-id</a> <a id="2757" href="README.Nary.html#2640" class="Bound">cs</a><a id="2759" class="Symbol">)</a>
                         <a id="2786" class="Symbol">(</a><a id="2787" href="Data.List.Properties.html#39415" class="Function">reverse-involutive</a> <a id="2806" href="README.Nary.html#2637" class="Bound">bs</a><a id="2808" class="Symbol">)</a>

<a id="2811" class="Comment">-- Or as part of a longer derivation:</a>

<a id="2850" href="README.Nary.html#2850" class="Function">_</a> <a id="2852" class="Symbol">:</a> <a id="2854" class="Symbol">∀</a> <a id="2856" href="README.Nary.html#2856" class="Bound">m</a> <a id="2858" href="README.Nary.html#2858" class="Bound">n</a> <a id="2860" href="README.Nary.html#2860" class="Bound">p</a> <a id="2862" href="README.Nary.html#2862" class="Bound">q</a> <a id="2864" class="Symbol">→</a> <a id="2866" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2870" class="Symbol">(</a><a id="2871" href="README.Nary.html#2856" class="Bound">m</a> <a id="2873" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2875" class="Symbol">(</a><a id="2876" href="README.Nary.html#2860" class="Bound">p</a> <a id="2878" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2880" href="README.Nary.html#2858" class="Bound">n</a><a id="2881" class="Symbol">)</a> <a id="2883" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2885" class="Symbol">(</a><a id="2886" href="README.Nary.html#2862" class="Bound">q</a> <a id="2888" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="2890" class="Symbol">(</a><a id="2891" href="README.Nary.html#2856" class="Bound">m</a> <a id="2893" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2895" href="README.Nary.html#2858" class="Bound">n</a><a id="2896" class="Symbol">)))</a>
              <a id="2914" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2916" class="Symbol">(</a><a id="2917" href="README.Nary.html#2856" class="Bound">m</a> <a id="2919" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2921" class="Number">0</a><a id="2922" class="Symbol">)</a> <a id="2924" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2926" class="Symbol">(</a><a id="2927" href="README.Nary.html#2858" class="Bound">n</a> <a id="2929" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2931" href="README.Nary.html#2860" class="Bound">p</a><a id="2932" class="Symbol">)</a> <a id="2934" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2936" class="Symbol">(</a><a id="2937" href="README.Nary.html#2862" class="Bound">q</a> <a id="2939" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="2941" href="README.Nary.html#2856" class="Bound">m</a> <a id="2943" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2945" href="README.Nary.html#2862" class="Bound">q</a> <a id="2947" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="2949" href="README.Nary.html#2858" class="Bound">n</a><a id="2950" class="Symbol">)</a> <a id="2952" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2954" class="Number">1</a>
<a id="2956" class="Symbol">_</a> <a id="2958" class="Symbol">=</a> <a id="2960" class="Symbol">λ</a> <a id="2962" href="README.Nary.html#2962" class="Bound">m</a> <a id="2964" href="README.Nary.html#2964" class="Bound">n</a> <a id="2966" href="README.Nary.html#2966" class="Bound">p</a> <a id="2968" href="README.Nary.html#2968" class="Bound">q</a> <a id="2970" class="Symbol">→</a> <a id="2972" href="Relation.Binary.PropositionalEquality.Core.html#2834" class="Function Operator">begin</a>
    <a id="2982" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2986" class="Symbol">(</a><a id="2987" href="README.Nary.html#2962" class="Bound">m</a> <a id="2989" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2991" class="Symbol">(</a><a id="2992" href="README.Nary.html#2966" class="Bound">p</a> <a id="2994" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2996" href="README.Nary.html#2964" class="Bound">n</a><a id="2997" class="Symbol">)</a> <a id="2999" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3001" class="Symbol">(</a><a id="3002" href="README.Nary.html#2968" class="Bound">q</a> <a id="3004" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3006" class="Symbol">(</a><a id="3007" href="README.Nary.html#2962" class="Bound">m</a> <a id="3009" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3011" href="README.Nary.html#2964" class="Bound">n</a><a id="3012" class="Symbol">)))</a> <a id="3016" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">≡⟨</a> <a id="3019" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="3026" class="Number">1</a> <a id="3028" class="Symbol">_</a> <a id="3030" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">⟩</a>
    <a id="3036" href="README.Nary.html#2962" class="Bound">m</a> <a id="3038" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3040" class="Symbol">(</a><a id="3041" href="README.Nary.html#2966" class="Bound">p</a> <a id="3043" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3045" href="README.Nary.html#2964" class="Bound">n</a><a id="3046" class="Symbol">)</a> <a id="3048" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3050" class="Symbol">(</a><a id="3051" href="README.Nary.html#2968" class="Bound">q</a> <a id="3053" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3055" class="Symbol">(</a><a id="3056" href="README.Nary.html#2962" class="Bound">m</a> <a id="3058" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3060" href="README.Nary.html#2964" class="Bound">n</a><a id="3061" class="Symbol">))</a> <a id="3064" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3066" class="Number">1</a>   <a id="3070" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">≡⟨</a> <a id="3073" href="Function.Nary.NonDependent.html#2024" class="Function">congₙ</a> <a id="3079" class="Number">3</a> <a id="3081" class="Symbol">(λ</a> <a id="3084" href="README.Nary.html#3084" class="Bound">m</a> <a id="3086" href="README.Nary.html#3086" class="Bound">n</a> <a id="3088" href="README.Nary.html#3088" class="Bound">p</a> <a id="3090" class="Symbol">→</a> <a id="3092" href="README.Nary.html#3084" class="Bound">m</a> <a id="3094" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3096" href="README.Nary.html#3086" class="Bound">n</a> <a id="3098" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3100" href="README.Nary.html#3088" class="Bound">p</a> <a id="3102" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3104" class="Number">1</a><a id="3105" class="Symbol">)</a>
                                                 <a id="3156" class="Symbol">(</a><a id="3157" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="3164" class="Number">0</a> <a id="3166" href="README.Nary.html#2962" class="Bound">m</a><a id="3167" class="Symbol">)</a>
                                                 <a id="3218" class="Symbol">(</a><a id="3219" href="Data.Nat.Properties.html#21339" class="Function">*-comm</a> <a id="3226" href="README.Nary.html#2966" class="Bound">p</a> <a id="3228" href="README.Nary.html#2964" class="Bound">n</a><a id="3229" class="Symbol">)</a>
                                                 <a id="3280" class="Symbol">(</a><a id="3281" href="Data.Nat.Properties.html#28849" class="Function">^-distribˡ-+-*</a> <a id="3296" href="README.Nary.html#2968" class="Bound">q</a> <a id="3298" href="README.Nary.html#2962" class="Bound">m</a> <a id="3300" href="README.Nary.html#2964" class="Bound">n</a><a id="3301" class="Symbol">)</a>
                                       <a id="3342" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">⟩</a>
    <a id="3348" href="README.Nary.html#2962" class="Bound">m</a> <a id="3350" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3352" class="Number">0</a> <a id="3354" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3356" href="README.Nary.html#2964" class="Bound">n</a> <a id="3358" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3360" href="README.Nary.html#2966" class="Bound">p</a> <a id="3362" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3364" class="Symbol">(</a><a id="3365" href="README.Nary.html#2968" class="Bound">q</a> <a id="3367" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3369" href="README.Nary.html#2962" class="Bound">m</a><a id="3370" class="Symbol">)</a> <a id="3372" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3374" class="Symbol">(</a><a id="3375" href="README.Nary.html#2968" class="Bound">q</a> <a id="3377" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3379" href="README.Nary.html#2964" class="Bound">n</a><a id="3380" class="Symbol">)</a> <a id="3382" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3384" class="Number">1</a> <a id="3386" href="Relation.Binary.PropositionalEquality.Core.html#3133" class="Function Operator">∎</a> <a id="3388" class="Keyword">where</a> <a id="3394" class="Keyword">open</a> <a id="3399" href="Relation.Binary.PropositionalEquality.Core.html#2736" class="Module">≡-Reasoning</a>

<a id="3412" class="Comment">-- Partial application of the functional argument is fine: the number of arguments</a>
<a id="3495" class="Comment">-- `congₙ` is going to take is determined by its first argument (a natural number)</a>
<a id="3578" class="Comment">-- and not by the type of the function it works on.</a>

<a id="3631" href="README.Nary.html#3631" class="Function">_</a> <a id="3633" class="Symbol">:</a> <a id="3635" class="Symbol">∀</a> <a id="3637" href="README.Nary.html#3637" class="Bound">m</a> <a id="3639" class="Symbol">→</a> <a id="3641" class="Symbol">(</a><a id="3642" href="README.Nary.html#3637" class="Bound">m</a> <a id="3644" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+_</a><a id="3646" class="Symbol">)</a> <a id="3648" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="3650" class="Symbol">((</a><a id="3652" href="README.Nary.html#3637" class="Bound">m</a> <a id="3654" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3656" class="Number">0</a><a id="3657" class="Symbol">)</a> <a id="3659" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+_</a><a id="3661" class="Symbol">)</a>
<a id="3663" class="Symbol">_</a> <a id="3665" class="Symbol">=</a> <a id="3667" class="Symbol">λ</a> <a id="3669" href="README.Nary.html#3669" class="Bound">m</a> <a id="3671" class="Symbol">→</a> <a id="3673" href="Function.Nary.NonDependent.html#2024" class="Function">congₙ</a> <a id="3679" class="Number">1</a> <a id="3681" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="3685" class="Symbol">(</a><a id="3686" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="3693" class="Number">0</a> <a id="3695" href="README.Nary.html#3669" class="Bound">m</a><a id="3696" class="Symbol">)</a>

<a id="3699" class="Comment">-- We don&#39;t have to work on the function&#39;s first argument either: we can just as</a>
<a id="3780" class="Comment">-- easily use `congₙ` to act on the second one by `flip`ping it. See `holeₙ` for</a>
<a id="3861" class="Comment">-- a generalisation of this idea allowing to target *any* of the function&#39;s</a>
<a id="3937" class="Comment">-- arguments and not just the first or second one.</a>

<a id="3989" href="README.Nary.html#3989" class="Function">_</a> <a id="3991" class="Symbol">:</a> <a id="3993" class="Symbol">∀</a> <a id="3995" href="README.Nary.html#3995" class="Bound">m</a> <a id="3997" class="Symbol">→</a> <a id="3999" class="Symbol">(</a><a id="4000" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+</a> <a id="4003" href="README.Nary.html#3995" class="Bound">m</a><a id="4004" class="Symbol">)</a> <a id="4006" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4008" class="Symbol">(</a><a id="4009" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+</a> <a id="4012" class="Symbol">(</a><a id="4013" href="README.Nary.html#3995" class="Bound">m</a> <a id="4015" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4017" class="Number">0</a><a id="4018" class="Symbol">))</a>
<a id="4021" class="Symbol">_</a> <a id="4023" class="Symbol">=</a> <a id="4025" class="Symbol">λ</a> <a id="4027" href="README.Nary.html#4027" class="Bound">m</a> <a id="4029" class="Symbol">→</a> <a id="4031" href="Function.Nary.NonDependent.html#2024" class="Function">congₙ</a> <a id="4037" class="Number">1</a> <a id="4039" class="Symbol">(</a><a id="4040" href="Function.Base.html#1638" class="Function">flip</a> <a id="4045" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="4048" class="Symbol">)</a> <a id="4050" class="Symbol">(</a><a id="4051" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4058" class="Number">0</a> <a id="4060" href="README.Nary.html#4027" class="Bound">m</a><a id="4061" class="Symbol">)</a>

<a id="4064" class="Comment">------------------------------------------------------------------------</a>
<a id="4137" class="Comment">-- substₙ : (P : A₁ → ⋯ → Aₙ → Set p) →</a>
<a id="4177" class="Comment">--          a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → P a₁ ⋯ aₙ → P b₁ ⋯ bₙ</a>

<a id="4234" class="Comment">-- We can play the same type of game with subst</a>

<a id="4283" class="Keyword">open</a> <a id="4288" class="Keyword">import</a> <a id="4295" href="Agda.Builtin.Nat.html" class="Module">Agda.Builtin.Nat</a> <a id="4312" class="Keyword">using</a> <a id="4318" class="Symbol">(</a><a id="4319" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a><a id="4329" class="Symbol">)</a>

<a id="4332" class="Comment">-- Because we know from the definition `mod-helper` that this equation holds:</a>
<a id="4410" class="Comment">-- mod-helper k m (suc n) (suc j) = mod-helper (suc k) m n j</a>
<a id="4471" class="Comment">-- we should be able to prove the slightly modified statement by transforming</a>
<a id="4549" class="Comment">-- all the `x + 1` into `suc x`. We can do so using `substₙ`.</a>

<a id="4612" href="README.Nary.html#4612" class="Function">_</a> <a id="4614" class="Symbol">:</a> <a id="4616" class="Symbol">∀</a> <a id="4618" href="README.Nary.html#4618" class="Bound">k</a> <a id="4620" href="README.Nary.html#4620" class="Bound">m</a> <a id="4622" href="README.Nary.html#4622" class="Bound">n</a> <a id="4624" href="README.Nary.html#4624" class="Bound">j</a> <a id="4626" class="Symbol">→</a> <a id="4628" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4639" href="README.Nary.html#4618" class="Bound">k</a> <a id="4641" href="README.Nary.html#4620" class="Bound">m</a> <a id="4643" class="Symbol">(</a><a id="4644" href="README.Nary.html#4622" class="Bound">n</a> <a id="4646" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4648" class="Number">1</a><a id="4649" class="Symbol">)</a> <a id="4651" class="Symbol">(</a><a id="4652" href="README.Nary.html#4624" class="Bound">j</a> <a id="4654" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4656" class="Number">1</a><a id="4657" class="Symbol">)</a> <a id="4659" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4661" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4672" class="Symbol">(</a><a id="4673" href="README.Nary.html#4618" class="Bound">k</a> <a id="4675" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4677" class="Number">1</a><a id="4678" class="Symbol">)</a> <a id="4680" href="README.Nary.html#4620" class="Bound">m</a> <a id="4682" href="README.Nary.html#4622" class="Bound">n</a> <a id="4684" href="README.Nary.html#4624" class="Bound">j</a>
<a id="4686" class="Symbol">_</a> <a id="4688" class="Symbol">=</a> <a id="4690" class="Symbol">λ</a> <a id="4692" href="README.Nary.html#4692" class="Bound">k</a> <a id="4694" href="README.Nary.html#4694" class="Bound">m</a> <a id="4696" href="README.Nary.html#4696" class="Bound">n</a> <a id="4698" href="README.Nary.html#4698" class="Bound">j</a> <a id="4700" class="Symbol">→</a>
    <a id="4706" class="Keyword">let</a> <a id="4710" href="README.Nary.html#4710" class="Bound">P</a> <a id="4712" href="README.Nary.html#4712" class="Bound">sk</a> <a id="4715" href="README.Nary.html#4715" class="Bound">sn</a> <a id="4718" href="README.Nary.html#4718" class="Bound">sj</a> <a id="4721" class="Symbol">=</a> <a id="4723" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4734" href="README.Nary.html#4692" class="Bound">k</a> <a id="4736" href="README.Nary.html#4694" class="Bound">m</a> <a id="4738" href="README.Nary.html#4715" class="Bound">sn</a> <a id="4741" href="README.Nary.html#4718" class="Bound">sj</a> <a id="4744" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4746" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4757" href="README.Nary.html#4712" class="Bound">sk</a> <a id="4760" href="README.Nary.html#4694" class="Bound">m</a> <a id="4762" href="README.Nary.html#4696" class="Bound">n</a> <a id="4764" href="README.Nary.html#4698" class="Bound">j</a>
    <a id="4770" class="Keyword">in</a> <a id="4773" href="Relation.Nary.html#3708" class="Function">substₙ</a> <a id="4780" href="README.Nary.html#4710" class="Bound">P</a> <a id="4782" class="Symbol">(</a><a id="4783" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4790" class="Number">1</a> <a id="4792" href="README.Nary.html#4692" class="Bound">k</a><a id="4793" class="Symbol">)</a> <a id="4795" class="Symbol">(</a><a id="4796" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4803" class="Number">1</a> <a id="4805" href="README.Nary.html#4696" class="Bound">n</a><a id="4806" class="Symbol">)</a> <a id="4808" class="Symbol">(</a><a id="4809" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4816" class="Number">1</a> <a id="4818" href="README.Nary.html#4698" class="Bound">j</a><a id="4819" class="Symbol">)</a> <a id="4821" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="4827" class="Comment">-----------------------------------------------------------------------</a>
<a id="4899" class="Comment">-- Generic programs working on n-ary products &amp; functions</a>
<a id="4957" class="Comment">-----------------------------------------------------------------------</a>

<a id="5030" class="Comment">-----------------------------------------------------------------------</a>
<a id="5102" class="Comment">-- curryₙ   : ∀ n → (A₁ × ⋯ × Aₙ → B) → A₁ → ⋯ → Aₙ → B</a>
<a id="5158" class="Comment">-- uncurryₙ : ∀ n → (A₁ → ⋯ → Aₙ → B) → A₁ × ⋯ × Aₙ → B</a>

<a id="5215" class="Comment">-- The first thing we may want to do generically is convert between</a>
<a id="5283" class="Comment">-- curried function types and uncurried ones. We can do this by using:</a>

<a id="5355" class="Comment">-- They both work the same way so we will focus on curryₙ only here.</a>
<a id="5424" class="Comment">-- If we pass to `curryₙ` the arity of its argument then we obtain a</a>
<a id="5493" class="Comment">-- fully curried function.</a>

<a id="curry₁"></a><a id="5521" href="README.Nary.html#5521" class="Function">curry₁</a> <a id="5528" class="Symbol">:</a> <a id="5530" class="Symbol">(</a><a id="5531" href="README.Nary.html#827" class="Generalizable">A</a> <a id="5533" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5535" href="README.Nary.html#841" class="Generalizable">B</a> <a id="5537" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5539" href="README.Nary.html#855" class="Generalizable">C</a> <a id="5541" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5543" href="README.Nary.html#869" class="Generalizable">D</a> <a id="5545" class="Symbol">→</a> <a id="5547" href="README.Nary.html#883" class="Generalizable">E</a><a id="5548" class="Symbol">)</a> <a id="5550" class="Symbol">→</a> <a id="5552" href="README.Nary.html#827" class="Generalizable">A</a> <a id="5554" class="Symbol">→</a> <a id="5556" href="README.Nary.html#841" class="Generalizable">B</a> <a id="5558" class="Symbol">→</a> <a id="5560" href="README.Nary.html#855" class="Generalizable">C</a> <a id="5562" class="Symbol">→</a> <a id="5564" href="README.Nary.html#869" class="Generalizable">D</a> <a id="5566" class="Symbol">→</a> <a id="5568" href="README.Nary.html#883" class="Generalizable">E</a>
<a id="5570" href="README.Nary.html#5521" class="Function">curry₁</a> <a id="5577" class="Symbol">=</a> <a id="5579" href="Data.Product.Nary.NonDependent.html#3688" class="Function">curryₙ</a> <a id="5586" class="Number">4</a>

<a id="5589" class="Comment">-- Note that here we are not flattening arbitrary nestings: products have</a>
<a id="5663" class="Comment">-- to be right nested. Which means that if you have a deeply-nested product</a>
<a id="5739" class="Comment">-- then it won&#39;t be affected by the procedure.</a>

<a id="curry₁′"></a><a id="5787" href="README.Nary.html#5787" class="Function">curry₁′</a> <a id="5795" class="Symbol">:</a> <a id="5797" class="Symbol">(</a><a id="5798" href="README.Nary.html#827" class="Generalizable">A</a> <a id="5800" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5802" class="Symbol">(</a><a id="5803" href="README.Nary.html#841" class="Generalizable">B</a> <a id="5805" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5807" href="README.Nary.html#855" class="Generalizable">C</a><a id="5808" class="Symbol">)</a> <a id="5810" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5812" href="README.Nary.html#869" class="Generalizable">D</a> <a id="5814" class="Symbol">→</a> <a id="5816" href="README.Nary.html#883" class="Generalizable">E</a><a id="5817" class="Symbol">)</a> <a id="5819" class="Symbol">→</a> <a id="5821" href="README.Nary.html#827" class="Generalizable">A</a> <a id="5823" class="Symbol">→</a> <a id="5825" class="Symbol">(</a><a id="5826" href="README.Nary.html#841" class="Generalizable">B</a> <a id="5828" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5830" href="README.Nary.html#855" class="Generalizable">C</a><a id="5831" class="Symbol">)</a> <a id="5833" class="Symbol">→</a> <a id="5835" href="README.Nary.html#869" class="Generalizable">D</a> <a id="5837" class="Symbol">→</a> <a id="5839" href="README.Nary.html#883" class="Generalizable">E</a>
<a id="5841" href="README.Nary.html#5787" class="Function">curry₁′</a> <a id="5849" class="Symbol">=</a> <a id="5851" href="Data.Product.Nary.NonDependent.html#3688" class="Function">curryₙ</a> <a id="5858" class="Number">3</a>

<a id="5861" class="Comment">-- When we are currying a function, we have no obligation to pass its exact</a>
<a id="5937" class="Comment">-- arity as the parameter: we can decide to only curry part of it like so:</a>
<a id="6012" class="Comment">-- Indeed (A₁ × ⋯ × Aₙ → B) can also be seen as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ) → B)</a>

<a id="curry₂"></a><a id="6090" href="README.Nary.html#6090" class="Function">curry₂</a> <a id="6097" class="Symbol">:</a> <a id="6099" class="Symbol">(</a><a id="6100" href="README.Nary.html#827" class="Generalizable">A</a> <a id="6102" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6104" href="README.Nary.html#841" class="Generalizable">B</a> <a id="6106" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6108" href="README.Nary.html#855" class="Generalizable">C</a> <a id="6110" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6112" href="README.Nary.html#869" class="Generalizable">D</a> <a id="6114" class="Symbol">→</a> <a id="6116" href="README.Nary.html#883" class="Generalizable">E</a><a id="6117" class="Symbol">)</a> <a id="6119" class="Symbol">→</a> <a id="6121" href="README.Nary.html#827" class="Generalizable">A</a> <a id="6123" class="Symbol">→</a> <a id="6125" href="README.Nary.html#841" class="Generalizable">B</a> <a id="6127" class="Symbol">→</a> <a id="6129" class="Symbol">(</a><a id="6130" href="README.Nary.html#855" class="Generalizable">C</a> <a id="6132" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6134" href="README.Nary.html#869" class="Generalizable">D</a><a id="6135" class="Symbol">)</a> <a id="6137" class="Symbol">→</a> <a id="6139" href="README.Nary.html#883" class="Generalizable">E</a>
<a id="6141" href="README.Nary.html#6090" class="Function">curry₂</a> <a id="6148" class="Symbol">=</a> <a id="6150" href="Data.Product.Nary.NonDependent.html#3688" class="Function">curryₙ</a> <a id="6157" class="Number">3</a>

<a id="6160" class="Comment">-----------------------------------------------------------------------</a>
<a id="6232" class="Comment">-- projₙ : ∀ n (k : Fin n) → (A₁ × ⋯ × Aₙ) → Aₖ₊₁</a>

<a id="6283" class="Comment">-- Another useful class of functions to manipulate n-ary product is a</a>
<a id="6353" class="Comment">-- generic projection function. Note the (k + 1) in the return index:</a>
<a id="6423" class="Comment">-- Fin counts from 0 up.</a>

<a id="6449" class="Comment">-- It behaves as one expects (Data.Fin&#39;s #_ comes in handy to write down</a>
<a id="6522" class="Comment">-- Fin literals):</a>

<a id="proj₃"></a><a id="6541" href="README.Nary.html#6541" class="Function">proj₃</a> <a id="6547" class="Symbol">:</a> <a id="6549" class="Symbol">(</a><a id="6550" href="README.Nary.html#827" class="Generalizable">A</a> <a id="6552" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6554" href="README.Nary.html#841" class="Generalizable">B</a> <a id="6556" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6558" href="README.Nary.html#855" class="Generalizable">C</a> <a id="6560" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6562" href="README.Nary.html#869" class="Generalizable">D</a> <a id="6564" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6566" href="README.Nary.html#883" class="Generalizable">E</a><a id="6567" class="Symbol">)</a> <a id="6569" class="Symbol">→</a> <a id="6571" href="README.Nary.html#855" class="Generalizable">C</a>
<a id="6573" href="README.Nary.html#6541" class="Function">proj₃</a> <a id="6579" class="Symbol">=</a> <a id="6581" href="Data.Product.Nary.NonDependent.html#6482" class="Function">projₙ</a> <a id="6587" class="Number">5</a> <a id="6589" class="Symbol">(</a><a id="6590" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="6592" class="Number">2</a><a id="6593" class="Symbol">)</a>

<a id="6596" class="Comment">-- Of course we can once more project the &quot;tail&quot; of the n-ary product by</a>
<a id="6669" class="Comment">-- passing `projₙ` a natural number which is smaller than the size of the</a>
<a id="6743" class="Comment">-- n-ary product, seeing (A₁ × ⋯ × Aₙ) as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ)).</a>

<a id="proj₃′"></a><a id="6812" href="README.Nary.html#6812" class="Function">proj₃′</a> <a id="6819" class="Symbol">:</a> <a id="6821" class="Symbol">(</a><a id="6822" href="README.Nary.html#827" class="Generalizable">A</a> <a id="6824" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6826" href="README.Nary.html#841" class="Generalizable">B</a> <a id="6828" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6830" href="README.Nary.html#855" class="Generalizable">C</a> <a id="6832" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6834" href="README.Nary.html#869" class="Generalizable">D</a> <a id="6836" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6838" href="README.Nary.html#883" class="Generalizable">E</a><a id="6839" class="Symbol">)</a> <a id="6841" class="Symbol">→</a> <a id="6843" href="README.Nary.html#855" class="Generalizable">C</a> <a id="6845" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6847" href="README.Nary.html#869" class="Generalizable">D</a> <a id="6849" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6851" href="README.Nary.html#883" class="Generalizable">E</a>
<a id="6853" href="README.Nary.html#6812" class="Function">proj₃′</a> <a id="6860" class="Symbol">=</a> <a id="6862" href="Data.Product.Nary.NonDependent.html#6482" class="Function">projₙ</a> <a id="6868" class="Number">3</a> <a id="6870" class="Symbol">(</a><a id="6871" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="6873" class="Number">2</a><a id="6874" class="Symbol">)</a>

<a id="6877" class="Comment">-----------------------------------------------------------------------</a>
<a id="6949" class="Comment">-- insertₙ : ∀ n (k : Fin (suc n)) →</a>
<a id="6986" class="Comment">--           B → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B × Aₖ₊₁ × ⋯ Aₙ)</a>

<a id="insert₁"></a><a id="7050" href="README.Nary.html#7050" class="Function">insert₁</a> <a id="7058" class="Symbol">:</a> <a id="7060" href="README.Nary.html#855" class="Generalizable">C</a> <a id="7062" class="Symbol">→</a> <a id="7064" class="Symbol">(</a><a id="7065" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7067" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7069" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7071" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7073" href="README.Nary.html#869" class="Generalizable">D</a> <a id="7075" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7077" href="README.Nary.html#883" class="Generalizable">E</a><a id="7078" class="Symbol">)</a> <a id="7080" class="Symbol">→</a> <a id="7082" class="Symbol">(</a><a id="7083" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7085" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7087" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7089" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7091" href="README.Nary.html#855" class="Generalizable">C</a> <a id="7093" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7095" href="README.Nary.html#869" class="Generalizable">D</a> <a id="7097" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7099" href="README.Nary.html#883" class="Generalizable">E</a><a id="7100" class="Symbol">)</a>
<a id="7102" href="README.Nary.html#7050" class="Function">insert₁</a> <a id="7110" class="Symbol">=</a> <a id="7112" href="Data.Product.Nary.NonDependent.html#8535" class="Function">insertₙ</a> <a id="7120" class="Number">4</a> <a id="7122" class="Symbol">(</a><a id="7123" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7125" class="Number">2</a><a id="7126" class="Symbol">)</a>

<a id="insert₁′"></a><a id="7129" href="README.Nary.html#7129" class="Function">insert₁′</a> <a id="7138" class="Symbol">:</a> <a id="7140" href="README.Nary.html#855" class="Generalizable">C</a> <a id="7142" class="Symbol">→</a> <a id="7144" class="Symbol">(</a><a id="7145" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7147" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7149" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7151" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7153" href="README.Nary.html#869" class="Generalizable">D</a> <a id="7155" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7157" href="README.Nary.html#883" class="Generalizable">E</a><a id="7158" class="Symbol">)</a> <a id="7160" class="Symbol">→</a> <a id="7162" class="Symbol">(</a><a id="7163" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7165" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7167" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7169" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7171" href="README.Nary.html#855" class="Generalizable">C</a> <a id="7173" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7175" href="README.Nary.html#869" class="Generalizable">D</a> <a id="7177" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7179" href="README.Nary.html#883" class="Generalizable">E</a><a id="7180" class="Symbol">)</a>
<a id="7182" href="README.Nary.html#7129" class="Function">insert₁′</a> <a id="7191" class="Symbol">=</a> <a id="7193" href="Data.Product.Nary.NonDependent.html#8535" class="Function">insertₙ</a> <a id="7201" class="Number">3</a> <a id="7203" class="Symbol">(</a><a id="7204" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7206" class="Number">2</a><a id="7207" class="Symbol">)</a>

<a id="7210" class="Comment">-- Note that `insertₙ` takes a `Fin (suc n)`. Indeed in an n-ary product</a>
<a id="7283" class="Comment">-- there are (suc n) positions at which one may insert a value. We may</a>
<a id="7354" class="Comment">-- insert at the front or the back of the product:</a>

<a id="insert-front"></a><a id="7406" href="README.Nary.html#7406" class="Function">insert-front</a> <a id="7419" class="Symbol">:</a> <a id="7421" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7423" class="Symbol">→</a> <a id="7425" class="Symbol">(</a><a id="7426" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7428" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7430" href="README.Nary.html#855" class="Generalizable">C</a> <a id="7432" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7434" href="README.Nary.html#869" class="Generalizable">D</a> <a id="7436" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7438" href="README.Nary.html#883" class="Generalizable">E</a><a id="7439" class="Symbol">)</a> <a id="7441" class="Symbol">→</a> <a id="7443" class="Symbol">(</a><a id="7444" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7446" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7448" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7450" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7452" href="README.Nary.html#855" class="Generalizable">C</a> <a id="7454" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7456" href="README.Nary.html#869" class="Generalizable">D</a> <a id="7458" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7460" href="README.Nary.html#883" class="Generalizable">E</a><a id="7461" class="Symbol">)</a>
<a id="7463" href="README.Nary.html#7406" class="Function">insert-front</a> <a id="7476" class="Symbol">=</a> <a id="7478" href="Data.Product.Nary.NonDependent.html#8535" class="Function">insertₙ</a> <a id="7486" class="Number">4</a> <a id="7488" class="Symbol">(</a><a id="7489" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7491" class="Number">0</a><a id="7492" class="Symbol">)</a>

<a id="insert-back"></a><a id="7495" href="README.Nary.html#7495" class="Function">insert-back</a> <a id="7507" class="Symbol">:</a> <a id="7509" href="README.Nary.html#883" class="Generalizable">E</a> <a id="7511" class="Symbol">→</a> <a id="7513" class="Symbol">(</a><a id="7514" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7516" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7518" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7520" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7522" href="README.Nary.html#855" class="Generalizable">C</a> <a id="7524" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7526" href="README.Nary.html#869" class="Generalizable">D</a><a id="7527" class="Symbol">)</a> <a id="7529" class="Symbol">→</a> <a id="7531" class="Symbol">(</a><a id="7532" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7534" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7536" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7538" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7540" href="README.Nary.html#855" class="Generalizable">C</a> <a id="7542" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7544" href="README.Nary.html#869" class="Generalizable">D</a> <a id="7546" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7548" href="README.Nary.html#883" class="Generalizable">E</a><a id="7549" class="Symbol">)</a>
<a id="7551" href="README.Nary.html#7495" class="Function">insert-back</a> <a id="7563" class="Symbol">=</a> <a id="7565" href="Data.Product.Nary.NonDependent.html#8535" class="Function">insertₙ</a> <a id="7573" class="Number">4</a> <a id="7575" class="Symbol">(</a><a id="7576" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7578" class="Number">4</a><a id="7579" class="Symbol">)</a>

<a id="7582" class="Comment">-----------------------------------------------------------------------</a>
<a id="7654" class="Comment">-- removeₙ : ∀ n (k : Fin n) → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="7728" class="Comment">-- Dual to `insertₙ`, we may remove a value.</a>

<a id="remove₁"></a><a id="7774" href="README.Nary.html#7774" class="Function">remove₁</a> <a id="7782" class="Symbol">:</a> <a id="7784" class="Symbol">(</a><a id="7785" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7787" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7789" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7791" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7793" href="README.Nary.html#855" class="Generalizable">C</a> <a id="7795" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7797" href="README.Nary.html#869" class="Generalizable">D</a> <a id="7799" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7801" href="README.Nary.html#883" class="Generalizable">E</a><a id="7802" class="Symbol">)</a> <a id="7804" class="Symbol">→</a> <a id="7806" class="Symbol">(</a><a id="7807" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7809" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7811" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7813" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7815" href="README.Nary.html#869" class="Generalizable">D</a> <a id="7817" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7819" href="README.Nary.html#883" class="Generalizable">E</a><a id="7820" class="Symbol">)</a>
<a id="7822" href="README.Nary.html#7774" class="Function">remove₁</a> <a id="7830" class="Symbol">=</a> <a id="7832" href="Data.Product.Nary.NonDependent.html#7672" class="Function">removeₙ</a> <a id="7840" class="Number">5</a> <a id="7842" class="Symbol">(</a><a id="7843" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7845" class="Number">2</a><a id="7846" class="Symbol">)</a>

<a id="7849" class="Comment">-- Inserting at `k` and then removing at `inject₁ k` should yield the identity</a>

<a id="remove-insert"></a><a id="7929" href="README.Nary.html#7929" class="Function">remove-insert</a> <a id="7943" class="Symbol">:</a> <a id="7945" href="README.Nary.html#855" class="Generalizable">C</a> <a id="7947" class="Symbol">→</a> <a id="7949" class="Symbol">(</a><a id="7950" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7952" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7954" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7956" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7958" href="README.Nary.html#869" class="Generalizable">D</a> <a id="7960" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7962" href="README.Nary.html#883" class="Generalizable">E</a><a id="7963" class="Symbol">)</a> <a id="7965" class="Symbol">→</a> <a id="7967" class="Symbol">(</a><a id="7968" href="README.Nary.html#827" class="Generalizable">A</a> <a id="7970" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7972" href="README.Nary.html#841" class="Generalizable">B</a> <a id="7974" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7976" href="README.Nary.html#869" class="Generalizable">D</a> <a id="7978" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7980" href="README.Nary.html#883" class="Generalizable">E</a><a id="7981" class="Symbol">)</a>
<a id="7983" href="README.Nary.html#7929" class="Function">remove-insert</a> <a id="7997" href="README.Nary.html#7997" class="Bound">c</a> <a id="7999" class="Symbol">=</a> <a id="8001" href="Data.Product.Nary.NonDependent.html#7672" class="Function">removeₙ</a> <a id="8009" class="Number">5</a> <a id="8011" class="Symbol">(</a><a id="8012" href="Data.Fin.Base.html#3276" class="Function">inject₁</a> <a id="8020" href="README.Nary.html#8050" class="Function">k</a><a id="8021" class="Symbol">)</a> <a id="8023" href="Function.Base.html#3646" class="Function Operator">∘′</a> <a id="8026" href="Data.Product.Nary.NonDependent.html#8535" class="Function">insertₙ</a> <a id="8034" class="Number">4</a> <a id="8036" href="README.Nary.html#8050" class="Function">k</a> <a id="8038" href="README.Nary.html#7997" class="Bound">c</a>
    <a id="8044" class="Keyword">where</a> <a id="8050" href="README.Nary.html#8050" class="Function">k</a> <a id="8052" class="Symbol">=</a> <a id="8054" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8056" class="Number">2</a>

<a id="8059" class="Comment">-----------------------------------------------------------------------</a>
<a id="8131" class="Comment">-- updateₙ : ∀ n (k : Fin n) (f : (a : Aₖ₊₁) → B a) →</a>
<a id="8185" class="Comment">--           (p : A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B (projₙ n k p) × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="8263" class="Comment">-- We can not only project out, insert or remove values: we can update them</a>
<a id="8339" class="Comment">-- in place. The type (and value) of the replacement at position k may depend</a>
<a id="8417" class="Comment">-- upon the current value at position k.</a>

<a id="update₁"></a><a id="8459" href="README.Nary.html#8459" class="Function">update₁</a> <a id="8467" class="Symbol">:</a> <a id="8469" class="Symbol">(</a><a id="8470" href="README.Nary.html#8470" class="Bound">p</a> <a id="8472" class="Symbol">:</a> <a id="8474" href="README.Nary.html#827" class="Generalizable">A</a> <a id="8476" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8478" href="README.Nary.html#841" class="Generalizable">B</a> <a id="8480" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8482" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="8484" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8486" href="README.Nary.html#855" class="Generalizable">C</a> <a id="8488" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8490" href="README.Nary.html#869" class="Generalizable">D</a><a id="8491" class="Symbol">)</a> <a id="8493" class="Symbol">→</a> <a id="8495" class="Symbol">(</a><a id="8496" href="README.Nary.html#827" class="Generalizable">A</a> <a id="8498" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8500" href="README.Nary.html#841" class="Generalizable">B</a> <a id="8502" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8504" href="Data.Fin.Base.html#1312" class="Datatype">Fin</a> <a id="8508" class="Symbol">_</a> <a id="8510" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8512" href="README.Nary.html#855" class="Generalizable">C</a> <a id="8514" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8516" href="README.Nary.html#869" class="Generalizable">D</a><a id="8517" class="Symbol">)</a>
<a id="8519" href="README.Nary.html#8459" class="Function">update₁</a> <a id="8527" class="Symbol">=</a> <a id="8529" href="Data.Product.Nary.NonDependent.html#9342" class="Function">updateₙ</a> <a id="8537" class="Number">5</a> <a id="8539" class="Symbol">(</a><a id="8540" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8542" class="Number">2</a><a id="8543" class="Symbol">)</a> <a id="8545" href="Data.Fin.Base.html#2005" class="Function">fromℕ</a>

<a id="8552" class="Comment">-- We can explicitly use the primed version of `updateₙ` to make it known to</a>
<a id="8629" class="Comment">-- Agda that the update function is non dependent. This type of information</a>
<a id="8705" class="Comment">-- is useful for inference: the tighter the constraints, the easier it is to</a>
<a id="8782" class="Comment">-- find a solution (if possible).</a>

<a id="update₂"></a><a id="8817" href="README.Nary.html#8817" class="Function">update₂</a> <a id="8825" class="Symbol">:</a> <a id="8827" class="Symbol">(</a><a id="8828" href="README.Nary.html#8828" class="Bound">p</a> <a id="8830" class="Symbol">:</a> <a id="8832" href="README.Nary.html#827" class="Generalizable">A</a> <a id="8834" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8836" href="README.Nary.html#841" class="Generalizable">B</a> <a id="8838" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8840" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="8842" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8844" href="README.Nary.html#855" class="Generalizable">C</a> <a id="8846" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8848" href="README.Nary.html#869" class="Generalizable">D</a><a id="8849" class="Symbol">)</a> <a id="8851" class="Symbol">→</a> <a id="8853" class="Symbol">(</a><a id="8854" href="README.Nary.html#827" class="Generalizable">A</a> <a id="8856" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8858" href="README.Nary.html#841" class="Generalizable">B</a> <a id="8860" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8862" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="8867" href="README.Nary.html#869" class="Generalizable">D</a> <a id="8869" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8871" href="README.Nary.html#855" class="Generalizable">C</a> <a id="8873" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8875" href="README.Nary.html#869" class="Generalizable">D</a><a id="8876" class="Symbol">)</a>
<a id="8878" href="README.Nary.html#8817" class="Function">update₂</a> <a id="8886" class="Symbol">=</a> <a id="8888" class="Symbol">λ</a> <a id="8890" href="README.Nary.html#8890" class="Bound">p</a> <a id="8892" class="Symbol">→</a> <a id="8894" href="Data.Product.Nary.NonDependent.html#9688" class="Function">updateₙ′</a> <a id="8903" class="Number">5</a> <a id="8905" class="Symbol">(</a><a id="8906" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8908" class="Number">2</a><a id="8909" class="Symbol">)</a> <a id="8911" class="Symbol">(λ</a> <a id="8914" href="README.Nary.html#8914" class="Bound">n</a> <a id="8916" class="Symbol">→</a> <a id="8918" href="Data.List.Base.html#5347" class="Function">replicate</a> <a id="8928" href="README.Nary.html#8914" class="Bound">n</a> <a id="8930" class="Symbol">(</a><a id="8931" href="Data.Product.Nary.NonDependent.html#6482" class="Function">projₙ</a> <a id="8937" class="Number">5</a> <a id="8939" class="Symbol">(</a><a id="8940" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8942" class="Number">4</a><a id="8943" class="Symbol">)</a> <a id="8945" href="README.Nary.html#8890" class="Bound">p</a><a id="8946" class="Symbol">))</a> <a id="8949" href="README.Nary.html#8890" class="Bound">p</a>

<a id="8952" class="Comment">-----------------------------------------------------------------------</a>
<a id="9024" class="Comment">-- _%=_⊢_ : ∀ n → (C → D) → (A₁ → ⋯ Aₙ → D → B) → A₁ → ⋯ → Aₙ → C → B</a>

<a id="9095" class="Comment">-- Traditional composition (also known as the index update operator `_⊢_`</a>
<a id="9169" class="Comment">-- in `Relation.Unary`) focuses solely on the first argument of an n-ary</a>
<a id="9242" class="Comment">-- function. `_%=_⊢_` on the other hand allows us to touch any one of the</a>
<a id="9316" class="Comment">-- arguments.</a>

<a id="9331" class="Comment">-- In the following example we have a function `f : A → B` and `replicate`</a>
<a id="9406" class="Comment">-- of type `ℕ → B → List B`. We want ̀f` to act on the second argument of</a>
<a id="9480" class="Comment">-- replicate. Which we can do like so.</a>

<a id="compose₁"></a><a id="9520" href="README.Nary.html#9520" class="Function">compose₁</a> <a id="9529" class="Symbol">:</a> <a id="9531" class="Symbol">(</a><a id="9532" href="README.Nary.html#827" class="Generalizable">A</a> <a id="9534" class="Symbol">→</a> <a id="9536" href="README.Nary.html#841" class="Generalizable">B</a><a id="9537" class="Symbol">)</a> <a id="9539" class="Symbol">→</a> <a id="9541" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="9543" class="Symbol">→</a> <a id="9545" href="README.Nary.html#827" class="Generalizable">A</a> <a id="9547" class="Symbol">→</a> <a id="9549" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="9554" href="README.Nary.html#841" class="Generalizable">B</a>
<a id="9556" href="README.Nary.html#9520" class="Function">compose₁</a> <a id="9565" href="README.Nary.html#9565" class="Bound">f</a> <a id="9567" class="Symbol">=</a> <a id="9569" class="Number">1</a> <a id="9571" href="Function.Nary.NonDependent.Base.html#3868" class="Function Operator">%=</a> <a id="9574" href="README.Nary.html#9565" class="Bound">f</a> <a id="9576" href="Function.Nary.NonDependent.Base.html#3868" class="Function Operator">⊢</a> <a id="9578" href="Data.List.Base.html#5347" class="Function">replicate</a>

<a id="9589" class="Comment">-- Here we spell out the equivalent explicit variable-manipulation and</a>
<a id="9660" class="Comment">-- prove the two functions equal.</a>

<a id="compose₁′"></a><a id="9695" href="README.Nary.html#9695" class="Function">compose₁′</a> <a id="9705" class="Symbol">:</a> <a id="9707" class="Symbol">(</a><a id="9708" href="README.Nary.html#827" class="Generalizable">A</a> <a id="9710" class="Symbol">→</a> <a id="9712" href="README.Nary.html#841" class="Generalizable">B</a><a id="9713" class="Symbol">)</a> <a id="9715" class="Symbol">→</a> <a id="9717" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="9719" class="Symbol">→</a> <a id="9721" href="README.Nary.html#827" class="Generalizable">A</a> <a id="9723" class="Symbol">→</a> <a id="9725" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="9730" href="README.Nary.html#841" class="Generalizable">B</a>
<a id="9732" href="README.Nary.html#9695" class="Function">compose₁′</a> <a id="9742" href="README.Nary.html#9742" class="Bound">f</a> <a id="9744" href="README.Nary.html#9744" class="Bound">n</a> <a id="9746" href="README.Nary.html#9746" class="Bound">a</a> <a id="9748" class="Symbol">=</a> <a id="9750" href="Data.List.Base.html#5347" class="Function">replicate</a> <a id="9760" href="README.Nary.html#9744" class="Bound">n</a> <a id="9762" class="Symbol">(</a><a id="9763" href="README.Nary.html#9742" class="Bound">f</a> <a id="9765" href="README.Nary.html#9746" class="Bound">a</a><a id="9766" class="Symbol">)</a>

<a id="compose₁-eq"></a><a id="9769" href="README.Nary.html#9769" class="Function">compose₁-eq</a> <a id="9781" class="Symbol">:</a> <a id="9783" href="README.Nary.html#9520" class="Function">compose₁</a> <a id="9792" class="Symbol">{</a><a id="9793" href="README.Nary.html#805" class="Generalizable">a</a><a id="9794" class="Symbol">}</a> <a id="9796" class="Symbol">{</a><a id="9797" href="README.Nary.html#827" class="Generalizable">A</a><a id="9798" class="Symbol">}</a> <a id="9800" class="Symbol">{</a><a id="9801" href="README.Nary.html#807" class="Generalizable">b</a><a id="9802" class="Symbol">}</a> <a id="9804" class="Symbol">{</a><a id="9805" href="README.Nary.html#841" class="Generalizable">B</a><a id="9806" class="Symbol">}</a> <a id="9808" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="9810" href="README.Nary.html#9695" class="Function">compose₁′</a>
<a id="9820" href="README.Nary.html#9769" class="Function">compose₁-eq</a> <a id="9832" class="Symbol">=</a> <a id="9834" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="9840" class="Comment">-----------------------------------------------------------------------</a>
<a id="9912" class="Comment">-- _∷=_⊢_ : ∀ n → A → (A₁ → ⋯ Aₙ → A → B) → A₁ → ⋯ → Aₙ → B</a>

<a id="9973" class="Comment">-- Partial application usually focuses on the first argument of a function.</a>
<a id="10049" class="Comment">-- We can now partially apply a function in any of its arguments using</a>
<a id="10120" class="Comment">-- `_∷=_⊢_`. Reusing our example involving replicate: we can specialise it</a>
<a id="10195" class="Comment">-- to only output finite lists of `0`:</a>

<a id="apply₁"></a><a id="10235" href="README.Nary.html#10235" class="Function">apply₁</a> <a id="10242" class="Symbol">:</a> <a id="10244" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="10246" class="Symbol">→</a> <a id="10248" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="10253" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="10255" href="README.Nary.html#10235" class="Function">apply₁</a> <a id="10262" class="Symbol">=</a> <a id="10264" class="Number">1</a> <a id="10266" href="Function.Nary.NonDependent.Base.html#4040" class="Function Operator">∷=</a> <a id="10269" class="Number">0</a> <a id="10271" href="Function.Nary.NonDependent.Base.html#4040" class="Function Operator">⊢</a> <a id="10273" href="Data.List.Base.html#5347" class="Function">replicate</a>

<a id="apply₁-eq"></a><a id="10284" href="README.Nary.html#10284" class="Function">apply₁-eq</a> <a id="10294" class="Symbol">:</a> <a id="10296" href="README.Nary.html#10235" class="Function">apply₁</a> <a id="10303" class="Number">3</a> <a id="10305" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="10307" class="Number">0</a> <a id="10309" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10311" class="Number">0</a> <a id="10313" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10315" class="Number">0</a> <a id="10317" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10319" class="InductiveConstructor">[]</a>
<a id="10322" href="README.Nary.html#10284" class="Function">apply₁-eq</a> <a id="10332" class="Symbol">=</a> <a id="10334" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="10340" class="Comment">------------------------------------------------------------------------</a>
<a id="10413" class="Comment">-- holeₙ : ∀ n → (A → (A₁ → ⋯ Aₙ → B)) → A₁ → ⋯ → Aₙ → (A → B)</a>

<a id="10477" class="Comment">-- As we have seen earlier, `cong` acts on a function&#39;s first variable.</a>
<a id="10549" class="Comment">-- If we want to access the second one, we can use `flip`. But what about</a>
<a id="10623" class="Comment">-- the fourth one? We typically use an explicit λ-abstraction shuffling</a>
<a id="10695" class="Comment">-- variables. Not anymore.</a>

<a id="10723" class="Comment">-- Reusing mod-helper just because it takes a lot of arguments:</a>

<a id="hole₁"></a><a id="10788" href="README.Nary.html#10788" class="Function">hole₁</a> <a id="10794" class="Symbol">:</a> <a id="10796" class="Symbol">∀</a> <a id="10798" href="README.Nary.html#10798" class="Bound">k</a> <a id="10800" href="README.Nary.html#10800" class="Bound">m</a> <a id="10802" href="README.Nary.html#10802" class="Bound">n</a> <a id="10804" href="README.Nary.html#10804" class="Bound">j</a> <a id="10806" class="Symbol">→</a> <a id="10808" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10819" href="README.Nary.html#10798" class="Bound">k</a> <a id="10821" class="Symbol">(</a><a id="10822" href="README.Nary.html#10800" class="Bound">m</a> <a id="10824" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="10826" class="Number">1</a><a id="10827" class="Symbol">)</a> <a id="10829" href="README.Nary.html#10802" class="Bound">n</a> <a id="10831" href="README.Nary.html#10804" class="Bound">j</a> <a id="10833" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="10835" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10846" href="README.Nary.html#10798" class="Bound">k</a> <a id="10848" class="Symbol">(</a><a id="10849" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="10853" href="README.Nary.html#10800" class="Bound">m</a><a id="10854" class="Symbol">)</a> <a id="10856" href="README.Nary.html#10802" class="Bound">n</a> <a id="10858" href="README.Nary.html#10804" class="Bound">j</a>
<a id="10860" href="README.Nary.html#10788" class="Function">hole₁</a> <a id="10866" class="Symbol">=</a> <a id="10868" class="Symbol">λ</a> <a id="10870" href="README.Nary.html#10870" class="Bound">k</a> <a id="10872" href="README.Nary.html#10872" class="Bound">m</a> <a id="10874" href="README.Nary.html#10874" class="Bound">n</a> <a id="10876" href="README.Nary.html#10876" class="Bound">j</a> <a id="10878" class="Symbol">→</a> <a id="10880" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="10885" class="Symbol">(</a><a id="10886" href="Function.Nary.NonDependent.Base.html#4164" class="Function">holeₙ</a> <a id="10892" class="Number">2</a> <a id="10894" class="Symbol">(</a><a id="10895" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10906" href="README.Nary.html#10870" class="Bound">k</a><a id="10907" class="Symbol">)</a> <a id="10909" href="README.Nary.html#10874" class="Bound">n</a> <a id="10911" href="README.Nary.html#10876" class="Bound">j</a><a id="10912" class="Symbol">)</a> <a id="10914" class="Symbol">(</a><a id="10915" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="10922" href="README.Nary.html#10872" class="Bound">m</a> <a id="10924" class="Number">1</a><a id="10925" class="Symbol">)</a>

<a id="10928" class="Comment">-----------------------------------------------------------------------</a>
<a id="11000" class="Comment">-- mapₙ : ∀ n → (B → C) → (A₁ → ⋯ Aₙ → B) → (A₁ → ⋯ → Aₙ → C)</a>

<a id="11063" class="Comment">-- (R →_) gives us the reader monad (and, a fortiori, functor). That is to</a>
<a id="11138" class="Comment">-- say that given a function (A → B) and an (R → A) we can get an (R → B)</a>
<a id="11212" class="Comment">-- This generalises to n-ary functions.</a>

<a id="11253" class="Comment">-- Reusing our `composeₙ` example: instead of applying `f` to the replicated</a>
<a id="11330" class="Comment">-- element, we can map it on the resulting list. Giving us:</a>

<a id="map₁"></a><a id="11391" href="README.Nary.html#11391" class="Function">map₁</a> <a id="11396" class="Symbol">:</a> <a id="11398" class="Symbol">(</a><a id="11399" href="README.Nary.html#827" class="Generalizable">A</a> <a id="11401" class="Symbol">→</a> <a id="11403" href="README.Nary.html#841" class="Generalizable">B</a><a id="11404" class="Symbol">)</a> <a id="11406" class="Symbol">→</a> <a id="11408" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="11410" class="Symbol">→</a> <a id="11412" href="README.Nary.html#827" class="Generalizable">A</a> <a id="11414" class="Symbol">→</a> <a id="11416" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="11421" href="README.Nary.html#841" class="Generalizable">B</a>
<a id="11423" href="README.Nary.html#11391" class="Function">map₁</a> <a id="11428" href="README.Nary.html#11428" class="Bound">f</a> <a id="11430" class="Symbol">=</a> <a id="11432" href="Function.Nary.NonDependent.Base.html#3692" class="Function">mapₙ</a> <a id="11437" class="Number">2</a> <a id="11439" class="Symbol">(</a><a id="11440" href="Data.List.Base.html#1620" class="Function">map</a> <a id="11444" href="README.Nary.html#11428" class="Bound">f</a><a id="11445" class="Symbol">)</a> <a id="11447" href="Data.List.Base.html#5347" class="Function">replicate</a>

<a id="11458" class="Comment">------------------------------------------------------------------------</a>
<a id="11531" class="Comment">-- constₙ : ∀ n → B → A₁ → ⋯ → Aₙ → B</a>

<a id="11570" class="Comment">-- `const` is basically `pure` for the reader monad discussed above. Just</a>
<a id="11644" class="Comment">-- like we can generalise the functorial action corresponding to the reader</a>
<a id="11720" class="Comment">-- functor to n-ary functions, we can do the same for `pure`.</a>

<a id="const₁"></a><a id="11783" href="README.Nary.html#11783" class="Function">const₁</a> <a id="11790" class="Symbol">:</a> <a id="11792" href="README.Nary.html#827" class="Generalizable">A</a> <a id="11794" class="Symbol">→</a> <a id="11796" href="README.Nary.html#841" class="Generalizable">B</a> <a id="11798" class="Symbol">→</a> <a id="11800" href="README.Nary.html#855" class="Generalizable">C</a> <a id="11802" class="Symbol">→</a> <a id="11804" href="README.Nary.html#869" class="Generalizable">D</a> <a id="11806" class="Symbol">→</a> <a id="11808" href="README.Nary.html#883" class="Generalizable">E</a> <a id="11810" class="Symbol">→</a> <a id="11812" href="README.Nary.html#827" class="Generalizable">A</a>
<a id="11814" href="README.Nary.html#11783" class="Function">const₁</a> <a id="11821" class="Symbol">=</a> <a id="11823" href="Function.Nary.NonDependent.Base.html#4546" class="Function">constₙ</a> <a id="11830" class="Number">4</a>

<a id="11833" class="Comment">-- Together with `holeₙ`, this means we can make a constant function out</a>
<a id="11906" class="Comment">-- of any of the arguments. The fourth for instance:</a>

<a id="const₂"></a><a id="11960" href="README.Nary.html#11960" class="Function">const₂</a> <a id="11967" class="Symbol">:</a> <a id="11969" href="README.Nary.html#827" class="Generalizable">A</a> <a id="11971" class="Symbol">→</a> <a id="11973" href="README.Nary.html#841" class="Generalizable">B</a> <a id="11975" class="Symbol">→</a> <a id="11977" href="README.Nary.html#855" class="Generalizable">C</a> <a id="11979" class="Symbol">→</a> <a id="11981" href="README.Nary.html#869" class="Generalizable">D</a> <a id="11983" class="Symbol">→</a> <a id="11985" href="README.Nary.html#883" class="Generalizable">E</a> <a id="11987" class="Symbol">→</a> <a id="11989" href="README.Nary.html#869" class="Generalizable">D</a>
<a id="11991" href="README.Nary.html#11960" class="Function">const₂</a> <a id="11998" class="Symbol">=</a> <a id="12000" href="Function.Nary.NonDependent.Base.html#4164" class="Function">holeₙ</a> <a id="12006" class="Number">3</a> <a id="12008" class="Symbol">(</a><a id="12009" href="Function.Nary.NonDependent.Base.html#4546" class="Function">constₙ</a> <a id="12016" class="Number">4</a><a id="12017" class="Symbol">)</a>

<a id="12020" class="Comment">------------------------------------------------------------------------</a>
<a id="12093" class="Comment">-- Generalised quantifiers</a>
<a id="12120" class="Comment">------------------------------------------------------------------------</a>

<a id="12194" class="Comment">-- As we have seen multiple times already, one of the advantages of working</a>
<a id="12270" class="Comment">-- with non-dependent products is that they can be easily inferred. This is</a>
<a id="12346" class="Comment">-- a prime opportunity to define generic quantifiers.</a>

<a id="12401" class="Comment">-- And because n-ary relations are Set-terminated, there is no ambiguity</a>
<a id="12474" class="Comment">-- where to split between arguments &amp; codomain. As a consequence Agda can</a>
<a id="12548" class="Comment">-- infer even `n`, the number of arguments. We can use notations which are</a>
<a id="12623" class="Comment">-- just like the ones defined in `Relation.Unary`.</a>

<a id="12675" class="Comment">------------------------------------------------------------------------</a>
<a id="12748" class="Comment">-- ∃⟨_⟩ : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="12788" class="Comment">-- ∃⟨ P ⟩ = ∃ λ a₁ → ⋯ → ∃ λ aₙ → P a₁ ⋯ aₙ</a>

<a id="12833" class="Comment">-- Returning to our favourite function taking a lot of arguments: we can</a>
<a id="12906" class="Comment">-- find a set of input for which it evaluates to 666</a>

<a id="exist₁"></a><a id="12960" href="README.Nary.html#12960" class="Function">exist₁</a> <a id="12967" class="Symbol">:</a> <a id="12969" href="Relation.Nary.html#2375" class="Function Operator">∃⟨</a> <a id="12972" class="Symbol">(λ</a> <a id="12975" href="README.Nary.html#12975" class="Bound">k</a> <a id="12977" href="README.Nary.html#12977" class="Bound">m</a> <a id="12979" href="README.Nary.html#12979" class="Bound">n</a> <a id="12981" href="README.Nary.html#12981" class="Bound">j</a> <a id="12983" class="Symbol">→</a> <a id="12985" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="12996" href="README.Nary.html#12975" class="Bound">k</a> <a id="12998" href="README.Nary.html#12977" class="Bound">m</a> <a id="13000" href="README.Nary.html#12979" class="Bound">n</a> <a id="13002" href="README.Nary.html#12981" class="Bound">j</a> <a id="13004" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13006" class="Number">666</a><a id="13009" class="Symbol">)</a> <a id="13011" href="Relation.Nary.html#2375" class="Function Operator">⟩</a>
<a id="13013" href="README.Nary.html#12960" class="Function">exist₁</a> <a id="13020" class="Symbol">=</a> <a id="13022" class="Number">19</a> <a id="13025" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13027" class="Number">793</a> <a id="13031" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13033" class="Number">3059</a> <a id="13038" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13040" class="Number">10</a> <a id="13043" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13045" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="13051" class="Comment">------------------------------------------------------------------------</a>
<a id="13124" class="Comment">-- ∀[_] : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13164" class="Comment">-- ∀[_] P = ∀ {a₁} → ⋯ → ∀ {aₙ} → P a₁ ⋯ aₙ</a>

<a id="all₁"></a><a id="13209" href="README.Nary.html#13209" class="Function">all₁</a> <a id="13214" class="Symbol">:</a> <a id="13216" href="Relation.Nary.html#2651" class="Function Operator">∀[</a> <a id="13219" class="Symbol">(λ</a> <a id="13222" class="Symbol">(</a><a id="13223" href="README.Nary.html#13223" class="Bound">a₁</a> <a id="13226" href="README.Nary.html#13226" class="Bound">a₂</a> <a id="13229" class="Symbol">:</a> <a id="13231" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13232" class="Symbol">)</a> <a id="13234" class="Symbol">→</a> <a id="13236" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="13240" class="Symbol">(</a><a id="13241" href="README.Nary.html#13223" class="Bound">a₁</a> <a id="13244" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13246" href="README.Nary.html#13226" class="Bound">a₂</a><a id="13248" class="Symbol">))</a> <a id="13251" href="Relation.Nary.html#2651" class="Function Operator">]</a>
<a id="13253" href="README.Nary.html#13209" class="Function">all₁</a> <a id="13258" class="Symbol">{</a><a id="13259" href="README.Nary.html#13259" class="Bound">a₁</a><a id="13261" class="Symbol">}</a> <a id="13263" class="Symbol">{</a><a id="13264" href="README.Nary.html#13264" class="Bound">a₂</a><a id="13266" class="Symbol">}</a> <a id="13268" class="Symbol">=</a> <a id="13270" href="README.Nary.html#13259" class="Bound">a₁</a> <a id="13273" href="Data.Nat.Properties.html#2947" class="Function Operator">≟</a> <a id="13275" href="README.Nary.html#13264" class="Bound">a₂</a>

<a id="13279" class="Comment">------------------------------------------------------------------------</a>
<a id="13352" class="Comment">-- Π : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13389" class="Comment">-- Π P = ∀ a₁ → ⋯ → ∀ aₙ → P a₁ ⋯ aₙ</a>

<a id="all₂"></a><a id="13427" href="README.Nary.html#13427" class="Function">all₂</a> <a id="13432" class="Symbol">:</a> <a id="13434" href="Relation.Nary.html#2514" class="Function Operator">Π[</a> <a id="13437" class="Symbol">(λ</a> <a id="13440" class="Symbol">(</a><a id="13441" href="README.Nary.html#13441" class="Bound">a₁</a> <a id="13444" href="README.Nary.html#13444" class="Bound">a₂</a> <a id="13447" class="Symbol">:</a> <a id="13449" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13450" class="Symbol">)</a> <a id="13452" class="Symbol">→</a> <a id="13454" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="13458" class="Symbol">(</a><a id="13459" href="README.Nary.html#13441" class="Bound">a₁</a> <a id="13462" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13464" href="README.Nary.html#13444" class="Bound">a₂</a><a id="13466" class="Symbol">))</a> <a id="13469" href="Relation.Nary.html#2514" class="Function Operator">]</a>
<a id="13471" href="README.Nary.html#13427" class="Function">all₂</a> <a id="13476" class="Symbol">=</a> <a id="13478" href="Data.Nat.Properties.html#2947" class="Function Operator">_≟_</a>

<a id="13483" class="Comment">------------------------------------------------------------------------</a>
<a id="13556" class="Comment">-- _⇒_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13635" class="Comment">-- P ⇒ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ → Q a₁ ⋯ aₙ</a>

<a id="antisym"></a><a id="13687" href="README.Nary.html#13687" class="Function">antisym</a> <a id="13695" class="Symbol">:</a> <a id="13697" href="Relation.Nary.html#2651" class="Function Operator">∀[</a> <a id="13700" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="13704" href="Relation.Nary.html#5050" class="Function Operator">⇒</a> <a id="13706" href="Data.Nat.Base.html#1903" class="Function Operator">_≥_</a> <a id="13710" href="Relation.Nary.html#5050" class="Function Operator">⇒</a> <a id="13712" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a> <a id="13716" href="Relation.Nary.html#2651" class="Function Operator">]</a>
<a id="13718" href="README.Nary.html#13687" class="Function">antisym</a> <a id="13726" class="Symbol">=</a> <a id="13728" href="Data.Nat.Properties.html#4980" class="Function">≤-antisym</a>

<a id="13739" class="Comment">------------------------------------------------------------------------</a>
<a id="13812" class="Comment">-- _∪_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13891" class="Comment">-- P ∪ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ ⊎ Q a₁ ⋯ aₙ</a>

<a id="≤-&gt;-connex"></a><a id="13943" href="README.Nary.html#13943" class="Function">≤-&gt;-connex</a> <a id="13954" class="Symbol">:</a> <a id="13956" href="Relation.Nary.html#2514" class="Function Operator">Π[</a> <a id="13959" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="13963" href="Relation.Nary.html#5340" class="Function Operator">∪</a> <a id="13965" href="Data.Nat.Base.html#1933" class="Function Operator">_&gt;_</a> <a id="13969" href="Relation.Nary.html#2514" class="Function Operator">]</a>
<a id="13971" href="README.Nary.html#13943" class="Function">≤-&gt;-connex</a> <a id="13982" href="README.Nary.html#13982" class="Bound">m</a> <a id="13984" href="README.Nary.html#13984" class="Bound">n</a> <a id="13986" class="Keyword">with</a> <a id="13991" href="Data.Nat.Properties.html#10339" class="Function">&lt;-cmp</a> <a id="13997" href="README.Nary.html#13982" class="Bound">m</a> <a id="13999" href="README.Nary.html#13984" class="Bound">n</a>
<a id="14001" class="Symbol">...</a> <a id="14005" class="Symbol">|</a> <a id="14007" href="Relation.Binary.Definitions.html#2857" class="InductiveConstructor">tri&lt;</a> <a id="14012" href="README.Nary.html#14012" class="Bound">a</a> <a id="14014" href="README.Nary.html#14014" class="Bound">¬b</a> <a id="14017" href="README.Nary.html#14017" class="Bound">¬c</a> <a id="14020" class="Symbol">=</a> <a id="14022" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="14027" class="Symbol">(</a><a id="14028" href="Data.Nat.Properties.html#8217" class="Function">&lt;⇒≤</a> <a id="14032" href="README.Nary.html#14012" class="Bound">a</a><a id="14033" class="Symbol">)</a>
<a id="14035" class="Symbol">...</a> <a id="14039" class="Symbol">|</a> <a id="14041" href="Relation.Binary.Definitions.html#2911" class="InductiveConstructor">tri≈</a> <a id="14046" href="README.Nary.html#14046" class="Bound">¬a</a> <a id="14049" href="README.Nary.html#14049" class="Bound">b</a> <a id="14051" href="README.Nary.html#14051" class="Bound">¬c</a> <a id="14054" class="Symbol">=</a> <a id="14056" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="14061" class="Symbol">(</a><a id="14062" href="Data.Nat.Properties.html#4824" class="Function">≤-reflexive</a> <a id="14074" href="README.Nary.html#14049" class="Bound">b</a><a id="14075" class="Symbol">)</a>
<a id="14077" class="Symbol">...</a> <a id="14081" class="Symbol">|</a> <a id="14083" href="Relation.Binary.Definitions.html#2965" class="InductiveConstructor">tri&gt;</a> <a id="14088" href="README.Nary.html#14088" class="Bound">¬a</a> <a id="14091" href="README.Nary.html#14091" class="Bound">¬b</a> <a id="14094" href="README.Nary.html#14094" class="Bound">c</a> <a id="14096" class="Symbol">=</a> <a id="14098" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="14103" href="README.Nary.html#14094" class="Bound">c</a>

<a id="14106" class="Comment">------------------------------------------------------------------------</a>
<a id="14179" class="Comment">-- _∩_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14258" class="Comment">-- P ∩ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ × Q a₁ ⋯ aₙ</a>

<a id="&lt;-inversion"></a><a id="14310" href="README.Nary.html#14310" class="Function">&lt;-inversion</a> <a id="14322" class="Symbol">:</a> <a id="14324" href="Relation.Nary.html#2651" class="Function Operator">∀[</a> <a id="14327" href="Data.Nat.Base.html#1654" class="Function Operator">_&lt;_</a> <a id="14331" href="Relation.Nary.html#5050" class="Function Operator">⇒</a> <a id="14333" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="14337" href="Relation.Nary.html#5201" class="Function Operator">∩</a> <a id="14339" href="Relation.Binary.PropositionalEquality.Core.html#858" class="Function Operator">_≢_</a> <a id="14343" href="Relation.Nary.html#2651" class="Function Operator">]</a>
<a id="14345" href="README.Nary.html#14310" class="Function">&lt;-inversion</a> <a id="14357" href="README.Nary.html#14357" class="Bound">m&lt;n</a> <a id="14361" class="Symbol">=</a> <a id="14363" href="Data.Nat.Properties.html#8217" class="Function">&lt;⇒≤</a> <a id="14367" href="README.Nary.html#14357" class="Bound">m&lt;n</a> <a id="14371" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="14373" href="Data.Nat.Properties.html#8300" class="Function">&lt;⇒≢</a> <a id="14377" href="README.Nary.html#14357" class="Bound">m&lt;n</a>

<a id="14382" class="Comment">------------------------------------------------------------------------</a>
<a id="14455" class="Comment">-- ∁ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14508" class="Comment">-- ∁ P = λ a₁ → ⋯ → λ aₙ → ¬ (P a₁ ⋯ aₙ)</a>

<a id="m&lt;n⇒m≱n"></a><a id="14550" href="README.Nary.html#14550" class="Function">m&lt;n⇒m≱n</a> <a id="14558" class="Symbol">:</a> <a id="14560" href="Relation.Nary.html#2651" class="Function Operator">∀[</a> <a id="14563" href="Data.Nat.Base.html#1933" class="Function Operator">_&gt;_</a> <a id="14567" href="Relation.Nary.html#5050" class="Function Operator">⇒</a> <a id="14569" href="Relation.Nary.html#5463" class="Function">∁</a> <a id="14571" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="14575" href="Relation.Nary.html#2651" class="Function Operator">]</a>
<a id="14577" href="README.Nary.html#14550" class="Function">m&lt;n⇒m≱n</a> <a id="14585" href="README.Nary.html#14585" class="Bound">m&gt;n</a> <a id="14589" href="README.Nary.html#14589" class="Bound">m≤n</a> <a id="14593" class="Symbol">=</a> <a id="14595" href="Data.Nat.Properties.html#8432" class="Function">&lt;⇒≱</a> <a id="14599" href="README.Nary.html#14585" class="Bound">m&gt;n</a> <a id="14603" href="README.Nary.html#14589" class="Bound">m≤n</a>
</pre></body></html>