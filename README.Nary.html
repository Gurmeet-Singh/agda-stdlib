<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Nary</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the generic n-ary operations the stdlib provides</a>
<a id="179" class="Comment">-- can be used</a>
<a id="194" class="Comment">------------------------------------------------------------------------</a>

<a id="268" class="Symbol">{-#</a> <a id="272" class="Keyword">OPTIONS</a> <a id="280" class="Pragma">--cubical-compatible</a> <a id="301" class="Pragma">--safe</a> <a id="308" class="Symbol">#-}</a>

<a id="313" class="Keyword">module</a> <a id="320" href="README.Nary.html" class="Module">README.Nary</a> <a id="332" class="Keyword">where</a>

<a id="339" class="Keyword">open</a> <a id="344" class="Keyword">import</a> <a id="351" href="Level.html" class="Module">Level</a> <a id="357" class="Keyword">using</a> <a id="363" class="Symbol">(</a><a id="364" href="Agda.Primitive.html#591" class="Postulate">Level</a><a id="369" class="Symbol">)</a>
<a id="371" class="Keyword">open</a> <a id="376" class="Keyword">import</a> <a id="383" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="397" class="Keyword">open</a> <a id="402" class="Keyword">import</a> <a id="409" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="429" class="Keyword">open</a> <a id="434" class="Keyword">import</a> <a id="441" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="450" class="Keyword">using</a> <a id="456" class="Symbol">(</a><a id="457" href="Data.Fin.Base.html#1312" class="Datatype">Fin</a><a id="460" class="Symbol">;</a> <a id="462" href="Data.Fin.Base.html#2005" class="Function">fromℕ</a><a id="467" class="Symbol">;</a> <a id="469" href="Data.Fin.html#739" class="Function Operator">#_</a><a id="471" class="Symbol">;</a> <a id="473" href="Data.Fin.Base.html#3276" class="Function">inject₁</a><a id="480" class="Symbol">)</a>
<a id="482" class="Keyword">open</a> <a id="487" class="Keyword">import</a> <a id="494" href="Data.List.html" class="Module">Data.List</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Data.List.Properties.html" class="Module">Data.List.Properties</a>
<a id="537" class="Keyword">open</a> <a id="542" class="Keyword">import</a> <a id="549" href="Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="567" class="Keyword">using</a> <a id="573" class="Symbol">(</a><a id="574" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="577" class="Symbol">;</a> <a id="579" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="582" class="Symbol">)</a>
<a id="584" class="Keyword">open</a> <a id="589" class="Keyword">import</a> <a id="596" href="Data.Sum.Base.html" class="Module">Data.Sum.Base</a> <a id="610" class="Keyword">using</a> <a id="616" class="Symbol">(</a><a id="617" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a><a id="621" class="Symbol">;</a> <a id="623" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a><a id="627" class="Symbol">)</a>
<a id="629" class="Keyword">open</a> <a id="634" class="Keyword">import</a> <a id="641" href="Function.Base.html" class="Module">Function.Base</a> <a id="655" class="Keyword">using</a> <a id="661" class="Symbol">(</a><a id="662" href="Function.Base.html#704" class="Function">id</a><a id="664" class="Symbol">;</a> <a id="666" href="Function.Base.html#1638" class="Function">flip</a><a id="670" class="Symbol">;</a> <a id="672" href="Function.Base.html#3646" class="Function Operator">_∘′_</a><a id="676" class="Symbol">)</a>
<a id="678" class="Keyword">open</a> <a id="683" class="Keyword">import</a> <a id="690" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="707" class="Keyword">open</a> <a id="712" class="Keyword">import</a> <a id="719" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="735" class="Keyword">using</a> <a id="741" class="Symbol">(</a><a id="742" class="Keyword">module</a> <a id="749" href="Relation.Binary.Definitions.html#2791" class="Module">Tri</a><a id="752" class="Symbol">);</a> <a id="755" class="Keyword">open</a> <a id="760" href="Relation.Binary.Definitions.html#2791" class="Module">Tri</a>
<a id="764" class="Keyword">open</a> <a id="769" class="Keyword">import</a> <a id="776" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="815" class="Keyword">private</a>
  <a id="825" class="Keyword">variable</a>
    <a id="838" href="README.Nary.html#838" class="Generalizable">a</a> <a id="840" href="README.Nary.html#840" class="Generalizable">b</a> <a id="842" href="README.Nary.html#842" class="Generalizable">c</a> <a id="844" href="README.Nary.html#844" class="Generalizable">d</a> <a id="846" href="README.Nary.html#846" class="Generalizable">e</a> <a id="848" class="Symbol">:</a> <a id="850" href="Agda.Primitive.html#591" class="Postulate">Level</a>
    <a id="860" href="README.Nary.html#860" class="Generalizable">A</a> <a id="862" class="Symbol">:</a> <a id="864" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="868" href="README.Nary.html#838" class="Generalizable">a</a>
    <a id="874" href="README.Nary.html#874" class="Generalizable">B</a> <a id="876" class="Symbol">:</a> <a id="878" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="882" href="README.Nary.html#840" class="Generalizable">b</a>
    <a id="888" href="README.Nary.html#888" class="Generalizable">C</a> <a id="890" class="Symbol">:</a> <a id="892" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="896" href="README.Nary.html#842" class="Generalizable">c</a>
    <a id="902" href="README.Nary.html#902" class="Generalizable">D</a> <a id="904" class="Symbol">:</a> <a id="906" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="910" href="README.Nary.html#844" class="Generalizable">d</a>
    <a id="916" href="README.Nary.html#916" class="Generalizable">E</a> <a id="918" class="Symbol">:</a> <a id="920" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="924" href="README.Nary.html#846" class="Generalizable">e</a>

<a id="927" class="Comment">------------------------------------------------------------------------</a>
<a id="1000" class="Comment">-- Introduction</a>
<a id="1016" class="Comment">------------------------------------------------------------------------</a>

<a id="1090" class="Comment">-- Function.Nary.NonDependent and Data.Product.N-ary.Heterogeneous provide</a>
<a id="1165" class="Comment">-- a generic representation of n-ary heterogeneous (non dependent) products</a>
<a id="1241" class="Comment">-- and the corresponding types of (non-dependent) n-ary functions. The</a>
<a id="1312" class="Comment">-- representation works well with inference thus allowing us to use generic</a>
<a id="1388" class="Comment">-- combinators to manipulate such functions.</a>

<a id="1434" class="Keyword">open</a> <a id="1439" class="Keyword">import</a> <a id="1446" href="Data.Product.Nary.NonDependent.html" class="Module">Data.Product.Nary.NonDependent</a>
<a id="1477" class="Keyword">open</a> <a id="1482" class="Keyword">import</a> <a id="1489" href="Function.Nary.NonDependent.html" class="Module">Function.Nary.NonDependent</a>
<a id="1516" class="Keyword">open</a> <a id="1521" class="Keyword">import</a> <a id="1528" href="Relation.Nary.html" class="Module">Relation.Nary</a>


<a id="1544" class="Comment">------------------------------------------------------------------------</a>
<a id="1617" class="Comment">-- Generalised equality-manipulating combinators</a>
<a id="1666" class="Comment">------------------------------------------------------------------------</a>

<a id="1740" class="Comment">-- By default the standard library provides users with (we are leaving out</a>
<a id="1815" class="Comment">-- the implicit arguments here):</a>
<a id="1848" class="Comment">--</a>
<a id="1851" class="Comment">-- cong   : (f : A₁      → B) → a₁ ≡ b₁           → f a₁   ≡ f b₁</a>
<a id="1917" class="Comment">-- cong₂  : (f : A₁ → A₂ → B) → a₁ ≡ b₁ → a₂ ≡ b₂ → f a₁ a₂ ≡ f b₁ b₂</a>
<a id="1987" class="Comment">--</a>
<a id="1990" class="Comment">-- and</a>
<a id="1997" class="Comment">--</a>
<a id="2000" class="Comment">-- subst  : (P : A₁      → Set p) → a₁ ≡ b₁           → P a₁    → P b₁</a>
<a id="2071" class="Comment">-- subst₂ : (P : A₁ → A₂ → Set p) → a₁ ≡ b₁ → a₂ ≡ b₂ → P a₁ a₂ → P b₁ b₂</a>
<a id="2145" class="Comment">--</a>
<a id="2148" class="Comment">-- This pattern can be generalised to any natural number `n`. Thanks to our</a>
<a id="2224" class="Comment">-- library for n-ary functions, we can write the types and implementations</a>
<a id="2299" class="Comment">-- of `congₙ` and `substₙ`.</a>

<a id="2328" class="Comment">------------------------------------------------------------------------</a>
<a id="2401" class="Comment">-- congₙ : ∀ n (f : A₁ → ⋯ → Aₙ → B) →</a>
<a id="2440" class="Comment">--         a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → f a₁ ⋯ aₙ ≡ f b₁ ⋯ bₙ</a>

<a id="2496" class="Comment">-- It may be used directly to prove something:</a>

<a id="2544" href="README.Nary.html#2544" class="Function">_</a> <a id="2546" class="Symbol">:</a> <a id="2548" class="Symbol">∀</a> <a id="2550" class="Symbol">(</a><a id="2551" href="README.Nary.html#2551" class="Bound">as</a> <a id="2554" href="README.Nary.html#2554" class="Bound">bs</a> <a id="2557" href="README.Nary.html#2557" class="Bound">cs</a> <a id="2560" class="Symbol">:</a> <a id="2562" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="2567" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2568" class="Symbol">)</a> <a id="2570" class="Symbol">→</a>
       <a id="2579" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2583" class="Symbol">(</a><a id="2584" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2588" class="Symbol">(</a><a id="2589" href="README.Nary.html#2551" class="Bound">as</a> <a id="2592" href="Data.List.Base.html#1943" class="Function Operator">++</a> <a id="2595" class="InductiveConstructor">[]</a><a id="2597" class="Symbol">)</a> <a id="2599" class="Symbol">(</a><a id="2600" href="Data.List.Base.html#1620" class="Function">map</a> <a id="2604" href="Function.Base.html#704" class="Function">id</a> <a id="2607" href="README.Nary.html#2557" class="Bound">cs</a><a id="2609" class="Symbol">))</a> <a id="2612" class="Symbol">(</a><a id="2613" href="Data.List.Base.html#7001" class="Function">reverse</a> <a id="2621" class="Symbol">(</a><a id="2622" href="Data.List.Base.html#7001" class="Function">reverse</a> <a id="2630" href="README.Nary.html#2554" class="Bound">bs</a><a id="2632" class="Symbol">))</a>
     <a id="2640" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2642" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2646" class="Symbol">(</a><a id="2647" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2651" href="README.Nary.html#2551" class="Bound">as</a> <a id="2654" href="README.Nary.html#2557" class="Bound">cs</a><a id="2656" class="Symbol">)</a> <a id="2658" href="README.Nary.html#2554" class="Bound">bs</a>
<a id="2661" class="Symbol">_</a> <a id="2663" class="Symbol">=</a> <a id="2665" class="Symbol">λ</a> <a id="2667" href="README.Nary.html#2667" class="Bound">as</a> <a id="2670" href="README.Nary.html#2670" class="Bound">bs</a> <a id="2673" href="README.Nary.html#2673" class="Bound">cs</a> <a id="2676" class="Symbol">→</a> <a id="2678" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="2684" class="Number">3</a> <a id="2686" class="Symbol">(λ</a> <a id="2689" href="README.Nary.html#2689" class="Bound">as</a> <a id="2692" href="README.Nary.html#2692" class="Bound">bs</a> <a id="2695" class="Symbol">→</a> <a id="2697" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2701" class="Symbol">(</a><a id="2702" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2706" href="README.Nary.html#2689" class="Bound">as</a> <a id="2709" href="README.Nary.html#2692" class="Bound">bs</a><a id="2711" class="Symbol">))</a>
                         <a id="2739" class="Symbol">(</a><a id="2740" href="Data.List.Properties.html#5894" class="Function">++-identityʳ</a> <a id="2753" href="README.Nary.html#2667" class="Bound">as</a><a id="2755" class="Symbol">)</a>
                         <a id="2782" class="Symbol">(</a><a id="2783" href="Data.List.Properties.html#3149" class="Function">map-id</a> <a id="2790" href="README.Nary.html#2673" class="Bound">cs</a><a id="2792" class="Symbol">)</a>
                         <a id="2819" class="Symbol">(</a><a id="2820" href="Data.List.Properties.html#39951" class="Function">reverse-involutive</a> <a id="2839" href="README.Nary.html#2670" class="Bound">bs</a><a id="2841" class="Symbol">)</a>

<a id="2844" class="Comment">-- Or as part of a longer derivation:</a>

<a id="2883" href="README.Nary.html#2883" class="Function">_</a> <a id="2885" class="Symbol">:</a> <a id="2887" class="Symbol">∀</a> <a id="2889" href="README.Nary.html#2889" class="Bound">m</a> <a id="2891" href="README.Nary.html#2891" class="Bound">n</a> <a id="2893" href="README.Nary.html#2893" class="Bound">p</a> <a id="2895" href="README.Nary.html#2895" class="Bound">q</a> <a id="2897" class="Symbol">→</a> <a id="2899" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2903" class="Symbol">(</a><a id="2904" href="README.Nary.html#2889" class="Bound">m</a> <a id="2906" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2908" class="Symbol">(</a><a id="2909" href="README.Nary.html#2893" class="Bound">p</a> <a id="2911" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2913" href="README.Nary.html#2891" class="Bound">n</a><a id="2914" class="Symbol">)</a> <a id="2916" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2918" class="Symbol">(</a><a id="2919" href="README.Nary.html#2895" class="Bound">q</a> <a id="2921" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="2923" class="Symbol">(</a><a id="2924" href="README.Nary.html#2889" class="Bound">m</a> <a id="2926" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2928" href="README.Nary.html#2891" class="Bound">n</a><a id="2929" class="Symbol">)))</a>
              <a id="2947" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2949" class="Symbol">(</a><a id="2950" href="README.Nary.html#2889" class="Bound">m</a> <a id="2952" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2954" class="Number">0</a><a id="2955" class="Symbol">)</a> <a id="2957" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2959" class="Symbol">(</a><a id="2960" href="README.Nary.html#2891" class="Bound">n</a> <a id="2962" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2964" href="README.Nary.html#2893" class="Bound">p</a><a id="2965" class="Symbol">)</a> <a id="2967" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2969" class="Symbol">(</a><a id="2970" href="README.Nary.html#2895" class="Bound">q</a> <a id="2972" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="2974" href="README.Nary.html#2889" class="Bound">m</a> <a id="2976" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2978" href="README.Nary.html#2895" class="Bound">q</a> <a id="2980" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="2982" href="README.Nary.html#2891" class="Bound">n</a><a id="2983" class="Symbol">)</a> <a id="2985" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2987" class="Number">1</a>
<a id="2989" class="Symbol">_</a> <a id="2991" class="Symbol">=</a> <a id="2993" class="Symbol">λ</a> <a id="2995" href="README.Nary.html#2995" class="Bound">m</a> <a id="2997" href="README.Nary.html#2997" class="Bound">n</a> <a id="2999" href="README.Nary.html#2999" class="Bound">p</a> <a id="3001" href="README.Nary.html#3001" class="Bound">q</a> <a id="3003" class="Symbol">→</a> <a id="3005" href="Relation.Binary.PropositionalEquality.Core.html#2834" class="Function Operator">begin</a>
    <a id="3015" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="3019" class="Symbol">(</a><a id="3020" href="README.Nary.html#2995" class="Bound">m</a> <a id="3022" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3024" class="Symbol">(</a><a id="3025" href="README.Nary.html#2999" class="Bound">p</a> <a id="3027" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3029" href="README.Nary.html#2997" class="Bound">n</a><a id="3030" class="Symbol">)</a> <a id="3032" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3034" class="Symbol">(</a><a id="3035" href="README.Nary.html#3001" class="Bound">q</a> <a id="3037" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3039" class="Symbol">(</a><a id="3040" href="README.Nary.html#2995" class="Bound">m</a> <a id="3042" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3044" href="README.Nary.html#2997" class="Bound">n</a><a id="3045" class="Symbol">)))</a> <a id="3049" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">≡⟨</a> <a id="3052" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="3059" class="Number">1</a> <a id="3061" class="Symbol">_</a> <a id="3063" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">⟩</a>
    <a id="3069" href="README.Nary.html#2995" class="Bound">m</a> <a id="3071" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3073" class="Symbol">(</a><a id="3074" href="README.Nary.html#2999" class="Bound">p</a> <a id="3076" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3078" href="README.Nary.html#2997" class="Bound">n</a><a id="3079" class="Symbol">)</a> <a id="3081" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3083" class="Symbol">(</a><a id="3084" href="README.Nary.html#3001" class="Bound">q</a> <a id="3086" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3088" class="Symbol">(</a><a id="3089" href="README.Nary.html#2995" class="Bound">m</a> <a id="3091" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3093" href="README.Nary.html#2997" class="Bound">n</a><a id="3094" class="Symbol">))</a> <a id="3097" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3099" class="Number">1</a>   <a id="3103" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">≡⟨</a> <a id="3106" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="3112" class="Number">3</a> <a id="3114" class="Symbol">(λ</a> <a id="3117" href="README.Nary.html#3117" class="Bound">m</a> <a id="3119" href="README.Nary.html#3119" class="Bound">n</a> <a id="3121" href="README.Nary.html#3121" class="Bound">p</a> <a id="3123" class="Symbol">→</a> <a id="3125" href="README.Nary.html#3117" class="Bound">m</a> <a id="3127" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3129" href="README.Nary.html#3119" class="Bound">n</a> <a id="3131" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3133" href="README.Nary.html#3121" class="Bound">p</a> <a id="3135" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3137" class="Number">1</a><a id="3138" class="Symbol">)</a>
                                                 <a id="3189" class="Symbol">(</a><a id="3190" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="3197" class="Number">0</a> <a id="3199" href="README.Nary.html#2995" class="Bound">m</a><a id="3200" class="Symbol">)</a>
                                                 <a id="3251" class="Symbol">(</a><a id="3252" href="Data.Nat.Properties.html#21339" class="Function">*-comm</a> <a id="3259" href="README.Nary.html#2999" class="Bound">p</a> <a id="3261" href="README.Nary.html#2997" class="Bound">n</a><a id="3262" class="Symbol">)</a>
                                                 <a id="3313" class="Symbol">(</a><a id="3314" href="Data.Nat.Properties.html#28849" class="Function">^-distribˡ-+-*</a> <a id="3329" href="README.Nary.html#3001" class="Bound">q</a> <a id="3331" href="README.Nary.html#2995" class="Bound">m</a> <a id="3333" href="README.Nary.html#2997" class="Bound">n</a><a id="3334" class="Symbol">)</a>
                                       <a id="3375" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">⟩</a>
    <a id="3381" href="README.Nary.html#2995" class="Bound">m</a> <a id="3383" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3385" class="Number">0</a> <a id="3387" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3389" href="README.Nary.html#2997" class="Bound">n</a> <a id="3391" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3393" href="README.Nary.html#2999" class="Bound">p</a> <a id="3395" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3397" class="Symbol">(</a><a id="3398" href="README.Nary.html#3001" class="Bound">q</a> <a id="3400" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3402" href="README.Nary.html#2995" class="Bound">m</a><a id="3403" class="Symbol">)</a> <a id="3405" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3407" class="Symbol">(</a><a id="3408" href="README.Nary.html#3001" class="Bound">q</a> <a id="3410" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3412" href="README.Nary.html#2997" class="Bound">n</a><a id="3413" class="Symbol">)</a> <a id="3415" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3417" class="Number">1</a> <a id="3419" href="Relation.Binary.PropositionalEquality.Core.html#3133" class="Function Operator">∎</a> <a id="3421" class="Keyword">where</a> <a id="3427" class="Keyword">open</a> <a id="3432" href="Relation.Binary.PropositionalEquality.Core.html#2736" class="Module">≡-Reasoning</a>

<a id="3445" class="Comment">-- Partial application of the functional argument is fine: the number of arguments</a>
<a id="3528" class="Comment">-- `congₙ` is going to take is determined by its first argument (a natural number)</a>
<a id="3611" class="Comment">-- and not by the type of the function it works on.</a>

<a id="3664" href="README.Nary.html#3664" class="Function">_</a> <a id="3666" class="Symbol">:</a> <a id="3668" class="Symbol">∀</a> <a id="3670" href="README.Nary.html#3670" class="Bound">m</a> <a id="3672" class="Symbol">→</a> <a id="3674" class="Symbol">(</a><a id="3675" href="README.Nary.html#3670" class="Bound">m</a> <a id="3677" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+_</a><a id="3679" class="Symbol">)</a> <a id="3681" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="3683" class="Symbol">((</a><a id="3685" href="README.Nary.html#3670" class="Bound">m</a> <a id="3687" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3689" class="Number">0</a><a id="3690" class="Symbol">)</a> <a id="3692" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+_</a><a id="3694" class="Symbol">)</a>
<a id="3696" class="Symbol">_</a> <a id="3698" class="Symbol">=</a> <a id="3700" class="Symbol">λ</a> <a id="3702" href="README.Nary.html#3702" class="Bound">m</a> <a id="3704" class="Symbol">→</a> <a id="3706" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="3712" class="Number">1</a> <a id="3714" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="3718" class="Symbol">(</a><a id="3719" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="3726" class="Number">0</a> <a id="3728" href="README.Nary.html#3702" class="Bound">m</a><a id="3729" class="Symbol">)</a>

<a id="3732" class="Comment">-- We don&#39;t have to work on the function&#39;s first argument either: we can just as</a>
<a id="3813" class="Comment">-- easily use `congₙ` to act on the second one by `flip`ping it. See `holeₙ` for</a>
<a id="3894" class="Comment">-- a generalisation of this idea allowing to target *any* of the function&#39;s</a>
<a id="3970" class="Comment">-- arguments and not just the first or second one.</a>

<a id="4022" href="README.Nary.html#4022" class="Function">_</a> <a id="4024" class="Symbol">:</a> <a id="4026" class="Symbol">∀</a> <a id="4028" href="README.Nary.html#4028" class="Bound">m</a> <a id="4030" class="Symbol">→</a> <a id="4032" class="Symbol">(</a><a id="4033" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+</a> <a id="4036" href="README.Nary.html#4028" class="Bound">m</a><a id="4037" class="Symbol">)</a> <a id="4039" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4041" class="Symbol">(</a><a id="4042" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+</a> <a id="4045" class="Symbol">(</a><a id="4046" href="README.Nary.html#4028" class="Bound">m</a> <a id="4048" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4050" class="Number">0</a><a id="4051" class="Symbol">))</a>
<a id="4054" class="Symbol">_</a> <a id="4056" class="Symbol">=</a> <a id="4058" class="Symbol">λ</a> <a id="4060" href="README.Nary.html#4060" class="Bound">m</a> <a id="4062" class="Symbol">→</a> <a id="4064" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="4070" class="Number">1</a> <a id="4072" class="Symbol">(</a><a id="4073" href="Function.Base.html#1638" class="Function">flip</a> <a id="4078" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="4081" class="Symbol">)</a> <a id="4083" class="Symbol">(</a><a id="4084" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4091" class="Number">0</a> <a id="4093" href="README.Nary.html#4060" class="Bound">m</a><a id="4094" class="Symbol">)</a>

<a id="4097" class="Comment">------------------------------------------------------------------------</a>
<a id="4170" class="Comment">-- substₙ : (P : A₁ → ⋯ → Aₙ → Set p) →</a>
<a id="4210" class="Comment">--          a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → P a₁ ⋯ aₙ → P b₁ ⋯ bₙ</a>

<a id="4267" class="Comment">-- We can play the same type of game with subst</a>

<a id="4316" class="Keyword">open</a> <a id="4321" class="Keyword">import</a> <a id="4328" href="Agda.Builtin.Nat.html" class="Module">Agda.Builtin.Nat</a> <a id="4345" class="Keyword">using</a> <a id="4351" class="Symbol">(</a><a id="4352" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a><a id="4362" class="Symbol">)</a>

<a id="4365" class="Comment">-- Because we know from the definition `mod-helper` that this equation holds:</a>
<a id="4443" class="Comment">-- mod-helper k m (suc n) (suc j) = mod-helper (suc k) m n j</a>
<a id="4504" class="Comment">-- we should be able to prove the slightly modified statement by transforming</a>
<a id="4582" class="Comment">-- all the `x + 1` into `suc x`. We can do so using `substₙ`.</a>

<a id="4645" href="README.Nary.html#4645" class="Function">_</a> <a id="4647" class="Symbol">:</a> <a id="4649" class="Symbol">∀</a> <a id="4651" href="README.Nary.html#4651" class="Bound">k</a> <a id="4653" href="README.Nary.html#4653" class="Bound">m</a> <a id="4655" href="README.Nary.html#4655" class="Bound">n</a> <a id="4657" href="README.Nary.html#4657" class="Bound">j</a> <a id="4659" class="Symbol">→</a> <a id="4661" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4672" href="README.Nary.html#4651" class="Bound">k</a> <a id="4674" href="README.Nary.html#4653" class="Bound">m</a> <a id="4676" class="Symbol">(</a><a id="4677" href="README.Nary.html#4655" class="Bound">n</a> <a id="4679" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4681" class="Number">1</a><a id="4682" class="Symbol">)</a> <a id="4684" class="Symbol">(</a><a id="4685" href="README.Nary.html#4657" class="Bound">j</a> <a id="4687" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4689" class="Number">1</a><a id="4690" class="Symbol">)</a> <a id="4692" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4694" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4705" class="Symbol">(</a><a id="4706" href="README.Nary.html#4651" class="Bound">k</a> <a id="4708" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4710" class="Number">1</a><a id="4711" class="Symbol">)</a> <a id="4713" href="README.Nary.html#4653" class="Bound">m</a> <a id="4715" href="README.Nary.html#4655" class="Bound">n</a> <a id="4717" href="README.Nary.html#4657" class="Bound">j</a>
<a id="4719" class="Symbol">_</a> <a id="4721" class="Symbol">=</a> <a id="4723" class="Symbol">λ</a> <a id="4725" href="README.Nary.html#4725" class="Bound">k</a> <a id="4727" href="README.Nary.html#4727" class="Bound">m</a> <a id="4729" href="README.Nary.html#4729" class="Bound">n</a> <a id="4731" href="README.Nary.html#4731" class="Bound">j</a> <a id="4733" class="Symbol">→</a>
    <a id="4739" class="Keyword">let</a> <a id="4743" href="README.Nary.html#4743" class="Bound">P</a> <a id="4745" href="README.Nary.html#4745" class="Bound">sk</a> <a id="4748" href="README.Nary.html#4748" class="Bound">sn</a> <a id="4751" href="README.Nary.html#4751" class="Bound">sj</a> <a id="4754" class="Symbol">=</a> <a id="4756" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4767" href="README.Nary.html#4725" class="Bound">k</a> <a id="4769" href="README.Nary.html#4727" class="Bound">m</a> <a id="4771" href="README.Nary.html#4748" class="Bound">sn</a> <a id="4774" href="README.Nary.html#4751" class="Bound">sj</a> <a id="4777" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4779" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4790" href="README.Nary.html#4745" class="Bound">sk</a> <a id="4793" href="README.Nary.html#4727" class="Bound">m</a> <a id="4795" href="README.Nary.html#4729" class="Bound">n</a> <a id="4797" href="README.Nary.html#4731" class="Bound">j</a>
    <a id="4803" class="Keyword">in</a> <a id="4806" href="Relation.Nary.html#3713" class="Function">substₙ</a> <a id="4813" href="README.Nary.html#4743" class="Bound">P</a> <a id="4815" class="Symbol">(</a><a id="4816" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4823" class="Number">1</a> <a id="4825" href="README.Nary.html#4725" class="Bound">k</a><a id="4826" class="Symbol">)</a> <a id="4828" class="Symbol">(</a><a id="4829" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4836" class="Number">1</a> <a id="4838" href="README.Nary.html#4729" class="Bound">n</a><a id="4839" class="Symbol">)</a> <a id="4841" class="Symbol">(</a><a id="4842" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4849" class="Number">1</a> <a id="4851" href="README.Nary.html#4731" class="Bound">j</a><a id="4852" class="Symbol">)</a> <a id="4854" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="4860" class="Comment">-----------------------------------------------------------------------</a>
<a id="4932" class="Comment">-- Generic programs working on n-ary products &amp; functions</a>
<a id="4990" class="Comment">-----------------------------------------------------------------------</a>

<a id="5063" class="Comment">-----------------------------------------------------------------------</a>
<a id="5135" class="Comment">-- curryₙ   : ∀ n → (A₁ × ⋯ × Aₙ → B) → A₁ → ⋯ → Aₙ → B</a>
<a id="5191" class="Comment">-- uncurryₙ : ∀ n → (A₁ → ⋯ → Aₙ → B) → A₁ × ⋯ × Aₙ → B</a>

<a id="5248" class="Comment">-- The first thing we may want to do generically is convert between</a>
<a id="5316" class="Comment">-- curried function types and uncurried ones. We can do this by using:</a>

<a id="5388" class="Comment">-- They both work the same way so we will focus on curryₙ only here.</a>
<a id="5457" class="Comment">-- If we pass to `curryₙ` the arity of its argument then we obtain a</a>
<a id="5526" class="Comment">-- fully curried function.</a>

<a id="curry₁"></a><a id="5554" href="README.Nary.html#5554" class="Function">curry₁</a> <a id="5561" class="Symbol">:</a> <a id="5563" class="Symbol">(</a><a id="5564" href="README.Nary.html#860" class="Generalizable">A</a> <a id="5566" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5568" href="README.Nary.html#874" class="Generalizable">B</a> <a id="5570" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5572" href="README.Nary.html#888" class="Generalizable">C</a> <a id="5574" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5576" href="README.Nary.html#902" class="Generalizable">D</a> <a id="5578" class="Symbol">→</a> <a id="5580" href="README.Nary.html#916" class="Generalizable">E</a><a id="5581" class="Symbol">)</a> <a id="5583" class="Symbol">→</a> <a id="5585" href="README.Nary.html#860" class="Generalizable">A</a> <a id="5587" class="Symbol">→</a> <a id="5589" href="README.Nary.html#874" class="Generalizable">B</a> <a id="5591" class="Symbol">→</a> <a id="5593" href="README.Nary.html#888" class="Generalizable">C</a> <a id="5595" class="Symbol">→</a> <a id="5597" href="README.Nary.html#902" class="Generalizable">D</a> <a id="5599" class="Symbol">→</a> <a id="5601" href="README.Nary.html#916" class="Generalizable">E</a>
<a id="5603" href="README.Nary.html#5554" class="Function">curry₁</a> <a id="5610" class="Symbol">=</a> <a id="5612" href="Data.Product.Nary.NonDependent.html#3691" class="Function">curryₙ</a> <a id="5619" class="Number">4</a>

<a id="5622" class="Comment">-- Note that here we are not flattening arbitrary nestings: products have</a>
<a id="5696" class="Comment">-- to be right nested. Which means that if you have a deeply-nested product</a>
<a id="5772" class="Comment">-- then it won&#39;t be affected by the procedure.</a>

<a id="curry₁′"></a><a id="5820" href="README.Nary.html#5820" class="Function">curry₁′</a> <a id="5828" class="Symbol">:</a> <a id="5830" class="Symbol">(</a><a id="5831" href="README.Nary.html#860" class="Generalizable">A</a> <a id="5833" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5835" class="Symbol">(</a><a id="5836" href="README.Nary.html#874" class="Generalizable">B</a> <a id="5838" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5840" href="README.Nary.html#888" class="Generalizable">C</a><a id="5841" class="Symbol">)</a> <a id="5843" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5845" href="README.Nary.html#902" class="Generalizable">D</a> <a id="5847" class="Symbol">→</a> <a id="5849" href="README.Nary.html#916" class="Generalizable">E</a><a id="5850" class="Symbol">)</a> <a id="5852" class="Symbol">→</a> <a id="5854" href="README.Nary.html#860" class="Generalizable">A</a> <a id="5856" class="Symbol">→</a> <a id="5858" class="Symbol">(</a><a id="5859" href="README.Nary.html#874" class="Generalizable">B</a> <a id="5861" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5863" href="README.Nary.html#888" class="Generalizable">C</a><a id="5864" class="Symbol">)</a> <a id="5866" class="Symbol">→</a> <a id="5868" href="README.Nary.html#902" class="Generalizable">D</a> <a id="5870" class="Symbol">→</a> <a id="5872" href="README.Nary.html#916" class="Generalizable">E</a>
<a id="5874" href="README.Nary.html#5820" class="Function">curry₁′</a> <a id="5882" class="Symbol">=</a> <a id="5884" href="Data.Product.Nary.NonDependent.html#3691" class="Function">curryₙ</a> <a id="5891" class="Number">3</a>

<a id="5894" class="Comment">-- When we are currying a function, we have no obligation to pass its exact</a>
<a id="5970" class="Comment">-- arity as the parameter: we can decide to only curry part of it like so:</a>
<a id="6045" class="Comment">-- Indeed (A₁ × ⋯ × Aₙ → B) can also be seen as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ) → B)</a>

<a id="curry₂"></a><a id="6123" href="README.Nary.html#6123" class="Function">curry₂</a> <a id="6130" class="Symbol">:</a> <a id="6132" class="Symbol">(</a><a id="6133" href="README.Nary.html#860" class="Generalizable">A</a> <a id="6135" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6137" href="README.Nary.html#874" class="Generalizable">B</a> <a id="6139" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6141" href="README.Nary.html#888" class="Generalizable">C</a> <a id="6143" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6145" href="README.Nary.html#902" class="Generalizable">D</a> <a id="6147" class="Symbol">→</a> <a id="6149" href="README.Nary.html#916" class="Generalizable">E</a><a id="6150" class="Symbol">)</a> <a id="6152" class="Symbol">→</a> <a id="6154" href="README.Nary.html#860" class="Generalizable">A</a> <a id="6156" class="Symbol">→</a> <a id="6158" href="README.Nary.html#874" class="Generalizable">B</a> <a id="6160" class="Symbol">→</a> <a id="6162" class="Symbol">(</a><a id="6163" href="README.Nary.html#888" class="Generalizable">C</a> <a id="6165" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6167" href="README.Nary.html#902" class="Generalizable">D</a><a id="6168" class="Symbol">)</a> <a id="6170" class="Symbol">→</a> <a id="6172" href="README.Nary.html#916" class="Generalizable">E</a>
<a id="6174" href="README.Nary.html#6123" class="Function">curry₂</a> <a id="6181" class="Symbol">=</a> <a id="6183" href="Data.Product.Nary.NonDependent.html#3691" class="Function">curryₙ</a> <a id="6190" class="Number">3</a>

<a id="6193" class="Comment">-----------------------------------------------------------------------</a>
<a id="6265" class="Comment">-- projₙ : ∀ n (k : Fin n) → (A₁ × ⋯ × Aₙ) → Aₖ₊₁</a>

<a id="6316" class="Comment">-- Another useful class of functions to manipulate n-ary product is a</a>
<a id="6386" class="Comment">-- generic projection function. Note the (k + 1) in the return index:</a>
<a id="6456" class="Comment">-- Fin counts from 0 up.</a>

<a id="6482" class="Comment">-- It behaves as one expects (Data.Fin&#39;s #_ comes in handy to write down</a>
<a id="6555" class="Comment">-- Fin literals):</a>

<a id="proj₃"></a><a id="6574" href="README.Nary.html#6574" class="Function">proj₃</a> <a id="6580" class="Symbol">:</a> <a id="6582" class="Symbol">(</a><a id="6583" href="README.Nary.html#860" class="Generalizable">A</a> <a id="6585" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6587" href="README.Nary.html#874" class="Generalizable">B</a> <a id="6589" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6591" href="README.Nary.html#888" class="Generalizable">C</a> <a id="6593" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6595" href="README.Nary.html#902" class="Generalizable">D</a> <a id="6597" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6599" href="README.Nary.html#916" class="Generalizable">E</a><a id="6600" class="Symbol">)</a> <a id="6602" class="Symbol">→</a> <a id="6604" href="README.Nary.html#888" class="Generalizable">C</a>
<a id="6606" href="README.Nary.html#6574" class="Function">proj₃</a> <a id="6612" class="Symbol">=</a> <a id="6614" href="Data.Product.Nary.NonDependent.html#6488" class="Function">projₙ</a> <a id="6620" class="Number">5</a> <a id="6622" class="Symbol">(</a><a id="6623" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="6625" class="Number">2</a><a id="6626" class="Symbol">)</a>

<a id="6629" class="Comment">-- Of course we can once more project the &quot;tail&quot; of the n-ary product by</a>
<a id="6702" class="Comment">-- passing `projₙ` a natural number which is smaller than the size of the</a>
<a id="6776" class="Comment">-- n-ary product, seeing (A₁ × ⋯ × Aₙ) as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ)).</a>

<a id="proj₃′"></a><a id="6845" href="README.Nary.html#6845" class="Function">proj₃′</a> <a id="6852" class="Symbol">:</a> <a id="6854" class="Symbol">(</a><a id="6855" href="README.Nary.html#860" class="Generalizable">A</a> <a id="6857" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6859" href="README.Nary.html#874" class="Generalizable">B</a> <a id="6861" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6863" href="README.Nary.html#888" class="Generalizable">C</a> <a id="6865" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6867" href="README.Nary.html#902" class="Generalizable">D</a> <a id="6869" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6871" href="README.Nary.html#916" class="Generalizable">E</a><a id="6872" class="Symbol">)</a> <a id="6874" class="Symbol">→</a> <a id="6876" href="README.Nary.html#888" class="Generalizable">C</a> <a id="6878" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6880" href="README.Nary.html#902" class="Generalizable">D</a> <a id="6882" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6884" href="README.Nary.html#916" class="Generalizable">E</a>
<a id="6886" href="README.Nary.html#6845" class="Function">proj₃′</a> <a id="6893" class="Symbol">=</a> <a id="6895" href="Data.Product.Nary.NonDependent.html#6488" class="Function">projₙ</a> <a id="6901" class="Number">3</a> <a id="6903" class="Symbol">(</a><a id="6904" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="6906" class="Number">2</a><a id="6907" class="Symbol">)</a>

<a id="6910" class="Comment">-----------------------------------------------------------------------</a>
<a id="6982" class="Comment">-- insertₙ : ∀ n (k : Fin (suc n)) →</a>
<a id="7019" class="Comment">--           B → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B × Aₖ₊₁ × ⋯ Aₙ)</a>

<a id="insert₁"></a><a id="7083" href="README.Nary.html#7083" class="Function">insert₁</a> <a id="7091" class="Symbol">:</a> <a id="7093" href="README.Nary.html#888" class="Generalizable">C</a> <a id="7095" class="Symbol">→</a> <a id="7097" class="Symbol">(</a><a id="7098" href="README.Nary.html#860" class="Generalizable">A</a> <a id="7100" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7102" href="README.Nary.html#874" class="Generalizable">B</a> <a id="7104" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7106" href="README.Nary.html#902" class="Generalizable">D</a> <a id="7108" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7110" href="README.Nary.html#916" class="Generalizable">E</a><a id="7111" class="Symbol">)</a> <a id="7113" class="Symbol">→</a> <a id="7115" class="Symbol">(</a><a id="7116" href="README.Nary.html#860" class="Generalizable">A</a> <a id="7118" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7120" href="README.Nary.html#874" class="Generalizable">B</a> <a id="7122" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7124" href="README.Nary.html#888" class="Generalizable">C</a> <a id="7126" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7128" href="README.Nary.html#902" class="Generalizable">D</a> <a id="7130" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7132" href="README.Nary.html#916" class="Generalizable">E</a><a id="7133" class="Symbol">)</a>
<a id="7135" href="README.Nary.html#7083" class="Function">insert₁</a> <a id="7143" class="Symbol">=</a> <a id="7145" href="Data.Product.Nary.NonDependent.html#8541" class="Function">insertₙ</a> <a id="7153" class="Number">4</a> <a id="7155" class="Symbol">(</a><a id="7156" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7158" class="Number">2</a><a id="7159" class="Symbol">)</a>

<a id="insert₁′"></a><a id="7162" href="README.Nary.html#7162" class="Function">insert₁′</a> <a id="7171" class="Symbol">:</a> <a id="7173" href="README.Nary.html#888" class="Generalizable">C</a> <a id="7175" class="Symbol">→</a> <a id="7177" class="Symbol">(</a><a id="7178" href="README.Nary.html#860" class="Generalizable">A</a> <a id="7180" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7182" href="README.Nary.html#874" class="Generalizable">B</a> <a id="7184" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7186" href="README.Nary.html#902" class="Generalizable">D</a> <a id="7188" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7190" href="README.Nary.html#916" class="Generalizable">E</a><a id="7191" class="Symbol">)</a> <a id="7193" class="Symbol">→</a> <a id="7195" class="Symbol">(</a><a id="7196" href="README.Nary.html#860" class="Generalizable">A</a> <a id="7198" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7200" href="README.Nary.html#874" class="Generalizable">B</a> <a id="7202" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7204" href="README.Nary.html#888" class="Generalizable">C</a> <a id="7206" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7208" href="README.Nary.html#902" class="Generalizable">D</a> <a id="7210" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7212" href="README.Nary.html#916" class="Generalizable">E</a><a id="7213" class="Symbol">)</a>
<a id="7215" href="README.Nary.html#7162" class="Function">insert₁′</a> <a id="7224" class="Symbol">=</a> <a id="7226" href="Data.Product.Nary.NonDependent.html#8541" class="Function">insertₙ</a> <a id="7234" class="Number">3</a> <a id="7236" class="Symbol">(</a><a id="7237" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7239" class="Number">2</a><a id="7240" class="Symbol">)</a>

<a id="7243" class="Comment">-- Note that `insertₙ` takes a `Fin (suc n)`. Indeed in an n-ary product</a>
<a id="7316" class="Comment">-- there are (suc n) positions at which one may insert a value. We may</a>
<a id="7387" class="Comment">-- insert at the front or the back of the product:</a>

<a id="insert-front"></a><a id="7439" href="README.Nary.html#7439" class="Function">insert-front</a> <a id="7452" class="Symbol">:</a> <a id="7454" href="README.Nary.html#860" class="Generalizable">A</a> <a id="7456" class="Symbol">→</a> <a id="7458" class="Symbol">(</a><a id="7459" href="README.Nary.html#874" class="Generalizable">B</a> <a id="7461" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7463" href="README.Nary.html#888" class="Generalizable">C</a> <a id="7465" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7467" href="README.Nary.html#902" class="Generalizable">D</a> <a id="7469" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7471" href="README.Nary.html#916" class="Generalizable">E</a><a id="7472" class="Symbol">)</a> <a id="7474" class="Symbol">→</a> <a id="7476" class="Symbol">(</a><a id="7477" href="README.Nary.html#860" class="Generalizable">A</a> <a id="7479" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7481" href="README.Nary.html#874" class="Generalizable">B</a> <a id="7483" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7485" href="README.Nary.html#888" class="Generalizable">C</a> <a id="7487" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7489" href="README.Nary.html#902" class="Generalizable">D</a> <a id="7491" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7493" href="README.Nary.html#916" class="Generalizable">E</a><a id="7494" class="Symbol">)</a>
<a id="7496" href="README.Nary.html#7439" class="Function">insert-front</a> <a id="7509" class="Symbol">=</a> <a id="7511" href="Data.Product.Nary.NonDependent.html#8541" class="Function">insertₙ</a> <a id="7519" class="Number">4</a> <a id="7521" class="Symbol">(</a><a id="7522" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7524" class="Number">0</a><a id="7525" class="Symbol">)</a>

<a id="insert-back"></a><a id="7528" href="README.Nary.html#7528" class="Function">insert-back</a> <a id="7540" class="Symbol">:</a> <a id="7542" href="README.Nary.html#916" class="Generalizable">E</a> <a id="7544" class="Symbol">→</a> <a id="7546" class="Symbol">(</a><a id="7547" href="README.Nary.html#860" class="Generalizable">A</a> <a id="7549" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7551" href="README.Nary.html#874" class="Generalizable">B</a> <a id="7553" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7555" href="README.Nary.html#888" class="Generalizable">C</a> <a id="7557" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7559" href="README.Nary.html#902" class="Generalizable">D</a><a id="7560" class="Symbol">)</a> <a id="7562" class="Symbol">→</a> <a id="7564" class="Symbol">(</a><a id="7565" href="README.Nary.html#860" class="Generalizable">A</a> <a id="7567" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7569" href="README.Nary.html#874" class="Generalizable">B</a> <a id="7571" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7573" href="README.Nary.html#888" class="Generalizable">C</a> <a id="7575" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7577" href="README.Nary.html#902" class="Generalizable">D</a> <a id="7579" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7581" href="README.Nary.html#916" class="Generalizable">E</a><a id="7582" class="Symbol">)</a>
<a id="7584" href="README.Nary.html#7528" class="Function">insert-back</a> <a id="7596" class="Symbol">=</a> <a id="7598" href="Data.Product.Nary.NonDependent.html#8541" class="Function">insertₙ</a> <a id="7606" class="Number">4</a> <a id="7608" class="Symbol">(</a><a id="7609" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7611" class="Number">4</a><a id="7612" class="Symbol">)</a>

<a id="7615" class="Comment">-----------------------------------------------------------------------</a>
<a id="7687" class="Comment">-- removeₙ : ∀ n (k : Fin n) → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="7761" class="Comment">-- Dual to `insertₙ`, we may remove a value.</a>

<a id="remove₁"></a><a id="7807" href="README.Nary.html#7807" class="Function">remove₁</a> <a id="7815" class="Symbol">:</a> <a id="7817" class="Symbol">(</a><a id="7818" href="README.Nary.html#860" class="Generalizable">A</a> <a id="7820" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7822" href="README.Nary.html#874" class="Generalizable">B</a> <a id="7824" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7826" href="README.Nary.html#888" class="Generalizable">C</a> <a id="7828" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7830" href="README.Nary.html#902" class="Generalizable">D</a> <a id="7832" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7834" href="README.Nary.html#916" class="Generalizable">E</a><a id="7835" class="Symbol">)</a> <a id="7837" class="Symbol">→</a> <a id="7839" class="Symbol">(</a><a id="7840" href="README.Nary.html#860" class="Generalizable">A</a> <a id="7842" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7844" href="README.Nary.html#874" class="Generalizable">B</a> <a id="7846" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7848" href="README.Nary.html#902" class="Generalizable">D</a> <a id="7850" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7852" href="README.Nary.html#916" class="Generalizable">E</a><a id="7853" class="Symbol">)</a>
<a id="7855" href="README.Nary.html#7807" class="Function">remove₁</a> <a id="7863" class="Symbol">=</a> <a id="7865" href="Data.Product.Nary.NonDependent.html#7678" class="Function">removeₙ</a> <a id="7873" class="Number">5</a> <a id="7875" class="Symbol">(</a><a id="7876" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7878" class="Number">2</a><a id="7879" class="Symbol">)</a>

<a id="7882" class="Comment">-- Inserting at `k` and then removing at `inject₁ k` should yield the identity</a>

<a id="remove-insert"></a><a id="7962" href="README.Nary.html#7962" class="Function">remove-insert</a> <a id="7976" class="Symbol">:</a> <a id="7978" href="README.Nary.html#888" class="Generalizable">C</a> <a id="7980" class="Symbol">→</a> <a id="7982" class="Symbol">(</a><a id="7983" href="README.Nary.html#860" class="Generalizable">A</a> <a id="7985" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7987" href="README.Nary.html#874" class="Generalizable">B</a> <a id="7989" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7991" href="README.Nary.html#902" class="Generalizable">D</a> <a id="7993" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7995" href="README.Nary.html#916" class="Generalizable">E</a><a id="7996" class="Symbol">)</a> <a id="7998" class="Symbol">→</a> <a id="8000" class="Symbol">(</a><a id="8001" href="README.Nary.html#860" class="Generalizable">A</a> <a id="8003" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8005" href="README.Nary.html#874" class="Generalizable">B</a> <a id="8007" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8009" href="README.Nary.html#902" class="Generalizable">D</a> <a id="8011" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8013" href="README.Nary.html#916" class="Generalizable">E</a><a id="8014" class="Symbol">)</a>
<a id="8016" href="README.Nary.html#7962" class="Function">remove-insert</a> <a id="8030" href="README.Nary.html#8030" class="Bound">c</a> <a id="8032" class="Symbol">=</a> <a id="8034" href="Data.Product.Nary.NonDependent.html#7678" class="Function">removeₙ</a> <a id="8042" class="Number">5</a> <a id="8044" class="Symbol">(</a><a id="8045" href="Data.Fin.Base.html#3276" class="Function">inject₁</a> <a id="8053" href="README.Nary.html#8083" class="Function">k</a><a id="8054" class="Symbol">)</a> <a id="8056" href="Function.Base.html#3646" class="Function Operator">∘′</a> <a id="8059" href="Data.Product.Nary.NonDependent.html#8541" class="Function">insertₙ</a> <a id="8067" class="Number">4</a> <a id="8069" href="README.Nary.html#8083" class="Function">k</a> <a id="8071" href="README.Nary.html#8030" class="Bound">c</a>
    <a id="8077" class="Keyword">where</a> <a id="8083" href="README.Nary.html#8083" class="Function">k</a> <a id="8085" class="Symbol">=</a> <a id="8087" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8089" class="Number">2</a>

<a id="8092" class="Comment">-----------------------------------------------------------------------</a>
<a id="8164" class="Comment">-- updateₙ : ∀ n (k : Fin n) (f : (a : Aₖ₊₁) → B a) →</a>
<a id="8218" class="Comment">--           (p : A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B (projₙ n k p) × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="8296" class="Comment">-- We can not only project out, insert or remove values: we can update them</a>
<a id="8372" class="Comment">-- in place. The type (and value) of the replacement at position k may depend</a>
<a id="8450" class="Comment">-- upon the current value at position k.</a>

<a id="update₁"></a><a id="8492" href="README.Nary.html#8492" class="Function">update₁</a> <a id="8500" class="Symbol">:</a> <a id="8502" class="Symbol">(</a><a id="8503" href="README.Nary.html#8503" class="Bound">p</a> <a id="8505" class="Symbol">:</a> <a id="8507" href="README.Nary.html#860" class="Generalizable">A</a> <a id="8509" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8511" href="README.Nary.html#874" class="Generalizable">B</a> <a id="8513" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8515" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="8517" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8519" href="README.Nary.html#888" class="Generalizable">C</a> <a id="8521" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8523" href="README.Nary.html#902" class="Generalizable">D</a><a id="8524" class="Symbol">)</a> <a id="8526" class="Symbol">→</a> <a id="8528" class="Symbol">(</a><a id="8529" href="README.Nary.html#860" class="Generalizable">A</a> <a id="8531" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8533" href="README.Nary.html#874" class="Generalizable">B</a> <a id="8535" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8537" href="Data.Fin.Base.html#1312" class="Datatype">Fin</a> <a id="8541" class="Symbol">_</a> <a id="8543" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8545" href="README.Nary.html#888" class="Generalizable">C</a> <a id="8547" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8549" href="README.Nary.html#902" class="Generalizable">D</a><a id="8550" class="Symbol">)</a>
<a id="8552" href="README.Nary.html#8492" class="Function">update₁</a> <a id="8560" class="Symbol">=</a> <a id="8562" href="Data.Product.Nary.NonDependent.html#9348" class="Function">updateₙ</a> <a id="8570" class="Number">5</a> <a id="8572" class="Symbol">(</a><a id="8573" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8575" class="Number">2</a><a id="8576" class="Symbol">)</a> <a id="8578" href="Data.Fin.Base.html#2005" class="Function">fromℕ</a>

<a id="8585" class="Comment">-- We can explicitly use the primed version of `updateₙ` to make it known to</a>
<a id="8662" class="Comment">-- Agda that the update function is non dependent. This type of information</a>
<a id="8738" class="Comment">-- is useful for inference: the tighter the constraints, the easier it is to</a>
<a id="8815" class="Comment">-- find a solution (if possible).</a>

<a id="update₂"></a><a id="8850" href="README.Nary.html#8850" class="Function">update₂</a> <a id="8858" class="Symbol">:</a> <a id="8860" class="Symbol">(</a><a id="8861" href="README.Nary.html#8861" class="Bound">p</a> <a id="8863" class="Symbol">:</a> <a id="8865" href="README.Nary.html#860" class="Generalizable">A</a> <a id="8867" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8869" href="README.Nary.html#874" class="Generalizable">B</a> <a id="8871" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8873" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="8875" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8877" href="README.Nary.html#888" class="Generalizable">C</a> <a id="8879" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8881" href="README.Nary.html#902" class="Generalizable">D</a><a id="8882" class="Symbol">)</a> <a id="8884" class="Symbol">→</a> <a id="8886" class="Symbol">(</a><a id="8887" href="README.Nary.html#860" class="Generalizable">A</a> <a id="8889" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8891" href="README.Nary.html#874" class="Generalizable">B</a> <a id="8893" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8895" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="8900" href="README.Nary.html#902" class="Generalizable">D</a> <a id="8902" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8904" href="README.Nary.html#888" class="Generalizable">C</a> <a id="8906" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8908" href="README.Nary.html#902" class="Generalizable">D</a><a id="8909" class="Symbol">)</a>
<a id="8911" href="README.Nary.html#8850" class="Function">update₂</a> <a id="8919" class="Symbol">=</a> <a id="8921" class="Symbol">λ</a> <a id="8923" href="README.Nary.html#8923" class="Bound">p</a> <a id="8925" class="Symbol">→</a> <a id="8927" href="Data.Product.Nary.NonDependent.html#9694" class="Function">updateₙ′</a> <a id="8936" class="Number">5</a> <a id="8938" class="Symbol">(</a><a id="8939" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8941" class="Number">2</a><a id="8942" class="Symbol">)</a> <a id="8944" class="Symbol">(λ</a> <a id="8947" href="README.Nary.html#8947" class="Bound">n</a> <a id="8949" class="Symbol">→</a> <a id="8951" href="Data.List.Base.html#5347" class="Function">replicate</a> <a id="8961" href="README.Nary.html#8947" class="Bound">n</a> <a id="8963" class="Symbol">(</a><a id="8964" href="Data.Product.Nary.NonDependent.html#6488" class="Function">projₙ</a> <a id="8970" class="Number">5</a> <a id="8972" class="Symbol">(</a><a id="8973" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8975" class="Number">4</a><a id="8976" class="Symbol">)</a> <a id="8978" href="README.Nary.html#8923" class="Bound">p</a><a id="8979" class="Symbol">))</a> <a id="8982" href="README.Nary.html#8923" class="Bound">p</a>

<a id="8985" class="Comment">-----------------------------------------------------------------------</a>
<a id="9057" class="Comment">-- _%=_⊢_ : ∀ n → (C → D) → (A₁ → ⋯ Aₙ → D → B) → A₁ → ⋯ → Aₙ → C → B</a>

<a id="9128" class="Comment">-- Traditional composition (also known as the index update operator `_⊢_`</a>
<a id="9202" class="Comment">-- in `Relation.Unary`) focuses solely on the first argument of an n-ary</a>
<a id="9275" class="Comment">-- function. `_%=_⊢_` on the other hand allows us to touch any one of the</a>
<a id="9349" class="Comment">-- arguments.</a>

<a id="9364" class="Comment">-- In the following example we have a function `f : A → B` and `replicate`</a>
<a id="9439" class="Comment">-- of type `ℕ → B → List B`. We want ̀f` to act on the second argument of</a>
<a id="9513" class="Comment">-- replicate. Which we can do like so.</a>

<a id="compose₁"></a><a id="9553" href="README.Nary.html#9553" class="Function">compose₁</a> <a id="9562" class="Symbol">:</a> <a id="9564" class="Symbol">(</a><a id="9565" href="README.Nary.html#860" class="Generalizable">A</a> <a id="9567" class="Symbol">→</a> <a id="9569" href="README.Nary.html#874" class="Generalizable">B</a><a id="9570" class="Symbol">)</a> <a id="9572" class="Symbol">→</a> <a id="9574" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="9576" class="Symbol">→</a> <a id="9578" href="README.Nary.html#860" class="Generalizable">A</a> <a id="9580" class="Symbol">→</a> <a id="9582" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="9587" href="README.Nary.html#874" class="Generalizable">B</a>
<a id="9589" href="README.Nary.html#9553" class="Function">compose₁</a> <a id="9598" href="README.Nary.html#9598" class="Bound">f</a> <a id="9600" class="Symbol">=</a> <a id="9602" class="Number">1</a> <a id="9604" href="Function.Nary.NonDependent.Base.html#3868" class="Function Operator">%=</a> <a id="9607" href="README.Nary.html#9598" class="Bound">f</a> <a id="9609" href="Function.Nary.NonDependent.Base.html#3868" class="Function Operator">⊢</a> <a id="9611" href="Data.List.Base.html#5347" class="Function">replicate</a>

<a id="9622" class="Comment">-- Here we spell out the equivalent explicit variable-manipulation and</a>
<a id="9693" class="Comment">-- prove the two functions equal.</a>

<a id="compose₁′"></a><a id="9728" href="README.Nary.html#9728" class="Function">compose₁′</a> <a id="9738" class="Symbol">:</a> <a id="9740" class="Symbol">(</a><a id="9741" href="README.Nary.html#860" class="Generalizable">A</a> <a id="9743" class="Symbol">→</a> <a id="9745" href="README.Nary.html#874" class="Generalizable">B</a><a id="9746" class="Symbol">)</a> <a id="9748" class="Symbol">→</a> <a id="9750" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="9752" class="Symbol">→</a> <a id="9754" href="README.Nary.html#860" class="Generalizable">A</a> <a id="9756" class="Symbol">→</a> <a id="9758" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="9763" href="README.Nary.html#874" class="Generalizable">B</a>
<a id="9765" href="README.Nary.html#9728" class="Function">compose₁′</a> <a id="9775" href="README.Nary.html#9775" class="Bound">f</a> <a id="9777" href="README.Nary.html#9777" class="Bound">n</a> <a id="9779" href="README.Nary.html#9779" class="Bound">a</a> <a id="9781" class="Symbol">=</a> <a id="9783" href="Data.List.Base.html#5347" class="Function">replicate</a> <a id="9793" href="README.Nary.html#9777" class="Bound">n</a> <a id="9795" class="Symbol">(</a><a id="9796" href="README.Nary.html#9775" class="Bound">f</a> <a id="9798" href="README.Nary.html#9779" class="Bound">a</a><a id="9799" class="Symbol">)</a>

<a id="compose₁-eq"></a><a id="9802" href="README.Nary.html#9802" class="Function">compose₁-eq</a> <a id="9814" class="Symbol">:</a> <a id="9816" href="README.Nary.html#9553" class="Function">compose₁</a> <a id="9825" class="Symbol">{</a><a id="9826" href="README.Nary.html#838" class="Generalizable">a</a><a id="9827" class="Symbol">}</a> <a id="9829" class="Symbol">{</a><a id="9830" href="README.Nary.html#860" class="Generalizable">A</a><a id="9831" class="Symbol">}</a> <a id="9833" class="Symbol">{</a><a id="9834" href="README.Nary.html#840" class="Generalizable">b</a><a id="9835" class="Symbol">}</a> <a id="9837" class="Symbol">{</a><a id="9838" href="README.Nary.html#874" class="Generalizable">B</a><a id="9839" class="Symbol">}</a> <a id="9841" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="9843" href="README.Nary.html#9728" class="Function">compose₁′</a>
<a id="9853" href="README.Nary.html#9802" class="Function">compose₁-eq</a> <a id="9865" class="Symbol">=</a> <a id="9867" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="9873" class="Comment">-----------------------------------------------------------------------</a>
<a id="9945" class="Comment">-- _∷=_⊢_ : ∀ n → A → (A₁ → ⋯ Aₙ → A → B) → A₁ → ⋯ → Aₙ → B</a>

<a id="10006" class="Comment">-- Partial application usually focuses on the first argument of a function.</a>
<a id="10082" class="Comment">-- We can now partially apply a function in any of its arguments using</a>
<a id="10153" class="Comment">-- `_∷=_⊢_`. Reusing our example involving replicate: we can specialise it</a>
<a id="10228" class="Comment">-- to only output finite lists of `0`:</a>

<a id="apply₁"></a><a id="10268" href="README.Nary.html#10268" class="Function">apply₁</a> <a id="10275" class="Symbol">:</a> <a id="10277" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="10279" class="Symbol">→</a> <a id="10281" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="10286" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="10288" href="README.Nary.html#10268" class="Function">apply₁</a> <a id="10295" class="Symbol">=</a> <a id="10297" class="Number">1</a> <a id="10299" href="Function.Nary.NonDependent.Base.html#4040" class="Function Operator">∷=</a> <a id="10302" class="Number">0</a> <a id="10304" href="Function.Nary.NonDependent.Base.html#4040" class="Function Operator">⊢</a> <a id="10306" href="Data.List.Base.html#5347" class="Function">replicate</a>

<a id="apply₁-eq"></a><a id="10317" href="README.Nary.html#10317" class="Function">apply₁-eq</a> <a id="10327" class="Symbol">:</a> <a id="10329" href="README.Nary.html#10268" class="Function">apply₁</a> <a id="10336" class="Number">3</a> <a id="10338" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="10340" class="Number">0</a> <a id="10342" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10344" class="Number">0</a> <a id="10346" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10348" class="Number">0</a> <a id="10350" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10352" class="InductiveConstructor">[]</a>
<a id="10355" href="README.Nary.html#10317" class="Function">apply₁-eq</a> <a id="10365" class="Symbol">=</a> <a id="10367" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="10373" class="Comment">------------------------------------------------------------------------</a>
<a id="10446" class="Comment">-- holeₙ : ∀ n → (A → (A₁ → ⋯ Aₙ → B)) → A₁ → ⋯ → Aₙ → (A → B)</a>

<a id="10510" class="Comment">-- As we have seen earlier, `cong` acts on a function&#39;s first variable.</a>
<a id="10582" class="Comment">-- If we want to access the second one, we can use `flip`. But what about</a>
<a id="10656" class="Comment">-- the fourth one? We typically use an explicit λ-abstraction shuffling</a>
<a id="10728" class="Comment">-- variables. Not anymore.</a>

<a id="10756" class="Comment">-- Reusing mod-helper just because it takes a lot of arguments:</a>

<a id="hole₁"></a><a id="10821" href="README.Nary.html#10821" class="Function">hole₁</a> <a id="10827" class="Symbol">:</a> <a id="10829" class="Symbol">∀</a> <a id="10831" href="README.Nary.html#10831" class="Bound">k</a> <a id="10833" href="README.Nary.html#10833" class="Bound">m</a> <a id="10835" href="README.Nary.html#10835" class="Bound">n</a> <a id="10837" href="README.Nary.html#10837" class="Bound">j</a> <a id="10839" class="Symbol">→</a> <a id="10841" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10852" href="README.Nary.html#10831" class="Bound">k</a> <a id="10854" class="Symbol">(</a><a id="10855" href="README.Nary.html#10833" class="Bound">m</a> <a id="10857" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="10859" class="Number">1</a><a id="10860" class="Symbol">)</a> <a id="10862" href="README.Nary.html#10835" class="Bound">n</a> <a id="10864" href="README.Nary.html#10837" class="Bound">j</a> <a id="10866" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="10868" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10879" href="README.Nary.html#10831" class="Bound">k</a> <a id="10881" class="Symbol">(</a><a id="10882" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="10886" href="README.Nary.html#10833" class="Bound">m</a><a id="10887" class="Symbol">)</a> <a id="10889" href="README.Nary.html#10835" class="Bound">n</a> <a id="10891" href="README.Nary.html#10837" class="Bound">j</a>
<a id="10893" href="README.Nary.html#10821" class="Function">hole₁</a> <a id="10899" class="Symbol">=</a> <a id="10901" class="Symbol">λ</a> <a id="10903" href="README.Nary.html#10903" class="Bound">k</a> <a id="10905" href="README.Nary.html#10905" class="Bound">m</a> <a id="10907" href="README.Nary.html#10907" class="Bound">n</a> <a id="10909" href="README.Nary.html#10909" class="Bound">j</a> <a id="10911" class="Symbol">→</a> <a id="10913" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="10918" class="Symbol">(</a><a id="10919" href="Function.Nary.NonDependent.Base.html#4164" class="Function">holeₙ</a> <a id="10925" class="Number">2</a> <a id="10927" class="Symbol">(</a><a id="10928" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10939" href="README.Nary.html#10903" class="Bound">k</a><a id="10940" class="Symbol">)</a> <a id="10942" href="README.Nary.html#10907" class="Bound">n</a> <a id="10944" href="README.Nary.html#10909" class="Bound">j</a><a id="10945" class="Symbol">)</a> <a id="10947" class="Symbol">(</a><a id="10948" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="10955" href="README.Nary.html#10905" class="Bound">m</a> <a id="10957" class="Number">1</a><a id="10958" class="Symbol">)</a>

<a id="10961" class="Comment">-----------------------------------------------------------------------</a>
<a id="11033" class="Comment">-- mapₙ : ∀ n → (B → C) → (A₁ → ⋯ Aₙ → B) → (A₁ → ⋯ → Aₙ → C)</a>

<a id="11096" class="Comment">-- (R →_) gives us the reader monad (and, a fortiori, functor). That is to</a>
<a id="11171" class="Comment">-- say that given a function (A → B) and an (R → A) we can get an (R → B)</a>
<a id="11245" class="Comment">-- This generalises to n-ary functions.</a>

<a id="11286" class="Comment">-- Reusing our `composeₙ` example: instead of applying `f` to the replicated</a>
<a id="11363" class="Comment">-- element, we can map it on the resulting list. Giving us:</a>

<a id="map₁"></a><a id="11424" href="README.Nary.html#11424" class="Function">map₁</a> <a id="11429" class="Symbol">:</a> <a id="11431" class="Symbol">(</a><a id="11432" href="README.Nary.html#860" class="Generalizable">A</a> <a id="11434" class="Symbol">→</a> <a id="11436" href="README.Nary.html#874" class="Generalizable">B</a><a id="11437" class="Symbol">)</a> <a id="11439" class="Symbol">→</a> <a id="11441" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="11443" class="Symbol">→</a> <a id="11445" href="README.Nary.html#860" class="Generalizable">A</a> <a id="11447" class="Symbol">→</a> <a id="11449" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="11454" href="README.Nary.html#874" class="Generalizable">B</a>
<a id="11456" href="README.Nary.html#11424" class="Function">map₁</a> <a id="11461" href="README.Nary.html#11461" class="Bound">f</a> <a id="11463" class="Symbol">=</a> <a id="11465" href="Function.Nary.NonDependent.Base.html#3692" class="Function">mapₙ</a> <a id="11470" class="Number">2</a> <a id="11472" class="Symbol">(</a><a id="11473" href="Data.List.Base.html#1620" class="Function">map</a> <a id="11477" href="README.Nary.html#11461" class="Bound">f</a><a id="11478" class="Symbol">)</a> <a id="11480" href="Data.List.Base.html#5347" class="Function">replicate</a>

<a id="11491" class="Comment">------------------------------------------------------------------------</a>
<a id="11564" class="Comment">-- constₙ : ∀ n → B → A₁ → ⋯ → Aₙ → B</a>

<a id="11603" class="Comment">-- `const` is basically `pure` for the reader monad discussed above. Just</a>
<a id="11677" class="Comment">-- like we can generalise the functorial action corresponding to the reader</a>
<a id="11753" class="Comment">-- functor to n-ary functions, we can do the same for `pure`.</a>

<a id="const₁"></a><a id="11816" href="README.Nary.html#11816" class="Function">const₁</a> <a id="11823" class="Symbol">:</a> <a id="11825" href="README.Nary.html#860" class="Generalizable">A</a> <a id="11827" class="Symbol">→</a> <a id="11829" href="README.Nary.html#874" class="Generalizable">B</a> <a id="11831" class="Symbol">→</a> <a id="11833" href="README.Nary.html#888" class="Generalizable">C</a> <a id="11835" class="Symbol">→</a> <a id="11837" href="README.Nary.html#902" class="Generalizable">D</a> <a id="11839" class="Symbol">→</a> <a id="11841" href="README.Nary.html#916" class="Generalizable">E</a> <a id="11843" class="Symbol">→</a> <a id="11845" href="README.Nary.html#860" class="Generalizable">A</a>
<a id="11847" href="README.Nary.html#11816" class="Function">const₁</a> <a id="11854" class="Symbol">=</a> <a id="11856" href="Function.Nary.NonDependent.Base.html#4546" class="Function">constₙ</a> <a id="11863" class="Number">4</a>

<a id="11866" class="Comment">-- Together with `holeₙ`, this means we can make a constant function out</a>
<a id="11939" class="Comment">-- of any of the arguments. The fourth for instance:</a>

<a id="const₂"></a><a id="11993" href="README.Nary.html#11993" class="Function">const₂</a> <a id="12000" class="Symbol">:</a> <a id="12002" href="README.Nary.html#860" class="Generalizable">A</a> <a id="12004" class="Symbol">→</a> <a id="12006" href="README.Nary.html#874" class="Generalizable">B</a> <a id="12008" class="Symbol">→</a> <a id="12010" href="README.Nary.html#888" class="Generalizable">C</a> <a id="12012" class="Symbol">→</a> <a id="12014" href="README.Nary.html#902" class="Generalizable">D</a> <a id="12016" class="Symbol">→</a> <a id="12018" href="README.Nary.html#916" class="Generalizable">E</a> <a id="12020" class="Symbol">→</a> <a id="12022" href="README.Nary.html#902" class="Generalizable">D</a>
<a id="12024" href="README.Nary.html#11993" class="Function">const₂</a> <a id="12031" class="Symbol">=</a> <a id="12033" href="Function.Nary.NonDependent.Base.html#4164" class="Function">holeₙ</a> <a id="12039" class="Number">3</a> <a id="12041" class="Symbol">(</a><a id="12042" href="Function.Nary.NonDependent.Base.html#4546" class="Function">constₙ</a> <a id="12049" class="Number">4</a><a id="12050" class="Symbol">)</a>

<a id="12053" class="Comment">------------------------------------------------------------------------</a>
<a id="12126" class="Comment">-- Generalised quantifiers</a>
<a id="12153" class="Comment">------------------------------------------------------------------------</a>

<a id="12227" class="Comment">-- As we have seen multiple times already, one of the advantages of working</a>
<a id="12303" class="Comment">-- with non-dependent products is that they can be easily inferred. This is</a>
<a id="12379" class="Comment">-- a prime opportunity to define generic quantifiers.</a>

<a id="12434" class="Comment">-- And because n-ary relations are Set-terminated, there is no ambiguity</a>
<a id="12507" class="Comment">-- where to split between arguments &amp; codomain. As a consequence Agda can</a>
<a id="12581" class="Comment">-- infer even `n`, the number of arguments. We can use notations which are</a>
<a id="12656" class="Comment">-- just like the ones defined in `Relation.Unary`.</a>

<a id="12708" class="Comment">------------------------------------------------------------------------</a>
<a id="12781" class="Comment">-- ∃⟨_⟩ : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="12821" class="Comment">-- ∃⟨ P ⟩ = ∃ λ a₁ → ⋯ → ∃ λ aₙ → P a₁ ⋯ aₙ</a>

<a id="12866" class="Comment">-- Returning to our favourite function taking a lot of arguments: we can</a>
<a id="12939" class="Comment">-- find a set of input for which it evaluates to 666</a>

<a id="exist₁"></a><a id="12993" href="README.Nary.html#12993" class="Function">exist₁</a> <a id="13000" class="Symbol">:</a> <a id="13002" href="Relation.Nary.html#2380" class="Function Operator">∃⟨</a> <a id="13005" class="Symbol">(λ</a> <a id="13008" href="README.Nary.html#13008" class="Bound">k</a> <a id="13010" href="README.Nary.html#13010" class="Bound">m</a> <a id="13012" href="README.Nary.html#13012" class="Bound">n</a> <a id="13014" href="README.Nary.html#13014" class="Bound">j</a> <a id="13016" class="Symbol">→</a> <a id="13018" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="13029" href="README.Nary.html#13008" class="Bound">k</a> <a id="13031" href="README.Nary.html#13010" class="Bound">m</a> <a id="13033" href="README.Nary.html#13012" class="Bound">n</a> <a id="13035" href="README.Nary.html#13014" class="Bound">j</a> <a id="13037" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13039" class="Number">666</a><a id="13042" class="Symbol">)</a> <a id="13044" href="Relation.Nary.html#2380" class="Function Operator">⟩</a>
<a id="13046" href="README.Nary.html#12993" class="Function">exist₁</a> <a id="13053" class="Symbol">=</a> <a id="13055" class="Number">19</a> <a id="13058" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13060" class="Number">793</a> <a id="13064" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13066" class="Number">3059</a> <a id="13071" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13073" class="Number">10</a> <a id="13076" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13078" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="13084" class="Comment">------------------------------------------------------------------------</a>
<a id="13157" class="Comment">-- ∀[_] : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13197" class="Comment">-- ∀[_] P = ∀ {a₁} → ⋯ → ∀ {aₙ} → P a₁ ⋯ aₙ</a>

<a id="all₁"></a><a id="13242" href="README.Nary.html#13242" class="Function">all₁</a> <a id="13247" class="Symbol">:</a> <a id="13249" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="13252" class="Symbol">(λ</a> <a id="13255" class="Symbol">(</a><a id="13256" href="README.Nary.html#13256" class="Bound">a₁</a> <a id="13259" href="README.Nary.html#13259" class="Bound">a₂</a> <a id="13262" class="Symbol">:</a> <a id="13264" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13265" class="Symbol">)</a> <a id="13267" class="Symbol">→</a> <a id="13269" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="13273" class="Symbol">(</a><a id="13274" href="README.Nary.html#13256" class="Bound">a₁</a> <a id="13277" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13279" href="README.Nary.html#13259" class="Bound">a₂</a><a id="13281" class="Symbol">))</a> <a id="13284" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="13286" href="README.Nary.html#13242" class="Function">all₁</a> <a id="13291" class="Symbol">{</a><a id="13292" href="README.Nary.html#13292" class="Bound">a₁</a><a id="13294" class="Symbol">}</a> <a id="13296" class="Symbol">{</a><a id="13297" href="README.Nary.html#13297" class="Bound">a₂</a><a id="13299" class="Symbol">}</a> <a id="13301" class="Symbol">=</a> <a id="13303" href="README.Nary.html#13292" class="Bound">a₁</a> <a id="13306" href="Data.Nat.Properties.html#2947" class="Function Operator">≟</a> <a id="13308" href="README.Nary.html#13297" class="Bound">a₂</a>

<a id="13312" class="Comment">------------------------------------------------------------------------</a>
<a id="13385" class="Comment">-- Π : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13422" class="Comment">-- Π P = ∀ a₁ → ⋯ → ∀ aₙ → P a₁ ⋯ aₙ</a>

<a id="all₂"></a><a id="13460" href="README.Nary.html#13460" class="Function">all₂</a> <a id="13465" class="Symbol">:</a> <a id="13467" href="Relation.Nary.html#2519" class="Function Operator">Π[</a> <a id="13470" class="Symbol">(λ</a> <a id="13473" class="Symbol">(</a><a id="13474" href="README.Nary.html#13474" class="Bound">a₁</a> <a id="13477" href="README.Nary.html#13477" class="Bound">a₂</a> <a id="13480" class="Symbol">:</a> <a id="13482" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13483" class="Symbol">)</a> <a id="13485" class="Symbol">→</a> <a id="13487" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="13491" class="Symbol">(</a><a id="13492" href="README.Nary.html#13474" class="Bound">a₁</a> <a id="13495" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13497" href="README.Nary.html#13477" class="Bound">a₂</a><a id="13499" class="Symbol">))</a> <a id="13502" href="Relation.Nary.html#2519" class="Function Operator">]</a>
<a id="13504" href="README.Nary.html#13460" class="Function">all₂</a> <a id="13509" class="Symbol">=</a> <a id="13511" href="Data.Nat.Properties.html#2947" class="Function Operator">_≟_</a>

<a id="13516" class="Comment">------------------------------------------------------------------------</a>
<a id="13589" class="Comment">-- _⇒_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13668" class="Comment">-- P ⇒ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ → Q a₁ ⋯ aₙ</a>

<a id="antisym"></a><a id="13720" href="README.Nary.html#13720" class="Function">antisym</a> <a id="13728" class="Symbol">:</a> <a id="13730" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="13733" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="13737" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="13739" href="Data.Nat.Base.html#1903" class="Function Operator">_≥_</a> <a id="13743" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="13745" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a> <a id="13749" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="13751" href="README.Nary.html#13720" class="Function">antisym</a> <a id="13759" class="Symbol">=</a> <a id="13761" href="Data.Nat.Properties.html#4980" class="Function">≤-antisym</a>

<a id="13772" class="Comment">------------------------------------------------------------------------</a>
<a id="13845" class="Comment">-- _∪_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13924" class="Comment">-- P ∪ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ ⊎ Q a₁ ⋯ aₙ</a>

<a id="≤-&gt;-connex"></a><a id="13976" href="README.Nary.html#13976" class="Function">≤-&gt;-connex</a> <a id="13987" class="Symbol">:</a> <a id="13989" href="Relation.Nary.html#2519" class="Function Operator">Π[</a> <a id="13992" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="13996" href="Relation.Nary.html#5345" class="Function Operator">∪</a> <a id="13998" href="Data.Nat.Base.html#1933" class="Function Operator">_&gt;_</a> <a id="14002" href="Relation.Nary.html#2519" class="Function Operator">]</a>
<a id="14004" href="README.Nary.html#13976" class="Function">≤-&gt;-connex</a> <a id="14015" href="README.Nary.html#14015" class="Bound">m</a> <a id="14017" href="README.Nary.html#14017" class="Bound">n</a> <a id="14019" class="Keyword">with</a> <a id="14024" href="Data.Nat.Properties.html#10339" class="Function">&lt;-cmp</a> <a id="14030" href="README.Nary.html#14015" class="Bound">m</a> <a id="14032" href="README.Nary.html#14017" class="Bound">n</a>
<a id="14034" class="Symbol">...</a> <a id="14038" class="Symbol">|</a> <a id="14040" href="Relation.Binary.Definitions.html#2857" class="InductiveConstructor">tri&lt;</a> <a id="14045" href="README.Nary.html#14045" class="Bound">a</a> <a id="14047" href="README.Nary.html#14047" class="Bound">¬b</a> <a id="14050" href="README.Nary.html#14050" class="Bound">¬c</a> <a id="14053" class="Symbol">=</a> <a id="14055" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="14060" class="Symbol">(</a><a id="14061" href="Data.Nat.Properties.html#8217" class="Function">&lt;⇒≤</a> <a id="14065" href="README.Nary.html#14045" class="Bound">a</a><a id="14066" class="Symbol">)</a>
<a id="14068" class="Symbol">...</a> <a id="14072" class="Symbol">|</a> <a id="14074" href="Relation.Binary.Definitions.html#2911" class="InductiveConstructor">tri≈</a> <a id="14079" href="README.Nary.html#14079" class="Bound">¬a</a> <a id="14082" href="README.Nary.html#14082" class="Bound">b</a> <a id="14084" href="README.Nary.html#14084" class="Bound">¬c</a> <a id="14087" class="Symbol">=</a> <a id="14089" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="14094" class="Symbol">(</a><a id="14095" href="Data.Nat.Properties.html#4824" class="Function">≤-reflexive</a> <a id="14107" href="README.Nary.html#14082" class="Bound">b</a><a id="14108" class="Symbol">)</a>
<a id="14110" class="Symbol">...</a> <a id="14114" class="Symbol">|</a> <a id="14116" href="Relation.Binary.Definitions.html#2965" class="InductiveConstructor">tri&gt;</a> <a id="14121" href="README.Nary.html#14121" class="Bound">¬a</a> <a id="14124" href="README.Nary.html#14124" class="Bound">¬b</a> <a id="14127" href="README.Nary.html#14127" class="Bound">c</a> <a id="14129" class="Symbol">=</a> <a id="14131" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="14136" href="README.Nary.html#14127" class="Bound">c</a>

<a id="14139" class="Comment">------------------------------------------------------------------------</a>
<a id="14212" class="Comment">-- _∩_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14291" class="Comment">-- P ∩ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ × Q a₁ ⋯ aₙ</a>

<a id="&lt;-inversion"></a><a id="14343" href="README.Nary.html#14343" class="Function">&lt;-inversion</a> <a id="14355" class="Symbol">:</a> <a id="14357" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="14360" href="Data.Nat.Base.html#1654" class="Function Operator">_&lt;_</a> <a id="14364" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="14366" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="14370" href="Relation.Nary.html#5206" class="Function Operator">∩</a> <a id="14372" href="Relation.Binary.PropositionalEquality.Core.html#858" class="Function Operator">_≢_</a> <a id="14376" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="14378" href="README.Nary.html#14343" class="Function">&lt;-inversion</a> <a id="14390" href="README.Nary.html#14390" class="Bound">m&lt;n</a> <a id="14394" class="Symbol">=</a> <a id="14396" href="Data.Nat.Properties.html#8217" class="Function">&lt;⇒≤</a> <a id="14400" href="README.Nary.html#14390" class="Bound">m&lt;n</a> <a id="14404" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="14406" href="Data.Nat.Properties.html#8300" class="Function">&lt;⇒≢</a> <a id="14410" href="README.Nary.html#14390" class="Bound">m&lt;n</a>

<a id="14415" class="Comment">------------------------------------------------------------------------</a>
<a id="14488" class="Comment">-- ∁ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14541" class="Comment">-- ∁ P = λ a₁ → ⋯ → λ aₙ → ¬ (P a₁ ⋯ aₙ)</a>

<a id="m&lt;n⇒m≱n"></a><a id="14583" href="README.Nary.html#14583" class="Function">m&lt;n⇒m≱n</a> <a id="14591" class="Symbol">:</a> <a id="14593" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="14596" href="Data.Nat.Base.html#1933" class="Function Operator">_&gt;_</a> <a id="14600" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="14602" href="Relation.Nary.html#5468" class="Function">∁</a> <a id="14604" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="14608" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="14610" href="README.Nary.html#14583" class="Function">m&lt;n⇒m≱n</a> <a id="14618" href="README.Nary.html#14618" class="Bound">m&gt;n</a> <a id="14622" href="README.Nary.html#14622" class="Bound">m≤n</a> <a id="14626" class="Symbol">=</a> <a id="14628" href="Data.Nat.Properties.html#8432" class="Function">&lt;⇒≱</a> <a id="14632" href="README.Nary.html#14618" class="Bound">m&gt;n</a> <a id="14636" href="README.Nary.html#14622" class="Bound">m≤n</a>
</pre></body></html>