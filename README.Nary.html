<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Nary</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the generic n-ary operations the stdlib provides</a>
<a id="179" class="Comment">-- can be used</a>
<a id="194" class="Comment">------------------------------------------------------------------------</a>

<a id="268" class="Symbol">{-#</a> <a id="272" class="Keyword">OPTIONS</a> <a id="280" class="Pragma">--cubical-compatible</a> <a id="301" class="Pragma">--safe</a> <a id="308" class="Symbol">#-}</a>

<a id="313" class="Keyword">module</a> <a id="320" href="README.Nary.html" class="Module">README.Nary</a> <a id="332" class="Keyword">where</a>

<a id="339" class="Keyword">open</a> <a id="344" class="Keyword">import</a> <a id="351" href="Level.html" class="Module">Level</a> <a id="357" class="Keyword">using</a> <a id="363" class="Symbol">(</a><a id="364" href="Agda.Primitive.html#591" class="Postulate">Level</a><a id="369" class="Symbol">)</a>
<a id="371" class="Keyword">open</a> <a id="376" class="Keyword">import</a> <a id="383" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="397" class="Keyword">open</a> <a id="402" class="Keyword">import</a> <a id="409" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="429" class="Keyword">open</a> <a id="434" class="Keyword">import</a> <a id="441" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="450" class="Keyword">using</a> <a id="456" class="Symbol">(</a><a id="457" href="Data.Fin.Base.html#1312" class="Datatype">Fin</a><a id="460" class="Symbol">;</a> <a id="462" href="Data.Fin.Base.html#2005" class="Function">fromℕ</a><a id="467" class="Symbol">;</a> <a id="469" href="Data.Fin.html#739" class="Function Operator">#_</a><a id="471" class="Symbol">;</a> <a id="473" href="Data.Fin.Base.html#3276" class="Function">inject₁</a><a id="480" class="Symbol">)</a>
<a id="482" class="Keyword">open</a> <a id="487" class="Keyword">import</a> <a id="494" href="Data.List.html" class="Module">Data.List</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Data.List.Properties.html" class="Module">Data.List.Properties</a>
<a id="537" class="Keyword">open</a> <a id="542" class="Keyword">import</a> <a id="549" href="Data.Product.html" class="Module">Data.Product</a> <a id="562" class="Keyword">using</a> <a id="568" class="Symbol">(</a><a id="569" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="572" class="Symbol">;</a> <a id="574" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="577" class="Symbol">)</a>
<a id="579" class="Keyword">open</a> <a id="584" class="Keyword">import</a> <a id="591" href="Data.Sum.Base.html" class="Module">Data.Sum.Base</a> <a id="605" class="Keyword">using</a> <a id="611" class="Symbol">(</a><a id="612" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a><a id="616" class="Symbol">;</a> <a id="618" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a><a id="622" class="Symbol">)</a>
<a id="624" class="Keyword">open</a> <a id="629" class="Keyword">import</a> <a id="636" href="Function.Base.html" class="Module">Function.Base</a> <a id="650" class="Keyword">using</a> <a id="656" class="Symbol">(</a><a id="657" href="Function.Base.html#704" class="Function">id</a><a id="659" class="Symbol">;</a> <a id="661" href="Function.Base.html#1638" class="Function">flip</a><a id="665" class="Symbol">;</a> <a id="667" href="Function.Base.html#3646" class="Function Operator">_∘′_</a><a id="671" class="Symbol">)</a>
<a id="673" class="Keyword">open</a> <a id="678" class="Keyword">import</a> <a id="685" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="702" class="Keyword">open</a> <a id="707" class="Keyword">import</a> <a id="714" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="730" class="Keyword">using</a> <a id="736" class="Symbol">(</a><a id="737" class="Keyword">module</a> <a id="744" href="Relation.Binary.Definitions.html#2791" class="Module">Tri</a><a id="747" class="Symbol">);</a> <a id="750" class="Keyword">open</a> <a id="755" href="Relation.Binary.Definitions.html#2791" class="Module">Tri</a>
<a id="759" class="Keyword">open</a> <a id="764" class="Keyword">import</a> <a id="771" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="810" class="Keyword">private</a>
  <a id="820" class="Keyword">variable</a>
    <a id="833" href="README.Nary.html#833" class="Generalizable">a</a> <a id="835" href="README.Nary.html#835" class="Generalizable">b</a> <a id="837" href="README.Nary.html#837" class="Generalizable">c</a> <a id="839" href="README.Nary.html#839" class="Generalizable">d</a> <a id="841" href="README.Nary.html#841" class="Generalizable">e</a> <a id="843" class="Symbol">:</a> <a id="845" href="Agda.Primitive.html#591" class="Postulate">Level</a>
    <a id="855" href="README.Nary.html#855" class="Generalizable">A</a> <a id="857" class="Symbol">:</a> <a id="859" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="863" href="README.Nary.html#833" class="Generalizable">a</a>
    <a id="869" href="README.Nary.html#869" class="Generalizable">B</a> <a id="871" class="Symbol">:</a> <a id="873" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="877" href="README.Nary.html#835" class="Generalizable">b</a>
    <a id="883" href="README.Nary.html#883" class="Generalizable">C</a> <a id="885" class="Symbol">:</a> <a id="887" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="891" href="README.Nary.html#837" class="Generalizable">c</a>
    <a id="897" href="README.Nary.html#897" class="Generalizable">D</a> <a id="899" class="Symbol">:</a> <a id="901" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="905" href="README.Nary.html#839" class="Generalizable">d</a>
    <a id="911" href="README.Nary.html#911" class="Generalizable">E</a> <a id="913" class="Symbol">:</a> <a id="915" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="919" href="README.Nary.html#841" class="Generalizable">e</a>

<a id="922" class="Comment">------------------------------------------------------------------------</a>
<a id="995" class="Comment">-- Introduction</a>
<a id="1011" class="Comment">------------------------------------------------------------------------</a>

<a id="1085" class="Comment">-- Function.Nary.NonDependent and Data.Product.N-ary.Heterogeneous provide</a>
<a id="1160" class="Comment">-- a generic representation of n-ary heterogeneous (non dependent) products</a>
<a id="1236" class="Comment">-- and the corresponding types of (non-dependent) n-ary functions. The</a>
<a id="1307" class="Comment">-- representation works well with inference thus allowing us to use generic</a>
<a id="1383" class="Comment">-- combinators to manipulate such functions.</a>

<a id="1429" class="Keyword">open</a> <a id="1434" class="Keyword">import</a> <a id="1441" href="Data.Product.Nary.NonDependent.html" class="Module">Data.Product.Nary.NonDependent</a>
<a id="1472" class="Keyword">open</a> <a id="1477" class="Keyword">import</a> <a id="1484" href="Function.Nary.NonDependent.html" class="Module">Function.Nary.NonDependent</a>
<a id="1511" class="Keyword">open</a> <a id="1516" class="Keyword">import</a> <a id="1523" href="Relation.Nary.html" class="Module">Relation.Nary</a>


<a id="1539" class="Comment">------------------------------------------------------------------------</a>
<a id="1612" class="Comment">-- Generalised equality-manipulating combinators</a>
<a id="1661" class="Comment">------------------------------------------------------------------------</a>

<a id="1735" class="Comment">-- By default the standard library provides users with (we are leaving out</a>
<a id="1810" class="Comment">-- the implicit arguments here):</a>
<a id="1843" class="Comment">--</a>
<a id="1846" class="Comment">-- cong   : (f : A₁      → B) → a₁ ≡ b₁           → f a₁   ≡ f b₁</a>
<a id="1912" class="Comment">-- cong₂  : (f : A₁ → A₂ → B) → a₁ ≡ b₁ → a₂ ≡ b₂ → f a₁ a₂ ≡ f b₁ b₂</a>
<a id="1982" class="Comment">--</a>
<a id="1985" class="Comment">-- and</a>
<a id="1992" class="Comment">--</a>
<a id="1995" class="Comment">-- subst  : (P : A₁      → Set p) → a₁ ≡ b₁           → P a₁    → P b₁</a>
<a id="2066" class="Comment">-- subst₂ : (P : A₁ → A₂ → Set p) → a₁ ≡ b₁ → a₂ ≡ b₂ → P a₁ a₂ → P b₁ b₂</a>
<a id="2140" class="Comment">--</a>
<a id="2143" class="Comment">-- This pattern can be generalised to any natural number `n`. Thanks to our</a>
<a id="2219" class="Comment">-- library for n-ary functions, we can write the types and implementations</a>
<a id="2294" class="Comment">-- of `congₙ` and `substₙ`.</a>

<a id="2323" class="Comment">------------------------------------------------------------------------</a>
<a id="2396" class="Comment">-- congₙ : ∀ n (f : A₁ → ⋯ → Aₙ → B) →</a>
<a id="2435" class="Comment">--         a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → f a₁ ⋯ aₙ ≡ f b₁ ⋯ bₙ</a>

<a id="2491" class="Comment">-- It may be used directly to prove something:</a>

<a id="2539" href="README.Nary.html#2539" class="Function">_</a> <a id="2541" class="Symbol">:</a> <a id="2543" class="Symbol">∀</a> <a id="2545" class="Symbol">(</a><a id="2546" href="README.Nary.html#2546" class="Bound">as</a> <a id="2549" href="README.Nary.html#2549" class="Bound">bs</a> <a id="2552" href="README.Nary.html#2552" class="Bound">cs</a> <a id="2555" class="Symbol">:</a> <a id="2557" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="2562" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2563" class="Symbol">)</a> <a id="2565" class="Symbol">→</a>
       <a id="2574" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2578" class="Symbol">(</a><a id="2579" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2583" class="Symbol">(</a><a id="2584" href="README.Nary.html#2546" class="Bound">as</a> <a id="2587" href="Data.List.Base.html#1943" class="Function Operator">++</a> <a id="2590" class="InductiveConstructor">[]</a><a id="2592" class="Symbol">)</a> <a id="2594" class="Symbol">(</a><a id="2595" href="Data.List.Base.html#1620" class="Function">map</a> <a id="2599" href="Function.Base.html#704" class="Function">id</a> <a id="2602" href="README.Nary.html#2552" class="Bound">cs</a><a id="2604" class="Symbol">))</a> <a id="2607" class="Symbol">(</a><a id="2608" href="Data.List.Base.html#7001" class="Function">reverse</a> <a id="2616" class="Symbol">(</a><a id="2617" href="Data.List.Base.html#7001" class="Function">reverse</a> <a id="2625" href="README.Nary.html#2549" class="Bound">bs</a><a id="2627" class="Symbol">))</a>
     <a id="2635" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2637" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2641" class="Symbol">(</a><a id="2642" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2646" href="README.Nary.html#2546" class="Bound">as</a> <a id="2649" href="README.Nary.html#2552" class="Bound">cs</a><a id="2651" class="Symbol">)</a> <a id="2653" href="README.Nary.html#2549" class="Bound">bs</a>
<a id="2656" class="Symbol">_</a> <a id="2658" class="Symbol">=</a> <a id="2660" class="Symbol">λ</a> <a id="2662" href="README.Nary.html#2662" class="Bound">as</a> <a id="2665" href="README.Nary.html#2665" class="Bound">bs</a> <a id="2668" href="README.Nary.html#2668" class="Bound">cs</a> <a id="2671" class="Symbol">→</a> <a id="2673" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="2679" class="Number">3</a> <a id="2681" class="Symbol">(λ</a> <a id="2684" href="README.Nary.html#2684" class="Bound">as</a> <a id="2687" href="README.Nary.html#2687" class="Bound">bs</a> <a id="2690" class="Symbol">→</a> <a id="2692" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2696" class="Symbol">(</a><a id="2697" href="Data.List.Base.html#3703" class="Function">zip</a> <a id="2701" href="README.Nary.html#2684" class="Bound">as</a> <a id="2704" href="README.Nary.html#2687" class="Bound">bs</a><a id="2706" class="Symbol">))</a>
                         <a id="2734" class="Symbol">(</a><a id="2735" href="Data.List.Properties.html#5883" class="Function">++-identityʳ</a> <a id="2748" href="README.Nary.html#2662" class="Bound">as</a><a id="2750" class="Symbol">)</a>
                         <a id="2777" class="Symbol">(</a><a id="2778" href="Data.List.Properties.html#3138" class="Function">map-id</a> <a id="2785" href="README.Nary.html#2668" class="Bound">cs</a><a id="2787" class="Symbol">)</a>
                         <a id="2814" class="Symbol">(</a><a id="2815" href="Data.List.Properties.html#39530" class="Function">reverse-involutive</a> <a id="2834" href="README.Nary.html#2665" class="Bound">bs</a><a id="2836" class="Symbol">)</a>

<a id="2839" class="Comment">-- Or as part of a longer derivation:</a>

<a id="2878" href="README.Nary.html#2878" class="Function">_</a> <a id="2880" class="Symbol">:</a> <a id="2882" class="Symbol">∀</a> <a id="2884" href="README.Nary.html#2884" class="Bound">m</a> <a id="2886" href="README.Nary.html#2886" class="Bound">n</a> <a id="2888" href="README.Nary.html#2888" class="Bound">p</a> <a id="2890" href="README.Nary.html#2890" class="Bound">q</a> <a id="2892" class="Symbol">→</a> <a id="2894" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2898" class="Symbol">(</a><a id="2899" href="README.Nary.html#2884" class="Bound">m</a> <a id="2901" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2903" class="Symbol">(</a><a id="2904" href="README.Nary.html#2888" class="Bound">p</a> <a id="2906" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2908" href="README.Nary.html#2886" class="Bound">n</a><a id="2909" class="Symbol">)</a> <a id="2911" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2913" class="Symbol">(</a><a id="2914" href="README.Nary.html#2890" class="Bound">q</a> <a id="2916" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="2918" class="Symbol">(</a><a id="2919" href="README.Nary.html#2884" class="Bound">m</a> <a id="2921" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2923" href="README.Nary.html#2886" class="Bound">n</a><a id="2924" class="Symbol">)))</a>
              <a id="2942" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2944" class="Symbol">(</a><a id="2945" href="README.Nary.html#2884" class="Bound">m</a> <a id="2947" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2949" class="Number">0</a><a id="2950" class="Symbol">)</a> <a id="2952" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2954" class="Symbol">(</a><a id="2955" href="README.Nary.html#2886" class="Bound">n</a> <a id="2957" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2959" href="README.Nary.html#2888" class="Bound">p</a><a id="2960" class="Symbol">)</a> <a id="2962" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2964" class="Symbol">(</a><a id="2965" href="README.Nary.html#2890" class="Bound">q</a> <a id="2967" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="2969" href="README.Nary.html#2884" class="Bound">m</a> <a id="2971" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2973" href="README.Nary.html#2890" class="Bound">q</a> <a id="2975" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="2977" href="README.Nary.html#2886" class="Bound">n</a><a id="2978" class="Symbol">)</a> <a id="2980" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2982" class="Number">1</a>
<a id="2984" class="Symbol">_</a> <a id="2986" class="Symbol">=</a> <a id="2988" class="Symbol">λ</a> <a id="2990" href="README.Nary.html#2990" class="Bound">m</a> <a id="2992" href="README.Nary.html#2992" class="Bound">n</a> <a id="2994" href="README.Nary.html#2994" class="Bound">p</a> <a id="2996" href="README.Nary.html#2996" class="Bound">q</a> <a id="2998" class="Symbol">→</a> <a id="3000" href="Relation.Binary.PropositionalEquality.Core.html#2834" class="Function Operator">begin</a>
    <a id="3010" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="3014" class="Symbol">(</a><a id="3015" href="README.Nary.html#2990" class="Bound">m</a> <a id="3017" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3019" class="Symbol">(</a><a id="3020" href="README.Nary.html#2994" class="Bound">p</a> <a id="3022" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3024" href="README.Nary.html#2992" class="Bound">n</a><a id="3025" class="Symbol">)</a> <a id="3027" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3029" class="Symbol">(</a><a id="3030" href="README.Nary.html#2996" class="Bound">q</a> <a id="3032" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3034" class="Symbol">(</a><a id="3035" href="README.Nary.html#2990" class="Bound">m</a> <a id="3037" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3039" href="README.Nary.html#2992" class="Bound">n</a><a id="3040" class="Symbol">)))</a> <a id="3044" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">≡⟨</a> <a id="3047" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="3054" class="Number">1</a> <a id="3056" class="Symbol">_</a> <a id="3058" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">⟩</a>
    <a id="3064" href="README.Nary.html#2990" class="Bound">m</a> <a id="3066" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3068" class="Symbol">(</a><a id="3069" href="README.Nary.html#2994" class="Bound">p</a> <a id="3071" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3073" href="README.Nary.html#2992" class="Bound">n</a><a id="3074" class="Symbol">)</a> <a id="3076" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3078" class="Symbol">(</a><a id="3079" href="README.Nary.html#2996" class="Bound">q</a> <a id="3081" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3083" class="Symbol">(</a><a id="3084" href="README.Nary.html#2990" class="Bound">m</a> <a id="3086" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3088" href="README.Nary.html#2992" class="Bound">n</a><a id="3089" class="Symbol">))</a> <a id="3092" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3094" class="Number">1</a>   <a id="3098" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">≡⟨</a> <a id="3101" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="3107" class="Number">3</a> <a id="3109" class="Symbol">(λ</a> <a id="3112" href="README.Nary.html#3112" class="Bound">m</a> <a id="3114" href="README.Nary.html#3114" class="Bound">n</a> <a id="3116" href="README.Nary.html#3116" class="Bound">p</a> <a id="3118" class="Symbol">→</a> <a id="3120" href="README.Nary.html#3112" class="Bound">m</a> <a id="3122" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3124" href="README.Nary.html#3114" class="Bound">n</a> <a id="3126" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3128" href="README.Nary.html#3116" class="Bound">p</a> <a id="3130" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3132" class="Number">1</a><a id="3133" class="Symbol">)</a>
                                                 <a id="3184" class="Symbol">(</a><a id="3185" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="3192" class="Number">0</a> <a id="3194" href="README.Nary.html#2990" class="Bound">m</a><a id="3195" class="Symbol">)</a>
                                                 <a id="3246" class="Symbol">(</a><a id="3247" href="Data.Nat.Properties.html#21339" class="Function">*-comm</a> <a id="3254" href="README.Nary.html#2994" class="Bound">p</a> <a id="3256" href="README.Nary.html#2992" class="Bound">n</a><a id="3257" class="Symbol">)</a>
                                                 <a id="3308" class="Symbol">(</a><a id="3309" href="Data.Nat.Properties.html#28849" class="Function">^-distribˡ-+-*</a> <a id="3324" href="README.Nary.html#2996" class="Bound">q</a> <a id="3326" href="README.Nary.html#2990" class="Bound">m</a> <a id="3328" href="README.Nary.html#2992" class="Bound">n</a><a id="3329" class="Symbol">)</a>
                                       <a id="3370" href="Relation.Binary.PropositionalEquality.Core.html#2951" class="Function">⟩</a>
    <a id="3376" href="README.Nary.html#2990" class="Bound">m</a> <a id="3378" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3380" class="Number">0</a> <a id="3382" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3384" href="README.Nary.html#2992" class="Bound">n</a> <a id="3386" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3388" href="README.Nary.html#2994" class="Bound">p</a> <a id="3390" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3392" class="Symbol">(</a><a id="3393" href="README.Nary.html#2996" class="Bound">q</a> <a id="3395" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3397" href="README.Nary.html#2990" class="Bound">m</a><a id="3398" class="Symbol">)</a> <a id="3400" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3402" class="Symbol">(</a><a id="3403" href="README.Nary.html#2996" class="Bound">q</a> <a id="3405" href="Data.Nat.Base.html#4575" class="Function Operator">^</a> <a id="3407" href="README.Nary.html#2992" class="Bound">n</a><a id="3408" class="Symbol">)</a> <a id="3410" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3412" class="Number">1</a> <a id="3414" href="Relation.Binary.PropositionalEquality.Core.html#3133" class="Function Operator">∎</a> <a id="3416" class="Keyword">where</a> <a id="3422" class="Keyword">open</a> <a id="3427" href="Relation.Binary.PropositionalEquality.Core.html#2736" class="Module">≡-Reasoning</a>

<a id="3440" class="Comment">-- Partial application of the functional argument is fine: the number of arguments</a>
<a id="3523" class="Comment">-- `congₙ` is going to take is determined by its first argument (a natural number)</a>
<a id="3606" class="Comment">-- and not by the type of the function it works on.</a>

<a id="3659" href="README.Nary.html#3659" class="Function">_</a> <a id="3661" class="Symbol">:</a> <a id="3663" class="Symbol">∀</a> <a id="3665" href="README.Nary.html#3665" class="Bound">m</a> <a id="3667" class="Symbol">→</a> <a id="3669" class="Symbol">(</a><a id="3670" href="README.Nary.html#3665" class="Bound">m</a> <a id="3672" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+_</a><a id="3674" class="Symbol">)</a> <a id="3676" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="3678" class="Symbol">((</a><a id="3680" href="README.Nary.html#3665" class="Bound">m</a> <a id="3682" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3684" class="Number">0</a><a id="3685" class="Symbol">)</a> <a id="3687" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+_</a><a id="3689" class="Symbol">)</a>
<a id="3691" class="Symbol">_</a> <a id="3693" class="Symbol">=</a> <a id="3695" class="Symbol">λ</a> <a id="3697" href="README.Nary.html#3697" class="Bound">m</a> <a id="3699" class="Symbol">→</a> <a id="3701" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="3707" class="Number">1</a> <a id="3709" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="3713" class="Symbol">(</a><a id="3714" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="3721" class="Number">0</a> <a id="3723" href="README.Nary.html#3697" class="Bound">m</a><a id="3724" class="Symbol">)</a>

<a id="3727" class="Comment">-- We don&#39;t have to work on the function&#39;s first argument either: we can just as</a>
<a id="3808" class="Comment">-- easily use `congₙ` to act on the second one by `flip`ping it. See `holeₙ` for</a>
<a id="3889" class="Comment">-- a generalisation of this idea allowing to target *any* of the function&#39;s</a>
<a id="3965" class="Comment">-- arguments and not just the first or second one.</a>

<a id="4017" href="README.Nary.html#4017" class="Function">_</a> <a id="4019" class="Symbol">:</a> <a id="4021" class="Symbol">∀</a> <a id="4023" href="README.Nary.html#4023" class="Bound">m</a> <a id="4025" class="Symbol">→</a> <a id="4027" class="Symbol">(</a><a id="4028" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+</a> <a id="4031" href="README.Nary.html#4023" class="Bound">m</a><a id="4032" class="Symbol">)</a> <a id="4034" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4036" class="Symbol">(</a><a id="4037" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+</a> <a id="4040" class="Symbol">(</a><a id="4041" href="README.Nary.html#4023" class="Bound">m</a> <a id="4043" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4045" class="Number">0</a><a id="4046" class="Symbol">))</a>
<a id="4049" class="Symbol">_</a> <a id="4051" class="Symbol">=</a> <a id="4053" class="Symbol">λ</a> <a id="4055" href="README.Nary.html#4055" class="Bound">m</a> <a id="4057" class="Symbol">→</a> <a id="4059" href="Function.Nary.NonDependent.html#2029" class="Function">congₙ</a> <a id="4065" class="Number">1</a> <a id="4067" class="Symbol">(</a><a id="4068" href="Function.Base.html#1638" class="Function">flip</a> <a id="4073" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="4076" class="Symbol">)</a> <a id="4078" class="Symbol">(</a><a id="4079" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4086" class="Number">0</a> <a id="4088" href="README.Nary.html#4055" class="Bound">m</a><a id="4089" class="Symbol">)</a>

<a id="4092" class="Comment">------------------------------------------------------------------------</a>
<a id="4165" class="Comment">-- substₙ : (P : A₁ → ⋯ → Aₙ → Set p) →</a>
<a id="4205" class="Comment">--          a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → P a₁ ⋯ aₙ → P b₁ ⋯ bₙ</a>

<a id="4262" class="Comment">-- We can play the same type of game with subst</a>

<a id="4311" class="Keyword">open</a> <a id="4316" class="Keyword">import</a> <a id="4323" href="Agda.Builtin.Nat.html" class="Module">Agda.Builtin.Nat</a> <a id="4340" class="Keyword">using</a> <a id="4346" class="Symbol">(</a><a id="4347" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a><a id="4357" class="Symbol">)</a>

<a id="4360" class="Comment">-- Because we know from the definition `mod-helper` that this equation holds:</a>
<a id="4438" class="Comment">-- mod-helper k m (suc n) (suc j) = mod-helper (suc k) m n j</a>
<a id="4499" class="Comment">-- we should be able to prove the slightly modified statement by transforming</a>
<a id="4577" class="Comment">-- all the `x + 1` into `suc x`. We can do so using `substₙ`.</a>

<a id="4640" href="README.Nary.html#4640" class="Function">_</a> <a id="4642" class="Symbol">:</a> <a id="4644" class="Symbol">∀</a> <a id="4646" href="README.Nary.html#4646" class="Bound">k</a> <a id="4648" href="README.Nary.html#4648" class="Bound">m</a> <a id="4650" href="README.Nary.html#4650" class="Bound">n</a> <a id="4652" href="README.Nary.html#4652" class="Bound">j</a> <a id="4654" class="Symbol">→</a> <a id="4656" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4667" href="README.Nary.html#4646" class="Bound">k</a> <a id="4669" href="README.Nary.html#4648" class="Bound">m</a> <a id="4671" class="Symbol">(</a><a id="4672" href="README.Nary.html#4650" class="Bound">n</a> <a id="4674" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4676" class="Number">1</a><a id="4677" class="Symbol">)</a> <a id="4679" class="Symbol">(</a><a id="4680" href="README.Nary.html#4652" class="Bound">j</a> <a id="4682" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4684" class="Number">1</a><a id="4685" class="Symbol">)</a> <a id="4687" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4689" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4700" class="Symbol">(</a><a id="4701" href="README.Nary.html#4646" class="Bound">k</a> <a id="4703" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4705" class="Number">1</a><a id="4706" class="Symbol">)</a> <a id="4708" href="README.Nary.html#4648" class="Bound">m</a> <a id="4710" href="README.Nary.html#4650" class="Bound">n</a> <a id="4712" href="README.Nary.html#4652" class="Bound">j</a>
<a id="4714" class="Symbol">_</a> <a id="4716" class="Symbol">=</a> <a id="4718" class="Symbol">λ</a> <a id="4720" href="README.Nary.html#4720" class="Bound">k</a> <a id="4722" href="README.Nary.html#4722" class="Bound">m</a> <a id="4724" href="README.Nary.html#4724" class="Bound">n</a> <a id="4726" href="README.Nary.html#4726" class="Bound">j</a> <a id="4728" class="Symbol">→</a>
    <a id="4734" class="Keyword">let</a> <a id="4738" href="README.Nary.html#4738" class="Bound">P</a> <a id="4740" href="README.Nary.html#4740" class="Bound">sk</a> <a id="4743" href="README.Nary.html#4743" class="Bound">sn</a> <a id="4746" href="README.Nary.html#4746" class="Bound">sj</a> <a id="4749" class="Symbol">=</a> <a id="4751" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4762" href="README.Nary.html#4720" class="Bound">k</a> <a id="4764" href="README.Nary.html#4722" class="Bound">m</a> <a id="4766" href="README.Nary.html#4743" class="Bound">sn</a> <a id="4769" href="README.Nary.html#4746" class="Bound">sj</a> <a id="4772" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4774" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4785" href="README.Nary.html#4740" class="Bound">sk</a> <a id="4788" href="README.Nary.html#4722" class="Bound">m</a> <a id="4790" href="README.Nary.html#4724" class="Bound">n</a> <a id="4792" href="README.Nary.html#4726" class="Bound">j</a>
    <a id="4798" class="Keyword">in</a> <a id="4801" href="Relation.Nary.html#3713" class="Function">substₙ</a> <a id="4808" href="README.Nary.html#4738" class="Bound">P</a> <a id="4810" class="Symbol">(</a><a id="4811" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4818" class="Number">1</a> <a id="4820" href="README.Nary.html#4720" class="Bound">k</a><a id="4821" class="Symbol">)</a> <a id="4823" class="Symbol">(</a><a id="4824" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4831" class="Number">1</a> <a id="4833" href="README.Nary.html#4724" class="Bound">n</a><a id="4834" class="Symbol">)</a> <a id="4836" class="Symbol">(</a><a id="4837" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="4844" class="Number">1</a> <a id="4846" href="README.Nary.html#4726" class="Bound">j</a><a id="4847" class="Symbol">)</a> <a id="4849" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="4855" class="Comment">-----------------------------------------------------------------------</a>
<a id="4927" class="Comment">-- Generic programs working on n-ary products &amp; functions</a>
<a id="4985" class="Comment">-----------------------------------------------------------------------</a>

<a id="5058" class="Comment">-----------------------------------------------------------------------</a>
<a id="5130" class="Comment">-- curryₙ   : ∀ n → (A₁ × ⋯ × Aₙ → B) → A₁ → ⋯ → Aₙ → B</a>
<a id="5186" class="Comment">-- uncurryₙ : ∀ n → (A₁ → ⋯ → Aₙ → B) → A₁ × ⋯ × Aₙ → B</a>

<a id="5243" class="Comment">-- The first thing we may want to do generically is convert between</a>
<a id="5311" class="Comment">-- curried function types and uncurried ones. We can do this by using:</a>

<a id="5383" class="Comment">-- They both work the same way so we will focus on curryₙ only here.</a>
<a id="5452" class="Comment">-- If we pass to `curryₙ` the arity of its argument then we obtain a</a>
<a id="5521" class="Comment">-- fully curried function.</a>

<a id="curry₁"></a><a id="5549" href="README.Nary.html#5549" class="Function">curry₁</a> <a id="5556" class="Symbol">:</a> <a id="5558" class="Symbol">(</a><a id="5559" href="README.Nary.html#855" class="Generalizable">A</a> <a id="5561" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5563" href="README.Nary.html#869" class="Generalizable">B</a> <a id="5565" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5567" href="README.Nary.html#883" class="Generalizable">C</a> <a id="5569" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5571" href="README.Nary.html#897" class="Generalizable">D</a> <a id="5573" class="Symbol">→</a> <a id="5575" href="README.Nary.html#911" class="Generalizable">E</a><a id="5576" class="Symbol">)</a> <a id="5578" class="Symbol">→</a> <a id="5580" href="README.Nary.html#855" class="Generalizable">A</a> <a id="5582" class="Symbol">→</a> <a id="5584" href="README.Nary.html#869" class="Generalizable">B</a> <a id="5586" class="Symbol">→</a> <a id="5588" href="README.Nary.html#883" class="Generalizable">C</a> <a id="5590" class="Symbol">→</a> <a id="5592" href="README.Nary.html#897" class="Generalizable">D</a> <a id="5594" class="Symbol">→</a> <a id="5596" href="README.Nary.html#911" class="Generalizable">E</a>
<a id="5598" href="README.Nary.html#5549" class="Function">curry₁</a> <a id="5605" class="Symbol">=</a> <a id="5607" href="Data.Product.Nary.NonDependent.html#3688" class="Function">curryₙ</a> <a id="5614" class="Number">4</a>

<a id="5617" class="Comment">-- Note that here we are not flattening arbitrary nestings: products have</a>
<a id="5691" class="Comment">-- to be right nested. Which means that if you have a deeply-nested product</a>
<a id="5767" class="Comment">-- then it won&#39;t be affected by the procedure.</a>

<a id="curry₁′"></a><a id="5815" href="README.Nary.html#5815" class="Function">curry₁′</a> <a id="5823" class="Symbol">:</a> <a id="5825" class="Symbol">(</a><a id="5826" href="README.Nary.html#855" class="Generalizable">A</a> <a id="5828" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5830" class="Symbol">(</a><a id="5831" href="README.Nary.html#869" class="Generalizable">B</a> <a id="5833" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5835" href="README.Nary.html#883" class="Generalizable">C</a><a id="5836" class="Symbol">)</a> <a id="5838" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5840" href="README.Nary.html#897" class="Generalizable">D</a> <a id="5842" class="Symbol">→</a> <a id="5844" href="README.Nary.html#911" class="Generalizable">E</a><a id="5845" class="Symbol">)</a> <a id="5847" class="Symbol">→</a> <a id="5849" href="README.Nary.html#855" class="Generalizable">A</a> <a id="5851" class="Symbol">→</a> <a id="5853" class="Symbol">(</a><a id="5854" href="README.Nary.html#869" class="Generalizable">B</a> <a id="5856" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5858" href="README.Nary.html#883" class="Generalizable">C</a><a id="5859" class="Symbol">)</a> <a id="5861" class="Symbol">→</a> <a id="5863" href="README.Nary.html#897" class="Generalizable">D</a> <a id="5865" class="Symbol">→</a> <a id="5867" href="README.Nary.html#911" class="Generalizable">E</a>
<a id="5869" href="README.Nary.html#5815" class="Function">curry₁′</a> <a id="5877" class="Symbol">=</a> <a id="5879" href="Data.Product.Nary.NonDependent.html#3688" class="Function">curryₙ</a> <a id="5886" class="Number">3</a>

<a id="5889" class="Comment">-- When we are currying a function, we have no obligation to pass its exact</a>
<a id="5965" class="Comment">-- arity as the parameter: we can decide to only curry part of it like so:</a>
<a id="6040" class="Comment">-- Indeed (A₁ × ⋯ × Aₙ → B) can also be seen as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ) → B)</a>

<a id="curry₂"></a><a id="6118" href="README.Nary.html#6118" class="Function">curry₂</a> <a id="6125" class="Symbol">:</a> <a id="6127" class="Symbol">(</a><a id="6128" href="README.Nary.html#855" class="Generalizable">A</a> <a id="6130" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6132" href="README.Nary.html#869" class="Generalizable">B</a> <a id="6134" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6136" href="README.Nary.html#883" class="Generalizable">C</a> <a id="6138" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6140" href="README.Nary.html#897" class="Generalizable">D</a> <a id="6142" class="Symbol">→</a> <a id="6144" href="README.Nary.html#911" class="Generalizable">E</a><a id="6145" class="Symbol">)</a> <a id="6147" class="Symbol">→</a> <a id="6149" href="README.Nary.html#855" class="Generalizable">A</a> <a id="6151" class="Symbol">→</a> <a id="6153" href="README.Nary.html#869" class="Generalizable">B</a> <a id="6155" class="Symbol">→</a> <a id="6157" class="Symbol">(</a><a id="6158" href="README.Nary.html#883" class="Generalizable">C</a> <a id="6160" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6162" href="README.Nary.html#897" class="Generalizable">D</a><a id="6163" class="Symbol">)</a> <a id="6165" class="Symbol">→</a> <a id="6167" href="README.Nary.html#911" class="Generalizable">E</a>
<a id="6169" href="README.Nary.html#6118" class="Function">curry₂</a> <a id="6176" class="Symbol">=</a> <a id="6178" href="Data.Product.Nary.NonDependent.html#3688" class="Function">curryₙ</a> <a id="6185" class="Number">3</a>

<a id="6188" class="Comment">-----------------------------------------------------------------------</a>
<a id="6260" class="Comment">-- projₙ : ∀ n (k : Fin n) → (A₁ × ⋯ × Aₙ) → Aₖ₊₁</a>

<a id="6311" class="Comment">-- Another useful class of functions to manipulate n-ary product is a</a>
<a id="6381" class="Comment">-- generic projection function. Note the (k + 1) in the return index:</a>
<a id="6451" class="Comment">-- Fin counts from 0 up.</a>

<a id="6477" class="Comment">-- It behaves as one expects (Data.Fin&#39;s #_ comes in handy to write down</a>
<a id="6550" class="Comment">-- Fin literals):</a>

<a id="proj₃"></a><a id="6569" href="README.Nary.html#6569" class="Function">proj₃</a> <a id="6575" class="Symbol">:</a> <a id="6577" class="Symbol">(</a><a id="6578" href="README.Nary.html#855" class="Generalizable">A</a> <a id="6580" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6582" href="README.Nary.html#869" class="Generalizable">B</a> <a id="6584" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6586" href="README.Nary.html#883" class="Generalizable">C</a> <a id="6588" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6590" href="README.Nary.html#897" class="Generalizable">D</a> <a id="6592" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6594" href="README.Nary.html#911" class="Generalizable">E</a><a id="6595" class="Symbol">)</a> <a id="6597" class="Symbol">→</a> <a id="6599" href="README.Nary.html#883" class="Generalizable">C</a>
<a id="6601" href="README.Nary.html#6569" class="Function">proj₃</a> <a id="6607" class="Symbol">=</a> <a id="6609" href="Data.Product.Nary.NonDependent.html#6482" class="Function">projₙ</a> <a id="6615" class="Number">5</a> <a id="6617" class="Symbol">(</a><a id="6618" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="6620" class="Number">2</a><a id="6621" class="Symbol">)</a>

<a id="6624" class="Comment">-- Of course we can once more project the &quot;tail&quot; of the n-ary product by</a>
<a id="6697" class="Comment">-- passing `projₙ` a natural number which is smaller than the size of the</a>
<a id="6771" class="Comment">-- n-ary product, seeing (A₁ × ⋯ × Aₙ) as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ)).</a>

<a id="proj₃′"></a><a id="6840" href="README.Nary.html#6840" class="Function">proj₃′</a> <a id="6847" class="Symbol">:</a> <a id="6849" class="Symbol">(</a><a id="6850" href="README.Nary.html#855" class="Generalizable">A</a> <a id="6852" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6854" href="README.Nary.html#869" class="Generalizable">B</a> <a id="6856" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6858" href="README.Nary.html#883" class="Generalizable">C</a> <a id="6860" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6862" href="README.Nary.html#897" class="Generalizable">D</a> <a id="6864" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6866" href="README.Nary.html#911" class="Generalizable">E</a><a id="6867" class="Symbol">)</a> <a id="6869" class="Symbol">→</a> <a id="6871" href="README.Nary.html#883" class="Generalizable">C</a> <a id="6873" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6875" href="README.Nary.html#897" class="Generalizable">D</a> <a id="6877" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6879" href="README.Nary.html#911" class="Generalizable">E</a>
<a id="6881" href="README.Nary.html#6840" class="Function">proj₃′</a> <a id="6888" class="Symbol">=</a> <a id="6890" href="Data.Product.Nary.NonDependent.html#6482" class="Function">projₙ</a> <a id="6896" class="Number">3</a> <a id="6898" class="Symbol">(</a><a id="6899" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="6901" class="Number">2</a><a id="6902" class="Symbol">)</a>

<a id="6905" class="Comment">-----------------------------------------------------------------------</a>
<a id="6977" class="Comment">-- insertₙ : ∀ n (k : Fin (suc n)) →</a>
<a id="7014" class="Comment">--           B → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B × Aₖ₊₁ × ⋯ Aₙ)</a>

<a id="insert₁"></a><a id="7078" href="README.Nary.html#7078" class="Function">insert₁</a> <a id="7086" class="Symbol">:</a> <a id="7088" href="README.Nary.html#883" class="Generalizable">C</a> <a id="7090" class="Symbol">→</a> <a id="7092" class="Symbol">(</a><a id="7093" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7095" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7097" href="README.Nary.html#869" class="Generalizable">B</a> <a id="7099" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7101" href="README.Nary.html#897" class="Generalizable">D</a> <a id="7103" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7105" href="README.Nary.html#911" class="Generalizable">E</a><a id="7106" class="Symbol">)</a> <a id="7108" class="Symbol">→</a> <a id="7110" class="Symbol">(</a><a id="7111" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7113" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7115" href="README.Nary.html#869" class="Generalizable">B</a> <a id="7117" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7119" href="README.Nary.html#883" class="Generalizable">C</a> <a id="7121" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7123" href="README.Nary.html#897" class="Generalizable">D</a> <a id="7125" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7127" href="README.Nary.html#911" class="Generalizable">E</a><a id="7128" class="Symbol">)</a>
<a id="7130" href="README.Nary.html#7078" class="Function">insert₁</a> <a id="7138" class="Symbol">=</a> <a id="7140" href="Data.Product.Nary.NonDependent.html#8535" class="Function">insertₙ</a> <a id="7148" class="Number">4</a> <a id="7150" class="Symbol">(</a><a id="7151" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7153" class="Number">2</a><a id="7154" class="Symbol">)</a>

<a id="insert₁′"></a><a id="7157" href="README.Nary.html#7157" class="Function">insert₁′</a> <a id="7166" class="Symbol">:</a> <a id="7168" href="README.Nary.html#883" class="Generalizable">C</a> <a id="7170" class="Symbol">→</a> <a id="7172" class="Symbol">(</a><a id="7173" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7175" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7177" href="README.Nary.html#869" class="Generalizable">B</a> <a id="7179" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7181" href="README.Nary.html#897" class="Generalizable">D</a> <a id="7183" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7185" href="README.Nary.html#911" class="Generalizable">E</a><a id="7186" class="Symbol">)</a> <a id="7188" class="Symbol">→</a> <a id="7190" class="Symbol">(</a><a id="7191" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7193" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7195" href="README.Nary.html#869" class="Generalizable">B</a> <a id="7197" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7199" href="README.Nary.html#883" class="Generalizable">C</a> <a id="7201" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7203" href="README.Nary.html#897" class="Generalizable">D</a> <a id="7205" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7207" href="README.Nary.html#911" class="Generalizable">E</a><a id="7208" class="Symbol">)</a>
<a id="7210" href="README.Nary.html#7157" class="Function">insert₁′</a> <a id="7219" class="Symbol">=</a> <a id="7221" href="Data.Product.Nary.NonDependent.html#8535" class="Function">insertₙ</a> <a id="7229" class="Number">3</a> <a id="7231" class="Symbol">(</a><a id="7232" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7234" class="Number">2</a><a id="7235" class="Symbol">)</a>

<a id="7238" class="Comment">-- Note that `insertₙ` takes a `Fin (suc n)`. Indeed in an n-ary product</a>
<a id="7311" class="Comment">-- there are (suc n) positions at which one may insert a value. We may</a>
<a id="7382" class="Comment">-- insert at the front or the back of the product:</a>

<a id="insert-front"></a><a id="7434" href="README.Nary.html#7434" class="Function">insert-front</a> <a id="7447" class="Symbol">:</a> <a id="7449" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7451" class="Symbol">→</a> <a id="7453" class="Symbol">(</a><a id="7454" href="README.Nary.html#869" class="Generalizable">B</a> <a id="7456" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7458" href="README.Nary.html#883" class="Generalizable">C</a> <a id="7460" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7462" href="README.Nary.html#897" class="Generalizable">D</a> <a id="7464" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7466" href="README.Nary.html#911" class="Generalizable">E</a><a id="7467" class="Symbol">)</a> <a id="7469" class="Symbol">→</a> <a id="7471" class="Symbol">(</a><a id="7472" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7474" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7476" href="README.Nary.html#869" class="Generalizable">B</a> <a id="7478" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7480" href="README.Nary.html#883" class="Generalizable">C</a> <a id="7482" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7484" href="README.Nary.html#897" class="Generalizable">D</a> <a id="7486" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7488" href="README.Nary.html#911" class="Generalizable">E</a><a id="7489" class="Symbol">)</a>
<a id="7491" href="README.Nary.html#7434" class="Function">insert-front</a> <a id="7504" class="Symbol">=</a> <a id="7506" href="Data.Product.Nary.NonDependent.html#8535" class="Function">insertₙ</a> <a id="7514" class="Number">4</a> <a id="7516" class="Symbol">(</a><a id="7517" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7519" class="Number">0</a><a id="7520" class="Symbol">)</a>

<a id="insert-back"></a><a id="7523" href="README.Nary.html#7523" class="Function">insert-back</a> <a id="7535" class="Symbol">:</a> <a id="7537" href="README.Nary.html#911" class="Generalizable">E</a> <a id="7539" class="Symbol">→</a> <a id="7541" class="Symbol">(</a><a id="7542" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7544" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7546" href="README.Nary.html#869" class="Generalizable">B</a> <a id="7548" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7550" href="README.Nary.html#883" class="Generalizable">C</a> <a id="7552" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7554" href="README.Nary.html#897" class="Generalizable">D</a><a id="7555" class="Symbol">)</a> <a id="7557" class="Symbol">→</a> <a id="7559" class="Symbol">(</a><a id="7560" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7562" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7564" href="README.Nary.html#869" class="Generalizable">B</a> <a id="7566" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7568" href="README.Nary.html#883" class="Generalizable">C</a> <a id="7570" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7572" href="README.Nary.html#897" class="Generalizable">D</a> <a id="7574" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7576" href="README.Nary.html#911" class="Generalizable">E</a><a id="7577" class="Symbol">)</a>
<a id="7579" href="README.Nary.html#7523" class="Function">insert-back</a> <a id="7591" class="Symbol">=</a> <a id="7593" href="Data.Product.Nary.NonDependent.html#8535" class="Function">insertₙ</a> <a id="7601" class="Number">4</a> <a id="7603" class="Symbol">(</a><a id="7604" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7606" class="Number">4</a><a id="7607" class="Symbol">)</a>

<a id="7610" class="Comment">-----------------------------------------------------------------------</a>
<a id="7682" class="Comment">-- removeₙ : ∀ n (k : Fin n) → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="7756" class="Comment">-- Dual to `insertₙ`, we may remove a value.</a>

<a id="remove₁"></a><a id="7802" href="README.Nary.html#7802" class="Function">remove₁</a> <a id="7810" class="Symbol">:</a> <a id="7812" class="Symbol">(</a><a id="7813" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7815" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7817" href="README.Nary.html#869" class="Generalizable">B</a> <a id="7819" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7821" href="README.Nary.html#883" class="Generalizable">C</a> <a id="7823" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7825" href="README.Nary.html#897" class="Generalizable">D</a> <a id="7827" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7829" href="README.Nary.html#911" class="Generalizable">E</a><a id="7830" class="Symbol">)</a> <a id="7832" class="Symbol">→</a> <a id="7834" class="Symbol">(</a><a id="7835" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7837" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7839" href="README.Nary.html#869" class="Generalizable">B</a> <a id="7841" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7843" href="README.Nary.html#897" class="Generalizable">D</a> <a id="7845" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7847" href="README.Nary.html#911" class="Generalizable">E</a><a id="7848" class="Symbol">)</a>
<a id="7850" href="README.Nary.html#7802" class="Function">remove₁</a> <a id="7858" class="Symbol">=</a> <a id="7860" href="Data.Product.Nary.NonDependent.html#7672" class="Function">removeₙ</a> <a id="7868" class="Number">5</a> <a id="7870" class="Symbol">(</a><a id="7871" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7873" class="Number">2</a><a id="7874" class="Symbol">)</a>

<a id="7877" class="Comment">-- Inserting at `k` and then removing at `inject₁ k` should yield the identity</a>

<a id="remove-insert"></a><a id="7957" href="README.Nary.html#7957" class="Function">remove-insert</a> <a id="7971" class="Symbol">:</a> <a id="7973" href="README.Nary.html#883" class="Generalizable">C</a> <a id="7975" class="Symbol">→</a> <a id="7977" class="Symbol">(</a><a id="7978" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7980" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7982" href="README.Nary.html#869" class="Generalizable">B</a> <a id="7984" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7986" href="README.Nary.html#897" class="Generalizable">D</a> <a id="7988" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7990" href="README.Nary.html#911" class="Generalizable">E</a><a id="7991" class="Symbol">)</a> <a id="7993" class="Symbol">→</a> <a id="7995" class="Symbol">(</a><a id="7996" href="README.Nary.html#855" class="Generalizable">A</a> <a id="7998" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8000" href="README.Nary.html#869" class="Generalizable">B</a> <a id="8002" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8004" href="README.Nary.html#897" class="Generalizable">D</a> <a id="8006" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8008" href="README.Nary.html#911" class="Generalizable">E</a><a id="8009" class="Symbol">)</a>
<a id="8011" href="README.Nary.html#7957" class="Function">remove-insert</a> <a id="8025" href="README.Nary.html#8025" class="Bound">c</a> <a id="8027" class="Symbol">=</a> <a id="8029" href="Data.Product.Nary.NonDependent.html#7672" class="Function">removeₙ</a> <a id="8037" class="Number">5</a> <a id="8039" class="Symbol">(</a><a id="8040" href="Data.Fin.Base.html#3276" class="Function">inject₁</a> <a id="8048" href="README.Nary.html#8078" class="Function">k</a><a id="8049" class="Symbol">)</a> <a id="8051" href="Function.Base.html#3646" class="Function Operator">∘′</a> <a id="8054" href="Data.Product.Nary.NonDependent.html#8535" class="Function">insertₙ</a> <a id="8062" class="Number">4</a> <a id="8064" href="README.Nary.html#8078" class="Function">k</a> <a id="8066" href="README.Nary.html#8025" class="Bound">c</a>
    <a id="8072" class="Keyword">where</a> <a id="8078" href="README.Nary.html#8078" class="Function">k</a> <a id="8080" class="Symbol">=</a> <a id="8082" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8084" class="Number">2</a>

<a id="8087" class="Comment">-----------------------------------------------------------------------</a>
<a id="8159" class="Comment">-- updateₙ : ∀ n (k : Fin n) (f : (a : Aₖ₊₁) → B a) →</a>
<a id="8213" class="Comment">--           (p : A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B (projₙ n k p) × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="8291" class="Comment">-- We can not only project out, insert or remove values: we can update them</a>
<a id="8367" class="Comment">-- in place. The type (and value) of the replacement at position k may depend</a>
<a id="8445" class="Comment">-- upon the current value at position k.</a>

<a id="update₁"></a><a id="8487" href="README.Nary.html#8487" class="Function">update₁</a> <a id="8495" class="Symbol">:</a> <a id="8497" class="Symbol">(</a><a id="8498" href="README.Nary.html#8498" class="Bound">p</a> <a id="8500" class="Symbol">:</a> <a id="8502" href="README.Nary.html#855" class="Generalizable">A</a> <a id="8504" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8506" href="README.Nary.html#869" class="Generalizable">B</a> <a id="8508" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8510" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="8512" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8514" href="README.Nary.html#883" class="Generalizable">C</a> <a id="8516" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8518" href="README.Nary.html#897" class="Generalizable">D</a><a id="8519" class="Symbol">)</a> <a id="8521" class="Symbol">→</a> <a id="8523" class="Symbol">(</a><a id="8524" href="README.Nary.html#855" class="Generalizable">A</a> <a id="8526" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8528" href="README.Nary.html#869" class="Generalizable">B</a> <a id="8530" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8532" href="Data.Fin.Base.html#1312" class="Datatype">Fin</a> <a id="8536" class="Symbol">_</a> <a id="8538" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8540" href="README.Nary.html#883" class="Generalizable">C</a> <a id="8542" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8544" href="README.Nary.html#897" class="Generalizable">D</a><a id="8545" class="Symbol">)</a>
<a id="8547" href="README.Nary.html#8487" class="Function">update₁</a> <a id="8555" class="Symbol">=</a> <a id="8557" href="Data.Product.Nary.NonDependent.html#9342" class="Function">updateₙ</a> <a id="8565" class="Number">5</a> <a id="8567" class="Symbol">(</a><a id="8568" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8570" class="Number">2</a><a id="8571" class="Symbol">)</a> <a id="8573" href="Data.Fin.Base.html#2005" class="Function">fromℕ</a>

<a id="8580" class="Comment">-- We can explicitly use the primed version of `updateₙ` to make it known to</a>
<a id="8657" class="Comment">-- Agda that the update function is non dependent. This type of information</a>
<a id="8733" class="Comment">-- is useful for inference: the tighter the constraints, the easier it is to</a>
<a id="8810" class="Comment">-- find a solution (if possible).</a>

<a id="update₂"></a><a id="8845" href="README.Nary.html#8845" class="Function">update₂</a> <a id="8853" class="Symbol">:</a> <a id="8855" class="Symbol">(</a><a id="8856" href="README.Nary.html#8856" class="Bound">p</a> <a id="8858" class="Symbol">:</a> <a id="8860" href="README.Nary.html#855" class="Generalizable">A</a> <a id="8862" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8864" href="README.Nary.html#869" class="Generalizable">B</a> <a id="8866" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8868" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="8870" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8872" href="README.Nary.html#883" class="Generalizable">C</a> <a id="8874" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8876" href="README.Nary.html#897" class="Generalizable">D</a><a id="8877" class="Symbol">)</a> <a id="8879" class="Symbol">→</a> <a id="8881" class="Symbol">(</a><a id="8882" href="README.Nary.html#855" class="Generalizable">A</a> <a id="8884" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8886" href="README.Nary.html#869" class="Generalizable">B</a> <a id="8888" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8890" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="8895" href="README.Nary.html#897" class="Generalizable">D</a> <a id="8897" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8899" href="README.Nary.html#883" class="Generalizable">C</a> <a id="8901" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="8903" href="README.Nary.html#897" class="Generalizable">D</a><a id="8904" class="Symbol">)</a>
<a id="8906" href="README.Nary.html#8845" class="Function">update₂</a> <a id="8914" class="Symbol">=</a> <a id="8916" class="Symbol">λ</a> <a id="8918" href="README.Nary.html#8918" class="Bound">p</a> <a id="8920" class="Symbol">→</a> <a id="8922" href="Data.Product.Nary.NonDependent.html#9688" class="Function">updateₙ′</a> <a id="8931" class="Number">5</a> <a id="8933" class="Symbol">(</a><a id="8934" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8936" class="Number">2</a><a id="8937" class="Symbol">)</a> <a id="8939" class="Symbol">(λ</a> <a id="8942" href="README.Nary.html#8942" class="Bound">n</a> <a id="8944" class="Symbol">→</a> <a id="8946" href="Data.List.Base.html#5347" class="Function">replicate</a> <a id="8956" href="README.Nary.html#8942" class="Bound">n</a> <a id="8958" class="Symbol">(</a><a id="8959" href="Data.Product.Nary.NonDependent.html#6482" class="Function">projₙ</a> <a id="8965" class="Number">5</a> <a id="8967" class="Symbol">(</a><a id="8968" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8970" class="Number">4</a><a id="8971" class="Symbol">)</a> <a id="8973" href="README.Nary.html#8918" class="Bound">p</a><a id="8974" class="Symbol">))</a> <a id="8977" href="README.Nary.html#8918" class="Bound">p</a>

<a id="8980" class="Comment">-----------------------------------------------------------------------</a>
<a id="9052" class="Comment">-- _%=_⊢_ : ∀ n → (C → D) → (A₁ → ⋯ Aₙ → D → B) → A₁ → ⋯ → Aₙ → C → B</a>

<a id="9123" class="Comment">-- Traditional composition (also known as the index update operator `_⊢_`</a>
<a id="9197" class="Comment">-- in `Relation.Unary`) focuses solely on the first argument of an n-ary</a>
<a id="9270" class="Comment">-- function. `_%=_⊢_` on the other hand allows us to touch any one of the</a>
<a id="9344" class="Comment">-- arguments.</a>

<a id="9359" class="Comment">-- In the following example we have a function `f : A → B` and `replicate`</a>
<a id="9434" class="Comment">-- of type `ℕ → B → List B`. We want ̀f` to act on the second argument of</a>
<a id="9508" class="Comment">-- replicate. Which we can do like so.</a>

<a id="compose₁"></a><a id="9548" href="README.Nary.html#9548" class="Function">compose₁</a> <a id="9557" class="Symbol">:</a> <a id="9559" class="Symbol">(</a><a id="9560" href="README.Nary.html#855" class="Generalizable">A</a> <a id="9562" class="Symbol">→</a> <a id="9564" href="README.Nary.html#869" class="Generalizable">B</a><a id="9565" class="Symbol">)</a> <a id="9567" class="Symbol">→</a> <a id="9569" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="9571" class="Symbol">→</a> <a id="9573" href="README.Nary.html#855" class="Generalizable">A</a> <a id="9575" class="Symbol">→</a> <a id="9577" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="9582" href="README.Nary.html#869" class="Generalizable">B</a>
<a id="9584" href="README.Nary.html#9548" class="Function">compose₁</a> <a id="9593" href="README.Nary.html#9593" class="Bound">f</a> <a id="9595" class="Symbol">=</a> <a id="9597" class="Number">1</a> <a id="9599" href="Function.Nary.NonDependent.Base.html#3868" class="Function Operator">%=</a> <a id="9602" href="README.Nary.html#9593" class="Bound">f</a> <a id="9604" href="Function.Nary.NonDependent.Base.html#3868" class="Function Operator">⊢</a> <a id="9606" href="Data.List.Base.html#5347" class="Function">replicate</a>

<a id="9617" class="Comment">-- Here we spell out the equivalent explicit variable-manipulation and</a>
<a id="9688" class="Comment">-- prove the two functions equal.</a>

<a id="compose₁′"></a><a id="9723" href="README.Nary.html#9723" class="Function">compose₁′</a> <a id="9733" class="Symbol">:</a> <a id="9735" class="Symbol">(</a><a id="9736" href="README.Nary.html#855" class="Generalizable">A</a> <a id="9738" class="Symbol">→</a> <a id="9740" href="README.Nary.html#869" class="Generalizable">B</a><a id="9741" class="Symbol">)</a> <a id="9743" class="Symbol">→</a> <a id="9745" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="9747" class="Symbol">→</a> <a id="9749" href="README.Nary.html#855" class="Generalizable">A</a> <a id="9751" class="Symbol">→</a> <a id="9753" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="9758" href="README.Nary.html#869" class="Generalizable">B</a>
<a id="9760" href="README.Nary.html#9723" class="Function">compose₁′</a> <a id="9770" href="README.Nary.html#9770" class="Bound">f</a> <a id="9772" href="README.Nary.html#9772" class="Bound">n</a> <a id="9774" href="README.Nary.html#9774" class="Bound">a</a> <a id="9776" class="Symbol">=</a> <a id="9778" href="Data.List.Base.html#5347" class="Function">replicate</a> <a id="9788" href="README.Nary.html#9772" class="Bound">n</a> <a id="9790" class="Symbol">(</a><a id="9791" href="README.Nary.html#9770" class="Bound">f</a> <a id="9793" href="README.Nary.html#9774" class="Bound">a</a><a id="9794" class="Symbol">)</a>

<a id="compose₁-eq"></a><a id="9797" href="README.Nary.html#9797" class="Function">compose₁-eq</a> <a id="9809" class="Symbol">:</a> <a id="9811" href="README.Nary.html#9548" class="Function">compose₁</a> <a id="9820" class="Symbol">{</a><a id="9821" href="README.Nary.html#833" class="Generalizable">a</a><a id="9822" class="Symbol">}</a> <a id="9824" class="Symbol">{</a><a id="9825" href="README.Nary.html#855" class="Generalizable">A</a><a id="9826" class="Symbol">}</a> <a id="9828" class="Symbol">{</a><a id="9829" href="README.Nary.html#835" class="Generalizable">b</a><a id="9830" class="Symbol">}</a> <a id="9832" class="Symbol">{</a><a id="9833" href="README.Nary.html#869" class="Generalizable">B</a><a id="9834" class="Symbol">}</a> <a id="9836" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="9838" href="README.Nary.html#9723" class="Function">compose₁′</a>
<a id="9848" href="README.Nary.html#9797" class="Function">compose₁-eq</a> <a id="9860" class="Symbol">=</a> <a id="9862" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="9868" class="Comment">-----------------------------------------------------------------------</a>
<a id="9940" class="Comment">-- _∷=_⊢_ : ∀ n → A → (A₁ → ⋯ Aₙ → A → B) → A₁ → ⋯ → Aₙ → B</a>

<a id="10001" class="Comment">-- Partial application usually focuses on the first argument of a function.</a>
<a id="10077" class="Comment">-- We can now partially apply a function in any of its arguments using</a>
<a id="10148" class="Comment">-- `_∷=_⊢_`. Reusing our example involving replicate: we can specialise it</a>
<a id="10223" class="Comment">-- to only output finite lists of `0`:</a>

<a id="apply₁"></a><a id="10263" href="README.Nary.html#10263" class="Function">apply₁</a> <a id="10270" class="Symbol">:</a> <a id="10272" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="10274" class="Symbol">→</a> <a id="10276" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="10281" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="10283" href="README.Nary.html#10263" class="Function">apply₁</a> <a id="10290" class="Symbol">=</a> <a id="10292" class="Number">1</a> <a id="10294" href="Function.Nary.NonDependent.Base.html#4040" class="Function Operator">∷=</a> <a id="10297" class="Number">0</a> <a id="10299" href="Function.Nary.NonDependent.Base.html#4040" class="Function Operator">⊢</a> <a id="10301" href="Data.List.Base.html#5347" class="Function">replicate</a>

<a id="apply₁-eq"></a><a id="10312" href="README.Nary.html#10312" class="Function">apply₁-eq</a> <a id="10322" class="Symbol">:</a> <a id="10324" href="README.Nary.html#10263" class="Function">apply₁</a> <a id="10331" class="Number">3</a> <a id="10333" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="10335" class="Number">0</a> <a id="10337" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10339" class="Number">0</a> <a id="10341" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10343" class="Number">0</a> <a id="10345" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10347" class="InductiveConstructor">[]</a>
<a id="10350" href="README.Nary.html#10312" class="Function">apply₁-eq</a> <a id="10360" class="Symbol">=</a> <a id="10362" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="10368" class="Comment">------------------------------------------------------------------------</a>
<a id="10441" class="Comment">-- holeₙ : ∀ n → (A → (A₁ → ⋯ Aₙ → B)) → A₁ → ⋯ → Aₙ → (A → B)</a>

<a id="10505" class="Comment">-- As we have seen earlier, `cong` acts on a function&#39;s first variable.</a>
<a id="10577" class="Comment">-- If we want to access the second one, we can use `flip`. But what about</a>
<a id="10651" class="Comment">-- the fourth one? We typically use an explicit λ-abstraction shuffling</a>
<a id="10723" class="Comment">-- variables. Not anymore.</a>

<a id="10751" class="Comment">-- Reusing mod-helper just because it takes a lot of arguments:</a>

<a id="hole₁"></a><a id="10816" href="README.Nary.html#10816" class="Function">hole₁</a> <a id="10822" class="Symbol">:</a> <a id="10824" class="Symbol">∀</a> <a id="10826" href="README.Nary.html#10826" class="Bound">k</a> <a id="10828" href="README.Nary.html#10828" class="Bound">m</a> <a id="10830" href="README.Nary.html#10830" class="Bound">n</a> <a id="10832" href="README.Nary.html#10832" class="Bound">j</a> <a id="10834" class="Symbol">→</a> <a id="10836" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10847" href="README.Nary.html#10826" class="Bound">k</a> <a id="10849" class="Symbol">(</a><a id="10850" href="README.Nary.html#10828" class="Bound">m</a> <a id="10852" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="10854" class="Number">1</a><a id="10855" class="Symbol">)</a> <a id="10857" href="README.Nary.html#10830" class="Bound">n</a> <a id="10859" href="README.Nary.html#10832" class="Bound">j</a> <a id="10861" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="10863" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10874" href="README.Nary.html#10826" class="Bound">k</a> <a id="10876" class="Symbol">(</a><a id="10877" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="10881" href="README.Nary.html#10828" class="Bound">m</a><a id="10882" class="Symbol">)</a> <a id="10884" href="README.Nary.html#10830" class="Bound">n</a> <a id="10886" href="README.Nary.html#10832" class="Bound">j</a>
<a id="10888" href="README.Nary.html#10816" class="Function">hole₁</a> <a id="10894" class="Symbol">=</a> <a id="10896" class="Symbol">λ</a> <a id="10898" href="README.Nary.html#10898" class="Bound">k</a> <a id="10900" href="README.Nary.html#10900" class="Bound">m</a> <a id="10902" href="README.Nary.html#10902" class="Bound">n</a> <a id="10904" href="README.Nary.html#10904" class="Bound">j</a> <a id="10906" class="Symbol">→</a> <a id="10908" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="10913" class="Symbol">(</a><a id="10914" href="Function.Nary.NonDependent.Base.html#4164" class="Function">holeₙ</a> <a id="10920" class="Number">2</a> <a id="10922" class="Symbol">(</a><a id="10923" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10934" href="README.Nary.html#10898" class="Bound">k</a><a id="10935" class="Symbol">)</a> <a id="10937" href="README.Nary.html#10902" class="Bound">n</a> <a id="10939" href="README.Nary.html#10904" class="Bound">j</a><a id="10940" class="Symbol">)</a> <a id="10942" class="Symbol">(</a><a id="10943" href="Data.Nat.Properties.html#14788" class="Function">+-comm</a> <a id="10950" href="README.Nary.html#10900" class="Bound">m</a> <a id="10952" class="Number">1</a><a id="10953" class="Symbol">)</a>

<a id="10956" class="Comment">-----------------------------------------------------------------------</a>
<a id="11028" class="Comment">-- mapₙ : ∀ n → (B → C) → (A₁ → ⋯ Aₙ → B) → (A₁ → ⋯ → Aₙ → C)</a>

<a id="11091" class="Comment">-- (R →_) gives us the reader monad (and, a fortiori, functor). That is to</a>
<a id="11166" class="Comment">-- say that given a function (A → B) and an (R → A) we can get an (R → B)</a>
<a id="11240" class="Comment">-- This generalises to n-ary functions.</a>

<a id="11281" class="Comment">-- Reusing our `composeₙ` example: instead of applying `f` to the replicated</a>
<a id="11358" class="Comment">-- element, we can map it on the resulting list. Giving us:</a>

<a id="map₁"></a><a id="11419" href="README.Nary.html#11419" class="Function">map₁</a> <a id="11424" class="Symbol">:</a> <a id="11426" class="Symbol">(</a><a id="11427" href="README.Nary.html#855" class="Generalizable">A</a> <a id="11429" class="Symbol">→</a> <a id="11431" href="README.Nary.html#869" class="Generalizable">B</a><a id="11432" class="Symbol">)</a> <a id="11434" class="Symbol">→</a> <a id="11436" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="11438" class="Symbol">→</a> <a id="11440" href="README.Nary.html#855" class="Generalizable">A</a> <a id="11442" class="Symbol">→</a> <a id="11444" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="11449" href="README.Nary.html#869" class="Generalizable">B</a>
<a id="11451" href="README.Nary.html#11419" class="Function">map₁</a> <a id="11456" href="README.Nary.html#11456" class="Bound">f</a> <a id="11458" class="Symbol">=</a> <a id="11460" href="Function.Nary.NonDependent.Base.html#3692" class="Function">mapₙ</a> <a id="11465" class="Number">2</a> <a id="11467" class="Symbol">(</a><a id="11468" href="Data.List.Base.html#1620" class="Function">map</a> <a id="11472" href="README.Nary.html#11456" class="Bound">f</a><a id="11473" class="Symbol">)</a> <a id="11475" href="Data.List.Base.html#5347" class="Function">replicate</a>

<a id="11486" class="Comment">------------------------------------------------------------------------</a>
<a id="11559" class="Comment">-- constₙ : ∀ n → B → A₁ → ⋯ → Aₙ → B</a>

<a id="11598" class="Comment">-- `const` is basically `pure` for the reader monad discussed above. Just</a>
<a id="11672" class="Comment">-- like we can generalise the functorial action corresponding to the reader</a>
<a id="11748" class="Comment">-- functor to n-ary functions, we can do the same for `pure`.</a>

<a id="const₁"></a><a id="11811" href="README.Nary.html#11811" class="Function">const₁</a> <a id="11818" class="Symbol">:</a> <a id="11820" href="README.Nary.html#855" class="Generalizable">A</a> <a id="11822" class="Symbol">→</a> <a id="11824" href="README.Nary.html#869" class="Generalizable">B</a> <a id="11826" class="Symbol">→</a> <a id="11828" href="README.Nary.html#883" class="Generalizable">C</a> <a id="11830" class="Symbol">→</a> <a id="11832" href="README.Nary.html#897" class="Generalizable">D</a> <a id="11834" class="Symbol">→</a> <a id="11836" href="README.Nary.html#911" class="Generalizable">E</a> <a id="11838" class="Symbol">→</a> <a id="11840" href="README.Nary.html#855" class="Generalizable">A</a>
<a id="11842" href="README.Nary.html#11811" class="Function">const₁</a> <a id="11849" class="Symbol">=</a> <a id="11851" href="Function.Nary.NonDependent.Base.html#4546" class="Function">constₙ</a> <a id="11858" class="Number">4</a>

<a id="11861" class="Comment">-- Together with `holeₙ`, this means we can make a constant function out</a>
<a id="11934" class="Comment">-- of any of the arguments. The fourth for instance:</a>

<a id="const₂"></a><a id="11988" href="README.Nary.html#11988" class="Function">const₂</a> <a id="11995" class="Symbol">:</a> <a id="11997" href="README.Nary.html#855" class="Generalizable">A</a> <a id="11999" class="Symbol">→</a> <a id="12001" href="README.Nary.html#869" class="Generalizable">B</a> <a id="12003" class="Symbol">→</a> <a id="12005" href="README.Nary.html#883" class="Generalizable">C</a> <a id="12007" class="Symbol">→</a> <a id="12009" href="README.Nary.html#897" class="Generalizable">D</a> <a id="12011" class="Symbol">→</a> <a id="12013" href="README.Nary.html#911" class="Generalizable">E</a> <a id="12015" class="Symbol">→</a> <a id="12017" href="README.Nary.html#897" class="Generalizable">D</a>
<a id="12019" href="README.Nary.html#11988" class="Function">const₂</a> <a id="12026" class="Symbol">=</a> <a id="12028" href="Function.Nary.NonDependent.Base.html#4164" class="Function">holeₙ</a> <a id="12034" class="Number">3</a> <a id="12036" class="Symbol">(</a><a id="12037" href="Function.Nary.NonDependent.Base.html#4546" class="Function">constₙ</a> <a id="12044" class="Number">4</a><a id="12045" class="Symbol">)</a>

<a id="12048" class="Comment">------------------------------------------------------------------------</a>
<a id="12121" class="Comment">-- Generalised quantifiers</a>
<a id="12148" class="Comment">------------------------------------------------------------------------</a>

<a id="12222" class="Comment">-- As we have seen multiple times already, one of the advantages of working</a>
<a id="12298" class="Comment">-- with non-dependent products is that they can be easily inferred. This is</a>
<a id="12374" class="Comment">-- a prime opportunity to define generic quantifiers.</a>

<a id="12429" class="Comment">-- And because n-ary relations are Set-terminated, there is no ambiguity</a>
<a id="12502" class="Comment">-- where to split between arguments &amp; codomain. As a consequence Agda can</a>
<a id="12576" class="Comment">-- infer even `n`, the number of arguments. We can use notations which are</a>
<a id="12651" class="Comment">-- just like the ones defined in `Relation.Unary`.</a>

<a id="12703" class="Comment">------------------------------------------------------------------------</a>
<a id="12776" class="Comment">-- ∃⟨_⟩ : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="12816" class="Comment">-- ∃⟨ P ⟩ = ∃ λ a₁ → ⋯ → ∃ λ aₙ → P a₁ ⋯ aₙ</a>

<a id="12861" class="Comment">-- Returning to our favourite function taking a lot of arguments: we can</a>
<a id="12934" class="Comment">-- find a set of input for which it evaluates to 666</a>

<a id="exist₁"></a><a id="12988" href="README.Nary.html#12988" class="Function">exist₁</a> <a id="12995" class="Symbol">:</a> <a id="12997" href="Relation.Nary.html#2380" class="Function Operator">∃⟨</a> <a id="13000" class="Symbol">(λ</a> <a id="13003" href="README.Nary.html#13003" class="Bound">k</a> <a id="13005" href="README.Nary.html#13005" class="Bound">m</a> <a id="13007" href="README.Nary.html#13007" class="Bound">n</a> <a id="13009" href="README.Nary.html#13009" class="Bound">j</a> <a id="13011" class="Symbol">→</a> <a id="13013" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="13024" href="README.Nary.html#13003" class="Bound">k</a> <a id="13026" href="README.Nary.html#13005" class="Bound">m</a> <a id="13028" href="README.Nary.html#13007" class="Bound">n</a> <a id="13030" href="README.Nary.html#13009" class="Bound">j</a> <a id="13032" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13034" class="Number">666</a><a id="13037" class="Symbol">)</a> <a id="13039" href="Relation.Nary.html#2380" class="Function Operator">⟩</a>
<a id="13041" href="README.Nary.html#12988" class="Function">exist₁</a> <a id="13048" class="Symbol">=</a> <a id="13050" class="Number">19</a> <a id="13053" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13055" class="Number">793</a> <a id="13059" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13061" class="Number">3059</a> <a id="13066" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13068" class="Number">10</a> <a id="13071" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13073" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="13079" class="Comment">------------------------------------------------------------------------</a>
<a id="13152" class="Comment">-- ∀[_] : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13192" class="Comment">-- ∀[_] P = ∀ {a₁} → ⋯ → ∀ {aₙ} → P a₁ ⋯ aₙ</a>

<a id="all₁"></a><a id="13237" href="README.Nary.html#13237" class="Function">all₁</a> <a id="13242" class="Symbol">:</a> <a id="13244" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="13247" class="Symbol">(λ</a> <a id="13250" class="Symbol">(</a><a id="13251" href="README.Nary.html#13251" class="Bound">a₁</a> <a id="13254" href="README.Nary.html#13254" class="Bound">a₂</a> <a id="13257" class="Symbol">:</a> <a id="13259" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13260" class="Symbol">)</a> <a id="13262" class="Symbol">→</a> <a id="13264" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="13268" class="Symbol">(</a><a id="13269" href="README.Nary.html#13251" class="Bound">a₁</a> <a id="13272" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13274" href="README.Nary.html#13254" class="Bound">a₂</a><a id="13276" class="Symbol">))</a> <a id="13279" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="13281" href="README.Nary.html#13237" class="Function">all₁</a> <a id="13286" class="Symbol">{</a><a id="13287" href="README.Nary.html#13287" class="Bound">a₁</a><a id="13289" class="Symbol">}</a> <a id="13291" class="Symbol">{</a><a id="13292" href="README.Nary.html#13292" class="Bound">a₂</a><a id="13294" class="Symbol">}</a> <a id="13296" class="Symbol">=</a> <a id="13298" href="README.Nary.html#13287" class="Bound">a₁</a> <a id="13301" href="Data.Nat.Properties.html#2947" class="Function Operator">≟</a> <a id="13303" href="README.Nary.html#13292" class="Bound">a₂</a>

<a id="13307" class="Comment">------------------------------------------------------------------------</a>
<a id="13380" class="Comment">-- Π : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13417" class="Comment">-- Π P = ∀ a₁ → ⋯ → ∀ aₙ → P a₁ ⋯ aₙ</a>

<a id="all₂"></a><a id="13455" href="README.Nary.html#13455" class="Function">all₂</a> <a id="13460" class="Symbol">:</a> <a id="13462" href="Relation.Nary.html#2519" class="Function Operator">Π[</a> <a id="13465" class="Symbol">(λ</a> <a id="13468" class="Symbol">(</a><a id="13469" href="README.Nary.html#13469" class="Bound">a₁</a> <a id="13472" href="README.Nary.html#13472" class="Bound">a₂</a> <a id="13475" class="Symbol">:</a> <a id="13477" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13478" class="Symbol">)</a> <a id="13480" class="Symbol">→</a> <a id="13482" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="13486" class="Symbol">(</a><a id="13487" href="README.Nary.html#13469" class="Bound">a₁</a> <a id="13490" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13492" href="README.Nary.html#13472" class="Bound">a₂</a><a id="13494" class="Symbol">))</a> <a id="13497" href="Relation.Nary.html#2519" class="Function Operator">]</a>
<a id="13499" href="README.Nary.html#13455" class="Function">all₂</a> <a id="13504" class="Symbol">=</a> <a id="13506" href="Data.Nat.Properties.html#2947" class="Function Operator">_≟_</a>

<a id="13511" class="Comment">------------------------------------------------------------------------</a>
<a id="13584" class="Comment">-- _⇒_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13663" class="Comment">-- P ⇒ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ → Q a₁ ⋯ aₙ</a>

<a id="antisym"></a><a id="13715" href="README.Nary.html#13715" class="Function">antisym</a> <a id="13723" class="Symbol">:</a> <a id="13725" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="13728" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="13732" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="13734" href="Data.Nat.Base.html#1903" class="Function Operator">_≥_</a> <a id="13738" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="13740" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a> <a id="13744" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="13746" href="README.Nary.html#13715" class="Function">antisym</a> <a id="13754" class="Symbol">=</a> <a id="13756" href="Data.Nat.Properties.html#4980" class="Function">≤-antisym</a>

<a id="13767" class="Comment">------------------------------------------------------------------------</a>
<a id="13840" class="Comment">-- _∪_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13919" class="Comment">-- P ∪ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ ⊎ Q a₁ ⋯ aₙ</a>

<a id="≤-&gt;-connex"></a><a id="13971" href="README.Nary.html#13971" class="Function">≤-&gt;-connex</a> <a id="13982" class="Symbol">:</a> <a id="13984" href="Relation.Nary.html#2519" class="Function Operator">Π[</a> <a id="13987" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="13991" href="Relation.Nary.html#5345" class="Function Operator">∪</a> <a id="13993" href="Data.Nat.Base.html#1933" class="Function Operator">_&gt;_</a> <a id="13997" href="Relation.Nary.html#2519" class="Function Operator">]</a>
<a id="13999" href="README.Nary.html#13971" class="Function">≤-&gt;-connex</a> <a id="14010" href="README.Nary.html#14010" class="Bound">m</a> <a id="14012" href="README.Nary.html#14012" class="Bound">n</a> <a id="14014" class="Keyword">with</a> <a id="14019" href="Data.Nat.Properties.html#10339" class="Function">&lt;-cmp</a> <a id="14025" href="README.Nary.html#14010" class="Bound">m</a> <a id="14027" href="README.Nary.html#14012" class="Bound">n</a>
<a id="14029" class="Symbol">...</a> <a id="14033" class="Symbol">|</a> <a id="14035" href="Relation.Binary.Definitions.html#2857" class="InductiveConstructor">tri&lt;</a> <a id="14040" href="README.Nary.html#14040" class="Bound">a</a> <a id="14042" href="README.Nary.html#14042" class="Bound">¬b</a> <a id="14045" href="README.Nary.html#14045" class="Bound">¬c</a> <a id="14048" class="Symbol">=</a> <a id="14050" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="14055" class="Symbol">(</a><a id="14056" href="Data.Nat.Properties.html#8217" class="Function">&lt;⇒≤</a> <a id="14060" href="README.Nary.html#14040" class="Bound">a</a><a id="14061" class="Symbol">)</a>
<a id="14063" class="Symbol">...</a> <a id="14067" class="Symbol">|</a> <a id="14069" href="Relation.Binary.Definitions.html#2911" class="InductiveConstructor">tri≈</a> <a id="14074" href="README.Nary.html#14074" class="Bound">¬a</a> <a id="14077" href="README.Nary.html#14077" class="Bound">b</a> <a id="14079" href="README.Nary.html#14079" class="Bound">¬c</a> <a id="14082" class="Symbol">=</a> <a id="14084" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="14089" class="Symbol">(</a><a id="14090" href="Data.Nat.Properties.html#4824" class="Function">≤-reflexive</a> <a id="14102" href="README.Nary.html#14077" class="Bound">b</a><a id="14103" class="Symbol">)</a>
<a id="14105" class="Symbol">...</a> <a id="14109" class="Symbol">|</a> <a id="14111" href="Relation.Binary.Definitions.html#2965" class="InductiveConstructor">tri&gt;</a> <a id="14116" href="README.Nary.html#14116" class="Bound">¬a</a> <a id="14119" href="README.Nary.html#14119" class="Bound">¬b</a> <a id="14122" href="README.Nary.html#14122" class="Bound">c</a> <a id="14124" class="Symbol">=</a> <a id="14126" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="14131" href="README.Nary.html#14122" class="Bound">c</a>

<a id="14134" class="Comment">------------------------------------------------------------------------</a>
<a id="14207" class="Comment">-- _∩_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14286" class="Comment">-- P ∩ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ × Q a₁ ⋯ aₙ</a>

<a id="&lt;-inversion"></a><a id="14338" href="README.Nary.html#14338" class="Function">&lt;-inversion</a> <a id="14350" class="Symbol">:</a> <a id="14352" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="14355" href="Data.Nat.Base.html#1654" class="Function Operator">_&lt;_</a> <a id="14359" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="14361" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="14365" href="Relation.Nary.html#5206" class="Function Operator">∩</a> <a id="14367" href="Relation.Binary.PropositionalEquality.Core.html#858" class="Function Operator">_≢_</a> <a id="14371" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="14373" href="README.Nary.html#14338" class="Function">&lt;-inversion</a> <a id="14385" href="README.Nary.html#14385" class="Bound">m&lt;n</a> <a id="14389" class="Symbol">=</a> <a id="14391" href="Data.Nat.Properties.html#8217" class="Function">&lt;⇒≤</a> <a id="14395" href="README.Nary.html#14385" class="Bound">m&lt;n</a> <a id="14399" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="14401" href="Data.Nat.Properties.html#8300" class="Function">&lt;⇒≢</a> <a id="14405" href="README.Nary.html#14385" class="Bound">m&lt;n</a>

<a id="14410" class="Comment">------------------------------------------------------------------------</a>
<a id="14483" class="Comment">-- ∁ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14536" class="Comment">-- ∁ P = λ a₁ → ⋯ → λ aₙ → ¬ (P a₁ ⋯ aₙ)</a>

<a id="m&lt;n⇒m≱n"></a><a id="14578" href="README.Nary.html#14578" class="Function">m&lt;n⇒m≱n</a> <a id="14586" class="Symbol">:</a> <a id="14588" href="Relation.Nary.html#2656" class="Function Operator">∀[</a> <a id="14591" href="Data.Nat.Base.html#1933" class="Function Operator">_&gt;_</a> <a id="14595" href="Relation.Nary.html#5055" class="Function Operator">⇒</a> <a id="14597" href="Relation.Nary.html#5468" class="Function">∁</a> <a id="14599" href="Data.Nat.Base.html#1544" class="Datatype Operator">_≤_</a> <a id="14603" href="Relation.Nary.html#2656" class="Function Operator">]</a>
<a id="14605" href="README.Nary.html#14578" class="Function">m&lt;n⇒m≱n</a> <a id="14613" href="README.Nary.html#14613" class="Bound">m&gt;n</a> <a id="14617" href="README.Nary.html#14617" class="Bound">m≤n</a> <a id="14621" class="Symbol">=</a> <a id="14623" href="Data.Nat.Properties.html#8432" class="Function">&lt;⇒≱</a> <a id="14627" href="README.Nary.html#14613" class="Bound">m&gt;n</a> <a id="14631" href="README.Nary.html#14617" class="Bound">m≤n</a>
</pre></body></html>