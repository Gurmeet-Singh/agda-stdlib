<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.Trie.NonDependent</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Example use case for a trie: a wee generic lexer</a>
<a id="158" class="Comment">------------------------------------------------------------------------</a>

<a id="232" class="Symbol">{-#</a> <a id="236" class="Keyword">OPTIONS</a> <a id="244" class="Pragma">--cubical-compatible</a> <a id="265" class="Pragma">--sized-types</a> <a id="279" class="Symbol">#-}</a>

<a id="284" class="Keyword">module</a> <a id="291" href="README.Data.Trie.NonDependent.html" class="Module">README.Data.Trie.NonDependent</a> <a id="321" class="Keyword">where</a>

<a id="328" class="Comment">------------------------------------------------------------------------</a>
<a id="401" class="Comment">-- Introduction</a>

<a id="418" class="Comment">-- A Trie is a tree of values indexed by words in a finite language. It</a>
<a id="490" class="Comment">-- allows users to quickly compute the Brzozowski derivative of that</a>
<a id="559" class="Comment">-- little mapping from words to values.</a>

<a id="600" class="Comment">-- In the most general case, values can depend upon the list of characters</a>
<a id="675" class="Comment">-- that constitutes the path leading to them. Here however we consider a</a>
<a id="748" class="Comment">-- non-dependent case (cf. README.Trie.Dependent for a dependent use case).</a>

<a id="825" class="Comment">-- We can recognize keywords by storing the list of characters they</a>
<a id="893" class="Comment">-- correspond to as paths in a Trie and the constructor they are decoded</a>
<a id="966" class="Comment">-- to as the tree&#39;s values.</a>

<a id="995" class="Comment">-- E.g.</a>
<a id="1003" class="Comment">-- [     .      ] is a root</a>
<a id="1031" class="Comment">-- [  -- m --&gt;  ] is an m-labeled edge and is followed when reading &#39;m&#39;</a>
<a id="1103" class="Comment">-- [    (X)     ] is a value leaf storing constructor X</a>

<a id="1160" class="Comment">--                     --&gt; -- m --&gt; -- m --&gt; -- a --&gt; (LEMMA)</a>
<a id="1222" class="Comment">--                    /</a>
<a id="1246" class="Comment">--       -- l --&gt; -- e --&gt; -- t --&gt; (LET)</a>
<a id="1288" class="Comment">--      /</a>
<a id="1298" class="Comment">--     /    -- u --&gt; -- t --&gt; -- u --&gt; -- a --&gt; -- l --&gt; (MUTUAL)</a>
<a id="1364" class="Comment">--    /    /</a>
<a id="1377" class="Comment">--  .&lt; -- m --&gt; -- o --&gt; -- d --&gt; -- u --&gt; -- l --&gt; -- e --&gt; (MODULE)</a>
<a id="1447" class="Comment">--    \</a>
<a id="1455" class="Comment">--     -- w --&gt; -- h --&gt; -- e --&gt; -- r --&gt; -- e --&gt; (WHERE)</a>
<a id="1515" class="Comment">--                           \</a>
<a id="1546" class="Comment">--                            --&gt; -- n --&gt; (WHEN)</a>


<a id="1598" class="Comment">-- after reading &#39;w&#39;, we get the derivative:</a>

<a id="1644" class="Comment">--  . -- h --&gt; -- e --&gt; -- r --&gt; -- e --&gt; (WHERE)</a>
<a id="1694" class="Comment">--                 \</a>
<a id="1715" class="Comment">--                  --&gt; -- n --&gt; (WHEN)</a>


<a id="1757" class="Keyword">open</a> <a id="1762" class="Keyword">import</a> <a id="1769" href="Level.html" class="Module">Level</a>
<a id="1775" class="Keyword">open</a> <a id="1780" class="Keyword">import</a> <a id="1787" href="Data.Unit.html" class="Module">Data.Unit</a>
<a id="1797" class="Keyword">open</a> <a id="1802" class="Keyword">import</a> <a id="1809" href="Data.Bool.html" class="Module">Data.Bool</a>
<a id="1819" class="Keyword">open</a> <a id="1824" class="Keyword">import</a> <a id="1831" href="Data.Char.html" class="Module">Data.Char</a>        <a id="1848" class="Symbol">as</a> <a id="1851" class="Module">Char</a>
<a id="1856" class="Keyword">import</a> <a id="1863" href="Data.Char.Properties.html" class="Module">Data.Char.Properties</a>  <a id="1885" class="Symbol">as</a> <a id="1888" class="Module">Char</a>
<a id="1893" class="Keyword">open</a> <a id="1898" class="Keyword">import</a> <a id="1905" href="Data.List.Base.html" class="Module">Data.List.Base</a>   <a id="1922" class="Symbol">as</a> <a id="1925" class="Module">List</a> <a id="1930" class="Keyword">using</a> <a id="1936" class="Symbol">(</a><a id="1937" href="Agda.Builtin.List.html#130" class="Datatype">List</a><a id="1941" class="Symbol">;</a> <a id="1943" href="Data.List.Base.html#7375" class="InductiveConstructor">[]</a><a id="1945" class="Symbol">;</a> <a id="1947" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">_∷_</a><a id="1950" class="Symbol">)</a>
<a id="1952" class="Keyword">open</a> <a id="1957" class="Keyword">import</a> <a id="1964" href="Data.List.Fresh.html" class="Module">Data.List.Fresh</a>  <a id="1981" class="Symbol">as</a> <a id="1984" class="Module">List#</a> <a id="1990" class="Keyword">using</a> <a id="1996" class="Symbol">(</a><a id="1997" href="Data.List.Fresh.html#1557" class="Datatype">List#</a><a id="2002" class="Symbol">;</a> <a id="2004" href="Data.List.Fresh.html#1640" class="InductiveConstructor">[]</a><a id="2006" class="Symbol">;</a> <a id="2008" href="Data.List.Fresh.html#2059" class="InductiveConstructor Operator">_∷#_</a><a id="2012" class="Symbol">)</a>
<a id="2014" class="Keyword">open</a> <a id="2019" class="Keyword">import</a> <a id="2026" href="Data.Maybe.html" class="Module">Data.Maybe</a>       <a id="2043" class="Symbol">as</a> <a id="2046" class="Module">Maybe</a>
<a id="2052" class="Keyword">open</a> <a id="2057" class="Keyword">import</a> <a id="2064" href="Data.Product.html" class="Module">Data.Product</a>     <a id="2081" class="Symbol">as</a> <a id="2084" class="Module">Prod</a>
<a id="2089" class="Keyword">open</a> <a id="2094" class="Keyword">import</a> <a id="2101" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="2118" class="Symbol">as</a> <a id="2121" class="Module">String</a> <a id="2128" class="Keyword">using</a> <a id="2134" class="Symbol">(</a><a id="2135" href="Agda.Builtin.String.html#318" class="Postulate">String</a><a id="2141" class="Symbol">)</a>
<a id="2143" class="Keyword">open</a> <a id="2148" class="Keyword">import</a> <a id="2155" href="Data.String.Properties.html" class="Module">Data.String.Properties</a> <a id="2178" class="Symbol">as</a> <a id="2181" class="Module">String</a> <a id="2188" class="Keyword">using</a> <a id="2194" class="Symbol">(</a><a id="2195" href="Data.String.Properties.html#2306" class="Function Operator">_≟_</a><a id="2198" class="Symbol">)</a>
<a id="2200" class="Keyword">open</a> <a id="2205" class="Keyword">import</a> <a id="2212" href="Data.These.html" class="Module">Data.These</a>       <a id="2229" class="Symbol">as</a> <a id="2232" class="Module">These</a>

<a id="2239" class="Keyword">open</a> <a id="2244" class="Keyword">import</a> <a id="2251" href="Function.Base.html" class="Module">Function.Base</a> <a id="2265" class="Keyword">using</a> <a id="2271" class="Symbol">(</a><a id="2272" href="Function.Base.html#4062" class="Function Operator">case_of_</a><a id="2280" class="Symbol">;</a> <a id="2282" href="Function.Base.html#2003" class="Function Operator">_$_</a><a id="2285" class="Symbol">;</a> <a id="2287" href="Function.Base.html#3646" class="Function Operator">_∘′_</a><a id="2291" class="Symbol">;</a> <a id="2293" href="Function.Base.html#704" class="Function">id</a><a id="2295" class="Symbol">;</a> <a id="2297" href="Function.Base.html#6226" class="Function Operator">_on_</a><a id="2301" class="Symbol">)</a>
<a id="2303" class="Keyword">open</a> <a id="2308" class="Keyword">import</a> <a id="2315" href="Relation.Nary.html" class="Module">Relation.Nary</a>
<a id="2329" class="Keyword">open</a> <a id="2334" class="Keyword">import</a> <a id="2341" href="Relation.Binary.Core.html" class="Module">Relation.Binary.Core</a> <a id="2362" class="Keyword">using</a> <a id="2368" class="Symbol">(</a><a id="2369" href="Relation.Binary.Core.html#896" class="Function">Rel</a><a id="2372" class="Symbol">)</a>
<a id="2374" class="Keyword">open</a> <a id="2379" class="Keyword">import</a> <a id="2386" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="2413" class="Keyword">using</a> <a id="2419" class="Symbol">(</a><a id="2420" href="Relation.Nullary.Decidable.Core.html#2177" class="Function">¬?</a><a id="2422" class="Symbol">)</a>

<a id="2425" class="Keyword">open</a> <a id="2430" class="Keyword">import</a> <a id="2437" href="Data.Trie.html" class="Module">Data.Trie</a> <a id="2447" href="Data.Char.Properties.html#3793" class="Function">Char.&lt;-strictTotalOrder</a>
<a id="2471" class="Keyword">open</a> <a id="2476" class="Keyword">import</a> <a id="2483" href="Data.Tree.AVL.Value.html" class="Module">Data.Tree.AVL.Value</a>

<a id="2504" class="Comment">------------------------------------------------------------------------</a>
<a id="2577" class="Comment">-- Generic lexer</a>

<a id="2595" class="Keyword">record</a> <a id="Lexer"></a><a id="2602" href="README.Data.Trie.NonDependent.html#2602" class="Record">Lexer</a> <a id="2608" href="README.Data.Trie.NonDependent.html#2608" class="Bound">t</a> <a id="2610" class="Symbol">:</a> <a id="2612" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="2616" class="Symbol">(</a><a id="2617" href="Agda.Primitive.html#774" class="Primitive">suc</a> <a id="2621" href="README.Data.Trie.NonDependent.html#2608" class="Bound">t</a><a id="2622" class="Symbol">)</a> <a id="2624" class="Keyword">where</a>
  <a id="2632" class="Keyword">field</a>
  <a id="2640" class="Comment">-- Our lexer is parametrised over the type of tokens</a>
    <a id="Lexer.Tok"></a><a id="2697" href="README.Data.Trie.NonDependent.html#2697" class="Field">Tok</a> <a id="2701" class="Symbol">:</a> <a id="2703" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="2707" href="README.Data.Trie.NonDependent.html#2608" class="Bound">t</a>

  <a id="2712" class="Comment">-- Keywords are distinguished strings associated to tokens</a>
  <a id="Lexer.Keyword"></a><a id="2773" href="README.Data.Trie.NonDependent.html#2773" class="Function">Keyword</a> <a id="2781" class="Symbol">:</a> <a id="2783" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="2787" href="README.Data.Trie.NonDependent.html#2608" class="Bound">t</a>
  <a id="2791" href="README.Data.Trie.NonDependent.html#2773" class="Function">Keyword</a> <a id="2799" class="Symbol">=</a> <a id="2801" href="Agda.Builtin.String.html#318" class="Postulate">String</a> <a id="2808" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="2810" href="README.Data.Trie.NonDependent.html#2697" class="Field">Tok</a>

  <a id="2817" class="Comment">-- Two keywords are considered distinct if the strings are not equal</a>
  <a id="Lexer.Distinct"></a><a id="2888" href="README.Data.Trie.NonDependent.html#2888" class="Function">Distinct</a> <a id="2897" class="Symbol">:</a> <a id="2899" href="Relation.Binary.Core.html#896" class="Function">Rel</a> <a id="2903" href="README.Data.Trie.NonDependent.html#2773" class="Function">Keyword</a> <a id="2911" href="Level.html#521" class="Function">0ℓ</a>
  <a id="2916" href="README.Data.Trie.NonDependent.html#2888" class="Function">Distinct</a> <a id="2925" href="README.Data.Trie.NonDependent.html#2925" class="Bound">a</a> <a id="2927" href="README.Data.Trie.NonDependent.html#2927" class="Bound">b</a> <a id="2929" class="Symbol">=</a> <a id="2931" href="Relation.Nary.html#6519" class="Function Operator">⌊</a> <a id="2933" href="Relation.Nullary.Decidable.Core.html#2177" class="Function">¬?</a> <a id="2936" class="Symbol">((</a><a id="2938" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="2944" href="README.Data.Trie.NonDependent.html#2925" class="Bound">a</a><a id="2945" class="Symbol">)</a> <a id="2947" href="Data.String.Properties.html#2306" class="Function Operator">String.≟</a> <a id="2956" class="Symbol">(</a><a id="2957" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="2963" href="README.Data.Trie.NonDependent.html#2927" class="Bound">b</a><a id="2964" class="Symbol">))</a> <a id="2967" href="Relation.Nary.html#6519" class="Function Operator">⌋</a>

  <a id="2972" class="Keyword">field</a>

  <a id="2981" class="Comment">-- We ask users to provide us with a fresh list of keywords to guarantee</a>
  <a id="3056" class="Comment">-- that no two keywords share the same string representation</a>
    <a id="Lexer.keywords"></a><a id="3121" href="README.Data.Trie.NonDependent.html#3121" class="Field">keywords</a> <a id="3130" class="Symbol">:</a> <a id="3132" href="Data.List.Fresh.html#1557" class="Datatype">List#</a> <a id="3138" href="README.Data.Trie.NonDependent.html#2773" class="Function">Keyword</a> <a id="3146" href="README.Data.Trie.NonDependent.html#2888" class="Function">Distinct</a>

  <a id="3158" class="Comment">-- Some characters are special: they are separators, breaking a string</a>
  <a id="3231" class="Comment">-- into a list of tokens. Some are associated to a token value</a>
  <a id="3296" class="Comment">-- (e.g. parentheses) others are not (e.g. space)</a>
    <a id="Lexer.breaking"></a><a id="3350" href="README.Data.Trie.NonDependent.html#3350" class="Field">breaking</a> <a id="3359" class="Symbol">:</a> <a id="3361" href="Agda.Builtin.Char.html#221" class="Postulate">Char</a> <a id="3366" class="Symbol">→</a> <a id="3368" href="Data.Product.Base.html#852" class="Function">∃</a> <a id="3370" class="Symbol">λ</a> <a id="3372" href="README.Data.Trie.NonDependent.html#3372" class="Bound">b</a> <a id="3374" class="Symbol">→</a> <a id="3376" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="3379" href="README.Data.Trie.NonDependent.html#3372" class="Bound">b</a> <a id="3381" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="3386" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="3392" href="README.Data.Trie.NonDependent.html#2697" class="Field">Tok</a> <a id="3396" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="3401" href="Level.html#409" class="Record">Lift</a> <a id="3406" class="Symbol">_</a> <a id="3408" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a>

  <a id="3413" class="Comment">-- Finally, strings which are not decoded as keywords are coerced</a>
  <a id="3481" class="Comment">-- using a function to token values.</a>
    <a id="Lexer.default"></a><a id="3522" href="README.Data.Trie.NonDependent.html#3522" class="Field">default</a>  <a id="3531" class="Symbol">:</a> <a id="3533" href="Agda.Builtin.String.html#318" class="Postulate">String</a> <a id="3540" class="Symbol">→</a> <a id="3542" href="README.Data.Trie.NonDependent.html#2697" class="Field">Tok</a>


<a id="3548" class="Keyword">module</a> <a id="3555" href="README.Data.Trie.NonDependent.html#3555" class="Module">_</a> <a id="3557" class="Symbol">{</a><a id="3558" href="README.Data.Trie.NonDependent.html#3558" class="Bound">t</a><a id="3559" class="Symbol">}</a> <a id="3561" class="Symbol">(</a><a id="3562" href="README.Data.Trie.NonDependent.html#3562" class="Bound">L</a> <a id="3564" class="Symbol">:</a> <a id="3566" href="README.Data.Trie.NonDependent.html#2602" class="Record">Lexer</a> <a id="3572" href="README.Data.Trie.NonDependent.html#3558" class="Bound">t</a><a id="3573" class="Symbol">)</a> <a id="3575" class="Keyword">where</a>
  <a id="3583" class="Keyword">open</a> <a id="3588" href="README.Data.Trie.NonDependent.html#2602" class="Module">Lexer</a> <a id="3594" href="README.Data.Trie.NonDependent.html#3562" class="Bound">L</a>

  <a id="3599" href="README.Data.Trie.NonDependent.html#3599" class="Function">tokenize</a> <a id="3608" class="Symbol">:</a> <a id="3610" href="Agda.Builtin.String.html#318" class="Postulate">String</a> <a id="3617" class="Symbol">→</a> <a id="3619" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="3624" href="README.Data.Trie.NonDependent.html#2697" class="Field">Tok</a>
  <a id="3630" href="README.Data.Trie.NonDependent.html#3599" class="Function">tokenize</a> <a id="3639" class="Symbol">=</a> <a id="3641" href="README.Data.Trie.NonDependent.html#4709" class="Function">start</a> <a id="3647" href="Function.Base.html#3646" class="Function Operator">∘′</a> <a id="3650" href="Data.String.Base.html#1533" class="Primitive">String.toList</a> <a id="3664" class="Keyword">where</a>

   <a id="3674" class="Keyword">mutual</a>

    <a id="3686" class="Comment">-- A Trie is defined for an alphabet of strictly ordered letters (here</a>
    <a id="3761" class="Comment">-- we have picked Char for letters and decided to use the strict total</a>
    <a id="3836" class="Comment">-- order induced by their injection into ℕ as witnessed by the statement</a>
    <a id="3913" class="Comment">-- open import Data.Trie Char.strictTotalOrder earlier in this file).</a>

    <a id="3988" class="Comment">-- It is parametrised by a set of Values indexed over list of letters.</a>
    <a id="4063" class="Comment">-- Because we focus on the non-dependent case, we pick the constant</a>
    <a id="4135" class="Comment">-- family of Value uniformly equal to Tok. It is trivially compatible</a>
    <a id="4209" class="Comment">-- with the notion of equality underlying the strict total order on Chars.</a>

    <a id="4289" href="README.Data.Trie.NonDependent.html#4289" class="Function">Keywords</a> <a id="4298" class="Symbol">:</a> <a id="4300" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="4304" class="Symbol">_</a>
    <a id="4310" href="README.Data.Trie.NonDependent.html#4289" class="Function">Keywords</a> <a id="4319" class="Symbol">=</a> <a id="4321" href="Data.Trie.html#1479" class="Function">Trie</a> <a id="4326" class="Symbol">(</a><a id="4327" href="Data.Tree.AVL.Value.html#1481" class="Function">const</a> <a id="4333" class="Symbol">_</a> <a id="4335" href="README.Data.Trie.NonDependent.html#2697" class="Field">Tok</a><a id="4338" class="Symbol">)</a> <a id="4340" class="Symbol">_</a>

    <a id="4347" class="Comment">-- We build a trie from the association list so that we may easily</a>
    <a id="4418" class="Comment">-- compute the successive derivatives obtained by eating the</a>
    <a id="4483" class="Comment">-- characters one by one</a>

    <a id="4513" href="README.Data.Trie.NonDependent.html#4513" class="Function">init</a> <a id="4518" class="Symbol">:</a> <a id="4520" href="README.Data.Trie.NonDependent.html#4289" class="Function">Keywords</a>
    <a id="4533" href="README.Data.Trie.NonDependent.html#4513" class="Function">init</a> <a id="4538" class="Symbol">=</a> <a id="4540" href="Data.Trie.html#2978" class="Function">fromList</a> <a id="4549" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="4551" href="Data.List.Base.html#1620" class="Function">List.map</a> <a id="4560" class="Symbol">(</a><a id="4561" href="Data.Product.Base.html#2312" class="Function">Prod.map₁</a> <a id="4571" href="Data.String.Base.html#1533" class="Primitive">String.toList</a><a id="4584" class="Symbol">)</a> <a id="4586" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="4588" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="4594" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="4596" href="Data.List.Fresh.html#6163" class="Function">List#.toList</a> <a id="4609" href="README.Data.Trie.NonDependent.html#3121" class="Field">keywords</a>

    <a id="4623" class="Comment">-- Kickstart the tokeniser with an empty accumulator and the initial</a>
    <a id="4696" class="Comment">-- trie.</a>
    <a id="4709" href="README.Data.Trie.NonDependent.html#4709" class="Function">start</a> <a id="4715" class="Symbol">:</a> <a id="4717" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="4722" href="Agda.Builtin.Char.html#221" class="Postulate">Char</a> <a id="4727" class="Symbol">→</a> <a id="4729" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="4734" href="README.Data.Trie.NonDependent.html#2697" class="Field">Tok</a>
    <a id="4742" href="README.Data.Trie.NonDependent.html#4709" class="Function">start</a> <a id="4748" class="Symbol">=</a> <a id="4750" href="README.Data.Trie.NonDependent.html#4789" class="Function">loop</a> <a id="4755" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a> <a id="4758" href="README.Data.Trie.NonDependent.html#4513" class="Function">init</a>

    <a id="4768" class="Comment">-- The main loop</a>
    <a id="4789" href="README.Data.Trie.NonDependent.html#4789" class="Function">loop</a> <a id="4794" class="Symbol">:</a> <a id="4796" class="Symbol">(</a><a id="4797" href="README.Data.Trie.NonDependent.html#4797" class="Bound">acc</a>  <a id="4802" class="Symbol">:</a> <a id="4804" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="4809" href="Agda.Builtin.Char.html#221" class="Postulate">Char</a><a id="4813" class="Symbol">)</a>  <a id="4816" class="Symbol">→</a> <a id="4818" class="Comment">-- chars read so far in this token</a>
           <a id="4864" class="Symbol">(</a><a id="4865" href="README.Data.Trie.NonDependent.html#4865" class="Bound">toks</a> <a id="4870" class="Symbol">:</a> <a id="4872" href="README.Data.Trie.NonDependent.html#4289" class="Function">Keywords</a><a id="4880" class="Symbol">)</a>   <a id="4884" class="Symbol">→</a> <a id="4886" class="Comment">-- keyword candidates left at this point</a>
           <a id="4938" class="Symbol">(</a><a id="4939" href="README.Data.Trie.NonDependent.html#4939" class="Bound">input</a> <a id="4945" class="Symbol">:</a> <a id="4947" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="4952" href="Agda.Builtin.Char.html#221" class="Postulate">Char</a><a id="4956" class="Symbol">)</a> <a id="4958" class="Symbol">→</a> <a id="4960" class="Comment">-- list of chars to tokenize</a>
           <a id="5000" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="5005" href="README.Data.Trie.NonDependent.html#2697" class="Field">Tok</a>
    <a id="5013" class="Comment">-- Empty input: finish up, check whether we have a non-empty accumulator</a>
    <a id="5090" href="README.Data.Trie.NonDependent.html#4789" class="Function">loop</a> <a id="5095" href="README.Data.Trie.NonDependent.html#5095" class="Bound">acc</a> <a id="5099" href="README.Data.Trie.NonDependent.html#5099" class="Bound">toks</a> <a id="5104" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>         <a id="5115" class="Symbol">=</a> <a id="5117" href="README.Data.Trie.NonDependent.html#5987" class="Function">push</a> <a id="5122" href="README.Data.Trie.NonDependent.html#5095" class="Bound">acc</a> <a id="5126" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>
    <a id="5133" class="Comment">-- At least one character</a>
    <a id="5163" href="README.Data.Trie.NonDependent.html#4789" class="Function">loop</a> <a id="5168" href="README.Data.Trie.NonDependent.html#5168" class="Bound">acc</a> <a id="5172" href="README.Data.Trie.NonDependent.html#5172" class="Bound">toks</a> <a id="5177" class="Symbol">(</a><a id="5178" href="README.Data.Trie.NonDependent.html#5178" class="Bound">c</a> <a id="5180" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="5182" href="README.Data.Trie.NonDependent.html#5182" class="Bound">cs</a><a id="5184" class="Symbol">)</a>   <a id="5188" class="Symbol">=</a> <a id="5190" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="5195" href="README.Data.Trie.NonDependent.html#3350" class="Field">breaking</a> <a id="5204" href="README.Data.Trie.NonDependent.html#5178" class="Bound">c</a> <a id="5206" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="5209" class="Symbol">λ</a> <a id="5211" class="Keyword">where</a>
      <a id="5223" class="Comment">-- if we are supposed to break on this character, we do</a>
      <a id="5285" class="Symbol">(</a><a id="5286" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a> <a id="5291" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5293" href="README.Data.Trie.NonDependent.html#5293" class="Bound">m</a><a id="5294" class="Symbol">)</a>  <a id="5297" class="Symbol">→</a> <a id="5299" href="README.Data.Trie.NonDependent.html#5987" class="Function">push</a> <a id="5304" href="README.Data.Trie.NonDependent.html#5168" class="Bound">acc</a> <a id="5308" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="5310" href="Data.Maybe.Base.html#1583" class="Function">maybe′</a> <a id="5317" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">_∷_</a> <a id="5321" href="Function.Base.html#704" class="Function">id</a> <a id="5324" href="README.Data.Trie.NonDependent.html#5293" class="Bound">m</a> <a id="5326" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="5328" href="README.Data.Trie.NonDependent.html#4709" class="Function">start</a> <a id="5334" href="README.Data.Trie.NonDependent.html#5182" class="Bound">cs</a>
      <a id="5343" class="Comment">-- otherwise we see whether it leads to a recognized keyword</a>
      <a id="5410" class="Symbol">(</a><a id="5411" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a> <a id="5417" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="5419" class="Symbol">_)</a> <a id="5422" class="Symbol">→</a> <a id="5424" href="Function.Base.html#4062" class="Function Operator">case</a> <a id="5429" href="Data.Trie.html#2131" class="Function">lookupValue</a> <a id="5441" href="README.Data.Trie.NonDependent.html#5172" class="Bound">toks</a> <a id="5446" class="Symbol">(</a><a id="5447" href="README.Data.Trie.NonDependent.html#5178" class="Bound">c</a> <a id="5449" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="5451" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="5453" class="Symbol">)</a> <a id="5455" href="Function.Base.html#4062" class="Function Operator">of</a> <a id="5458" class="Symbol">λ</a> <a id="5460" class="Keyword">where</a>
        <a id="5474" class="Comment">-- if so we can forget about the current accumulator and</a>
        <a id="5539" class="Comment">-- restart the tokenizer on the rest of the input</a>
        <a id="5597" class="Symbol">(</a><a id="5598" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="5603" href="README.Data.Trie.NonDependent.html#5603" class="Bound">tok</a><a id="5606" class="Symbol">)</a> <a id="5608" class="Symbol">→</a> <a id="5610" href="README.Data.Trie.NonDependent.html#5603" class="Bound">tok</a> <a id="5614" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="5616" href="README.Data.Trie.NonDependent.html#4709" class="Function">start</a> <a id="5622" href="README.Data.Trie.NonDependent.html#5182" class="Bound">cs</a>
        <a id="5633" class="Comment">-- otherwise we record the character we read in the accumulator,</a>
        <a id="5706" class="Comment">-- compute the derivative of the map of keyword candidates and</a>
        <a id="5777" class="Comment">-- keep going with the rest of the input</a>
        <a id="5826" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>    <a id="5837" class="Symbol">→</a> <a id="5839" href="README.Data.Trie.NonDependent.html#4789" class="Function">loop</a> <a id="5844" class="Symbol">(</a><a id="5845" href="README.Data.Trie.NonDependent.html#5178" class="Bound">c</a> <a id="5847" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="5849" href="README.Data.Trie.NonDependent.html#5168" class="Bound">acc</a><a id="5852" class="Symbol">)</a> <a id="5854" class="Symbol">(</a><a id="5855" href="Data.Trie.html#2375" class="Function">lookupTrie</a> <a id="5866" href="README.Data.Trie.NonDependent.html#5172" class="Bound">toks</a> <a id="5871" href="README.Data.Trie.NonDependent.html#5178" class="Bound">c</a><a id="5872" class="Symbol">)</a> <a id="5874" href="README.Data.Trie.NonDependent.html#5182" class="Bound">cs</a>

    <a id="5882" class="Comment">-- Grab the accumulator and, unless it is empty, push it on top of</a>
    <a id="5953" class="Comment">-- the decoded list of tokens</a>
    <a id="5987" href="README.Data.Trie.NonDependent.html#5987" class="Function">push</a> <a id="5992" class="Symbol">:</a> <a id="5994" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="5999" href="Agda.Builtin.Char.html#221" class="Postulate">Char</a> <a id="6004" class="Symbol">→</a> <a id="6006" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="6011" href="README.Data.Trie.NonDependent.html#2697" class="Field">Tok</a> <a id="6015" class="Symbol">→</a> <a id="6017" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="6022" href="README.Data.Trie.NonDependent.html#2697" class="Field">Tok</a>
    <a id="6030" href="README.Data.Trie.NonDependent.html#5987" class="Function">push</a> <a id="6035" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a> <a id="6038" href="README.Data.Trie.NonDependent.html#6038" class="Bound">ts</a> <a id="6041" class="Symbol">=</a> <a id="6043" href="README.Data.Trie.NonDependent.html#6038" class="Bound">ts</a>
    <a id="6050" href="README.Data.Trie.NonDependent.html#5987" class="CatchallClause Function">push</a><a id="6054" class="CatchallClause"> </a><a id="6055" href="README.Data.Trie.NonDependent.html#6055" class="CatchallClause Bound">cs</a><a id="6057" class="CatchallClause"> </a><a id="6058" href="README.Data.Trie.NonDependent.html#6058" class="CatchallClause Bound">ts</a> <a id="6061" class="Symbol">=</a> <a id="6063" href="README.Data.Trie.NonDependent.html#3522" class="Field">default</a> <a id="6071" class="Symbol">(</a><a id="6072" href="Data.String.Base.html#1566" class="Primitive">String.fromList</a> <a id="6088" class="Symbol">(</a><a id="6089" href="Data.List.Base.html#7001" class="Function">List.reverse</a> <a id="6102" href="README.Data.Trie.NonDependent.html#6055" class="Bound">cs</a><a id="6104" class="Symbol">))</a> <a id="6107" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="6109" href="README.Data.Trie.NonDependent.html#6058" class="Bound">ts</a>


<a id="6114" class="Comment">------------------------------------------------------------------------</a>
<a id="6187" class="Comment">-- Concrete instance</a>

<a id="6209" class="Comment">-- A small set of keywords for a language with expressions of the form</a>
<a id="6280" class="Comment">-- `let x = e in b`.</a>

<a id="6302" class="Keyword">module</a> <a id="LetIn"></a><a id="6309" href="README.Data.Trie.NonDependent.html#6309" class="Module">LetIn</a> <a id="6315" class="Keyword">where</a>

  <a id="6324" class="Keyword">data</a> <a id="LetIn.TOK"></a><a id="6329" href="README.Data.Trie.NonDependent.html#6329" class="Datatype">TOK</a> <a id="6333" class="Symbol">:</a> <a id="6335" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="6339" class="Keyword">where</a>
    <a id="LetIn.TOK.LET"></a><a id="6349" href="README.Data.Trie.NonDependent.html#6349" class="InductiveConstructor">LET</a> <a id="LetIn.TOK.EQ"></a><a id="6353" href="README.Data.Trie.NonDependent.html#6353" class="InductiveConstructor">EQ</a> <a id="LetIn.TOK.IN"></a><a id="6356" href="README.Data.Trie.NonDependent.html#6356" class="InductiveConstructor">IN</a> <a id="6359" class="Symbol">:</a> <a id="6361" href="README.Data.Trie.NonDependent.html#6329" class="Datatype">TOK</a>
    <a id="LetIn.TOK.LPAR"></a><a id="6369" href="README.Data.Trie.NonDependent.html#6369" class="InductiveConstructor">LPAR</a> <a id="LetIn.TOK.RPAR"></a><a id="6374" href="README.Data.Trie.NonDependent.html#6374" class="InductiveConstructor">RPAR</a> <a id="6379" class="Symbol">:</a> <a id="6381" href="README.Data.Trie.NonDependent.html#6329" class="Datatype">TOK</a>
    <a id="LetIn.TOK.ID"></a><a id="6389" href="README.Data.Trie.NonDependent.html#6389" class="InductiveConstructor">ID</a> <a id="6392" class="Symbol">:</a> <a id="6394" href="Agda.Builtin.String.html#318" class="Postulate">String</a> <a id="6401" class="Symbol">→</a> <a id="6403" href="README.Data.Trie.NonDependent.html#6329" class="Datatype">TOK</a>

  <a id="LetIn.keywords"></a><a id="6410" href="README.Data.Trie.NonDependent.html#6410" class="Function">keywords</a> <a id="6419" class="Symbol">:</a> <a id="6421" href="Data.List.Fresh.html#1557" class="Datatype">List#</a> <a id="6427" class="Symbol">(</a><a id="6428" href="Agda.Builtin.String.html#318" class="Postulate">String</a> <a id="6435" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6437" href="README.Data.Trie.NonDependent.html#6329" class="Datatype">TOK</a><a id="6440" class="Symbol">)</a> <a id="6442" class="Symbol">(λ</a> <a id="6445" href="README.Data.Trie.NonDependent.html#6445" class="Bound">a</a> <a id="6447" href="README.Data.Trie.NonDependent.html#6447" class="Bound">b</a> <a id="6449" class="Symbol">→</a> <a id="6451" href="Relation.Nary.html#6519" class="Function Operator">⌊</a> <a id="6453" href="Relation.Nullary.Decidable.Core.html#2177" class="Function">¬?</a> <a id="6456" class="Symbol">((</a><a id="6458" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="6464" href="README.Data.Trie.NonDependent.html#6445" class="Bound">a</a><a id="6465" class="Symbol">)</a> <a id="6467" href="Data.String.Properties.html#2306" class="Function Operator">String.≟</a> <a id="6476" class="Symbol">(</a><a id="6477" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="6483" href="README.Data.Trie.NonDependent.html#6447" class="Bound">b</a><a id="6484" class="Symbol">))</a> <a id="6487" href="Relation.Nary.html#6519" class="Function Operator">⌋</a><a id="6488" class="Symbol">)</a>
  <a id="6492" href="README.Data.Trie.NonDependent.html#6410" class="Function">keywords</a> <a id="6501" class="Symbol">=</a>  <a id="6504" class="Symbol">(</a><a id="6505" class="String">&quot;let&quot;</a> <a id="6511" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6513" href="README.Data.Trie.NonDependent.html#6349" class="InductiveConstructor">LET</a><a id="6516" class="Symbol">)</a>
           <a id="6529" href="Data.List.Fresh.html#2059" class="InductiveConstructor Operator">∷#</a> <a id="6532" class="Symbol">(</a><a id="6533" class="String">&quot;=&quot;</a>   <a id="6539" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6541" href="README.Data.Trie.NonDependent.html#6353" class="InductiveConstructor">EQ</a><a id="6543" class="Symbol">)</a>
           <a id="6556" href="Data.List.Fresh.html#2059" class="InductiveConstructor Operator">∷#</a> <a id="6559" class="Symbol">(</a><a id="6560" class="String">&quot;in&quot;</a>  <a id="6566" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6568" href="README.Data.Trie.NonDependent.html#6356" class="InductiveConstructor">IN</a><a id="6570" class="Symbol">)</a>
           <a id="6583" href="Data.List.Fresh.html#2059" class="InductiveConstructor Operator">∷#</a> <a id="6586" href="Data.List.Fresh.html#1640" class="InductiveConstructor">[]</a>

  <a id="6592" class="Comment">-- Breaking characters: spaces (thrown away) and parentheses (kept)</a>
  <a id="LetIn.breaking"></a><a id="6662" href="README.Data.Trie.NonDependent.html#6662" class="Function">breaking</a> <a id="6671" class="Symbol">:</a> <a id="6673" href="Agda.Builtin.Char.html#221" class="Postulate">Char</a> <a id="6678" class="Symbol">→</a> <a id="6680" href="Data.Product.Base.html#852" class="Function">∃</a> <a id="6682" class="Symbol">(λ</a> <a id="6685" href="README.Data.Trie.NonDependent.html#6685" class="Bound">b</a> <a id="6687" class="Symbol">→</a> <a id="6689" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="6692" href="README.Data.Trie.NonDependent.html#6685" class="Bound">b</a> <a id="6694" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="6699" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="6705" href="README.Data.Trie.NonDependent.html#6329" class="Datatype">TOK</a> <a id="6709" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="6714" href="Level.html#409" class="Record">Lift</a> <a id="6719" href="Level.html#521" class="Function">0ℓ</a> <a id="6722" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a><a id="6723" class="Symbol">)</a>
  <a id="6727" href="README.Data.Trie.NonDependent.html#6662" class="Function">breaking</a> <a id="6736" href="README.Data.Trie.NonDependent.html#6736" class="Bound">c</a> <a id="6738" class="Symbol">=</a> <a id="6740" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="6743" href="Data.Char.Base.html#891" class="Primitive">isSpace</a> <a id="6751" href="README.Data.Trie.NonDependent.html#6736" class="Bound">c</a> <a id="6753" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="6758" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a> <a id="6763" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6765" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a> <a id="6773" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="6778" href="README.Data.Trie.NonDependent.html#6798" class="Function">parens</a> <a id="6785" href="README.Data.Trie.NonDependent.html#6736" class="Bound">c</a> <a id="6787" class="Keyword">where</a>

    <a id="6798" href="README.Data.Trie.NonDependent.html#6798" class="Function">parens</a> <a id="6805" class="Symbol">:</a> <a id="6807" href="Agda.Builtin.Char.html#221" class="Postulate">Char</a> <a id="6812" class="Symbol">→</a> <a id="6814" class="Symbol">_</a>
    <a id="6820" href="README.Data.Trie.NonDependent.html#6798" class="Function">parens</a> <a id="6827" class="String">&#39;(&#39;</a> <a id="6831" class="Symbol">=</a> <a id="6833" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a> <a id="6838" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6840" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="6845" href="README.Data.Trie.NonDependent.html#6369" class="InductiveConstructor">LPAR</a>
    <a id="6854" href="README.Data.Trie.NonDependent.html#6798" class="Function">parens</a> <a id="6861" class="String">&#39;)&#39;</a> <a id="6865" class="Symbol">=</a> <a id="6867" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a> <a id="6872" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6874" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="6879" href="README.Data.Trie.NonDependent.html#6374" class="InductiveConstructor">RPAR</a>
    <a id="6888" href="README.Data.Trie.NonDependent.html#6798" class="Function">parens</a> <a id="6895" class="Symbol">_</a>   <a id="6899" class="Symbol">=</a> <a id="6901" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a> <a id="6907" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6909" class="Symbol">_</a>

  <a id="LetIn.default"></a><a id="6914" href="README.Data.Trie.NonDependent.html#6914" class="Function">default</a> <a id="6922" class="Symbol">:</a> <a id="6924" href="Agda.Builtin.String.html#318" class="Postulate">String</a> <a id="6931" class="Symbol">→</a> <a id="6933" href="README.Data.Trie.NonDependent.html#6329" class="Datatype">TOK</a>
  <a id="6939" href="README.Data.Trie.NonDependent.html#6914" class="Function">default</a> <a id="6947" class="Symbol">=</a> <a id="6949" href="README.Data.Trie.NonDependent.html#6389" class="InductiveConstructor">ID</a>

<a id="letIn"></a><a id="6953" href="README.Data.Trie.NonDependent.html#6953" class="Function">letIn</a> <a id="6959" class="Symbol">:</a> <a id="6961" href="README.Data.Trie.NonDependent.html#2602" class="Record">Lexer</a> <a id="6967" href="Level.html#521" class="Function">0ℓ</a>
<a id="6970" href="README.Data.Trie.NonDependent.html#6953" class="Function">letIn</a> <a id="6976" class="Symbol">=</a> <a id="6978" class="Keyword">record</a> <a id="6985" class="Symbol">{</a> <a id="6987" href="README.Data.Trie.NonDependent.html#6309" class="Module">LetIn</a> <a id="6993" class="Symbol">}</a>

<a id="6996" class="Keyword">open</a> <a id="7001" class="Keyword">import</a> <a id="7008" href="Agda.Builtin.Equality.html" class="Module">Agda.Builtin.Equality</a>

<a id="7031" class="Comment">-- A test case:</a>

<a id="7048" class="Keyword">open</a> <a id="7053" href="README.Data.Trie.NonDependent.html#6309" class="Module">LetIn</a>
<a id="7059" href="README.Data.Trie.NonDependent.html#7059" class="Function">_</a> <a id="7061" class="Symbol">:</a> <a id="7063" href="README.Data.Trie.NonDependent.html#3599" class="Function">tokenize</a> <a id="7072" href="README.Data.Trie.NonDependent.html#6953" class="Function">letIn</a> <a id="7078" class="String">&quot;fix f x = let b = fix f in (f b) x&quot;</a>
  <a id="7117" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="7119" href="README.Data.Trie.NonDependent.html#6389" class="InductiveConstructor">ID</a> <a id="7122" class="String">&quot;fix&quot;</a>
  <a id="7130" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7132" href="README.Data.Trie.NonDependent.html#6389" class="InductiveConstructor">ID</a> <a id="7135" class="String">&quot;f&quot;</a>
  <a id="7141" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7143" href="README.Data.Trie.NonDependent.html#6389" class="InductiveConstructor">ID</a> <a id="7146" class="String">&quot;x&quot;</a>
  <a id="7152" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7154" href="README.Data.Trie.NonDependent.html#6353" class="InductiveConstructor">EQ</a>
  <a id="7159" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7161" href="README.Data.Trie.NonDependent.html#6349" class="InductiveConstructor">LET</a>
  <a id="7167" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7169" href="README.Data.Trie.NonDependent.html#6389" class="InductiveConstructor">ID</a> <a id="7172" class="String">&quot;b&quot;</a>
  <a id="7178" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7180" href="README.Data.Trie.NonDependent.html#6353" class="InductiveConstructor">EQ</a>
  <a id="7185" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7187" href="README.Data.Trie.NonDependent.html#6389" class="InductiveConstructor">ID</a> <a id="7190" class="String">&quot;fix&quot;</a>
  <a id="7198" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7200" href="README.Data.Trie.NonDependent.html#6389" class="InductiveConstructor">ID</a> <a id="7203" class="String">&quot;f&quot;</a>
  <a id="7209" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7211" href="README.Data.Trie.NonDependent.html#6356" class="InductiveConstructor">IN</a>
  <a id="7216" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7218" href="README.Data.Trie.NonDependent.html#6369" class="InductiveConstructor">LPAR</a>
  <a id="7225" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7227" href="README.Data.Trie.NonDependent.html#6389" class="InductiveConstructor">ID</a> <a id="7230" class="String">&quot;f&quot;</a>
  <a id="7236" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7238" href="README.Data.Trie.NonDependent.html#6389" class="InductiveConstructor">ID</a> <a id="7241" class="String">&quot;b&quot;</a>
  <a id="7247" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7249" href="README.Data.Trie.NonDependent.html#6374" class="InductiveConstructor">RPAR</a>
  <a id="7256" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7258" href="README.Data.Trie.NonDependent.html#6389" class="InductiveConstructor">ID</a> <a id="7261" class="String">&quot;x&quot;</a>
  <a id="7267" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="7269" class="InductiveConstructor">[]</a>
<a id="7272" class="Symbol">_</a> <a id="7274" class="Symbol">=</a> <a id="7276" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
</pre></body></html>