<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Design.Decidability</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples of decision procedures and how to use them</a>
<a id="161" class="Comment">------------------------------------------------------------------------</a>

<a id="235" class="Symbol">{-#</a> <a id="239" class="Keyword">OPTIONS</a> <a id="247" class="Pragma">--cubical-compatible</a> <a id="268" class="Pragma">--safe</a> <a id="275" class="Symbol">#-}</a>

<a id="280" class="Keyword">module</a> <a id="287" href="README.Design.Decidability.html" class="Module">README.Design.Decidability</a> <a id="314" class="Keyword">where</a>

<a id="321" class="Keyword">open</a> <a id="326" class="Keyword">import</a> <a id="333" href="Data.Bool.html" class="Module">Data.Bool</a>
<a id="343" class="Keyword">open</a> <a id="348" class="Keyword">import</a> <a id="355" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="370" class="Keyword">using</a> <a id="376" class="Symbol">(</a><a id="377" href="Agda.Builtin.List.html#130" class="Datatype">List</a><a id="381" class="Symbol">;</a> <a id="383" href="Data.List.Base.html#7375" class="InductiveConstructor">[]</a><a id="385" class="Symbol">;</a> <a id="387" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">_∷_</a><a id="390" class="Symbol">)</a>
<a id="392" class="Keyword">open</a> <a id="397" class="Keyword">import</a> <a id="404" href="Data.List.Properties.html" class="Module">Data.List.Properties</a> <a id="425" class="Keyword">using</a> <a id="431" class="Symbol">(</a><a id="432" href="Data.List.Properties.html#2315" class="Function">∷-injective</a><a id="443" class="Symbol">)</a>
<a id="445" class="Keyword">open</a> <a id="450" class="Keyword">import</a> <a id="457" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="466" class="Keyword">open</a> <a id="471" class="Keyword">import</a> <a id="478" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="498" class="Keyword">using</a> <a id="504" class="Symbol">(</a><a id="505" href="Data.Nat.Properties.html#2329" class="Function">suc-injective</a><a id="518" class="Symbol">)</a>
<a id="520" class="Keyword">open</a> <a id="525" class="Keyword">import</a> <a id="532" href="Data.Product.html" class="Module">Data.Product</a>
<a id="545" class="Keyword">open</a> <a id="550" class="Keyword">import</a> <a id="557" href="Data.Unit.html" class="Module">Data.Unit</a>
<a id="567" class="Keyword">open</a> <a id="572" class="Keyword">import</a> <a id="579" href="Function.html" class="Module">Function</a>
<a id="588" class="Keyword">open</a> <a id="593" class="Keyword">import</a> <a id="600" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
<a id="638" class="Keyword">open</a> <a id="643" class="Keyword">import</a> <a id="650" href="Relation.Nary.html" class="Module">Relation.Nary</a>

<a id="665" class="Comment">------------------------------------------------------------------------</a>
<a id="738" class="Comment">-- Reflects</a>

<a id="751" class="Keyword">open</a> <a id="756" class="Keyword">import</a> <a id="763" href="Relation.Nullary.Reflects.html" class="Module">Relation.Nullary.Reflects</a>

<a id="790" class="Keyword">infix</a> <a id="796" class="Number">4</a> <a id="798" href="README.Design.Decidability.html#1933" class="Function Operator">_≟₀_</a> <a id="803" href="README.Design.Decidability.html#2561" class="Function Operator">_≟₁_</a> <a id="808" href="README.Design.Decidability.html#3150" class="Function Operator">_≟₂_</a>

<a id="814" class="Comment">-- A proof of `Reflects P b` shows that a proposition `P` has the truth value of</a>
<a id="895" class="Comment">-- the boolean `b`. A proof of `Reflects P true` amounts to a proof of `P`, and</a>
<a id="975" class="Comment">-- a proof of `Reflects P false` amounts to a refutation of `P`.</a>

<a id="ex₀"></a><a id="1041" href="README.Design.Decidability.html#1041" class="Function">ex₀</a> <a id="1045" class="Symbol">:</a> <a id="1047" class="Symbol">(</a><a id="1048" href="README.Design.Decidability.html#1048" class="Bound">n</a> <a id="1050" class="Symbol">:</a> <a id="1052" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="1053" class="Symbol">)</a> <a id="1055" class="Symbol">→</a> <a id="1057" href="Relation.Nullary.Reflects.html#899" class="Datatype">Reflects</a> <a id="1066" class="Symbol">(</a><a id="1067" href="README.Design.Decidability.html#1048" class="Bound">n</a> <a id="1069" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="1071" href="README.Design.Decidability.html#1048" class="Bound">n</a><a id="1072" class="Symbol">)</a> <a id="1074" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a>
<a id="1079" href="README.Design.Decidability.html#1041" class="Function">ex₀</a> <a id="1083" href="README.Design.Decidability.html#1083" class="Bound">n</a> <a id="1085" class="Symbol">=</a> <a id="1087" href="Relation.Nullary.Reflects.html#947" class="InductiveConstructor">ofʸ</a> <a id="1091" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="ex₁"></a><a id="1097" href="README.Design.Decidability.html#1097" class="Function">ex₁</a> <a id="1101" class="Symbol">:</a> <a id="1103" class="Symbol">(</a><a id="1104" href="README.Design.Decidability.html#1104" class="Bound">n</a> <a id="1106" class="Symbol">:</a> <a id="1108" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="1109" class="Symbol">)</a> <a id="1111" class="Symbol">→</a> <a id="1113" href="Relation.Nullary.Reflects.html#899" class="Datatype">Reflects</a> <a id="1122" class="Symbol">(</a><a id="1123" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="1128" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="1130" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1134" href="README.Design.Decidability.html#1104" class="Bound">n</a><a id="1135" class="Symbol">)</a> <a id="1137" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a>
<a id="1143" href="README.Design.Decidability.html#1097" class="Function">ex₁</a> <a id="1147" href="README.Design.Decidability.html#1147" class="Bound">n</a> <a id="1149" class="Symbol">=</a> <a id="1151" href="Relation.Nullary.Reflects.html#984" class="InductiveConstructor">ofⁿ</a> <a id="1155" class="Symbol">λ</a> <a id="1157" class="Symbol">()</a>

<a id="ex₂"></a><a id="1161" href="README.Design.Decidability.html#1161" class="Function">ex₂</a> <a id="1165" class="Symbol">:</a> <a id="1167" class="Symbol">(</a><a id="1168" href="README.Design.Decidability.html#1168" class="Bound">b</a> <a id="1170" class="Symbol">:</a> <a id="1172" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="1176" class="Symbol">)</a> <a id="1178" class="Symbol">→</a> <a id="1180" href="Relation.Nullary.Reflects.html#899" class="Datatype">Reflects</a> <a id="1189" class="Symbol">(</a><a id="1190" href="Data.Bool.Base.html#1460" class="Function">T</a> <a id="1192" href="README.Design.Decidability.html#1168" class="Bound">b</a><a id="1193" class="Symbol">)</a> <a id="1195" href="README.Design.Decidability.html#1168" class="Bound">b</a>
<a id="1197" href="README.Design.Decidability.html#1161" class="Function">ex₂</a> <a id="1201" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a> <a id="1207" class="Symbol">=</a> <a id="1209" href="Relation.Nullary.Reflects.html#984" class="InductiveConstructor">ofⁿ</a> <a id="1213" href="Function.Base.html#704" class="Function">id</a>
<a id="1216" href="README.Design.Decidability.html#1161" class="Function">ex₂</a> <a id="1220" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a>  <a id="1226" class="Symbol">=</a> <a id="1228" href="Relation.Nullary.Reflects.html#947" class="InductiveConstructor">ofʸ</a> <a id="1232" href="Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a>

<a id="1236" class="Comment">------------------------------------------------------------------------</a>
<a id="1309" class="Comment">-- Dec</a>

<a id="1317" class="Keyword">open</a> <a id="1322" class="Keyword">import</a> <a id="1329" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="1357" class="Comment">-- A proof of `Dec P` is a proof of `Reflects P b` for some `b`.</a>
<a id="1422" class="Comment">-- `Dec P` is declared as a record, with fields:</a>
<a id="1471" class="Comment">--   does : Bool</a>
<a id="1488" class="Comment">--   proof : Reflects P does</a>

<a id="ex₃"></a><a id="1518" href="README.Design.Decidability.html#1518" class="Function">ex₃</a> <a id="1522" class="Symbol">:</a> <a id="1524" class="Symbol">(</a><a id="1525" href="README.Design.Decidability.html#1525" class="Bound">b</a> <a id="1527" class="Symbol">:</a> <a id="1529" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="1533" class="Symbol">)</a> <a id="1535" class="Symbol">→</a> <a id="1537" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="1541" class="Symbol">(</a><a id="1542" href="Data.Bool.Base.html#1460" class="Function">T</a> <a id="1544" href="README.Design.Decidability.html#1525" class="Bound">b</a><a id="1545" class="Symbol">)</a>
<a id="1547" href="Relation.Nullary.Decidable.Core.html#1560" class="Field">does</a>  <a id="1553" class="Symbol">(</a><a id="1554" href="README.Design.Decidability.html#1518" class="Function">ex₃</a> <a id="1558" href="README.Design.Decidability.html#1558" class="Bound">b</a><a id="1559" class="Symbol">)</a> <a id="1561" class="Symbol">=</a> <a id="1563" href="README.Design.Decidability.html#1558" class="Bound">b</a>
<a id="1565" href="Relation.Nullary.Decidable.Core.html#1577" class="Field">proof</a> <a id="1571" class="Symbol">(</a><a id="1572" href="README.Design.Decidability.html#1518" class="Function">ex₃</a> <a id="1576" href="README.Design.Decidability.html#1576" class="Bound">b</a><a id="1577" class="Symbol">)</a> <a id="1579" class="Symbol">=</a> <a id="1581" href="README.Design.Decidability.html#1161" class="Function">ex₂</a> <a id="1585" href="README.Design.Decidability.html#1576" class="Bound">b</a>

<a id="1588" class="Comment">-- We also have pattern synonyms `yes` and `no`, allowing both fields to be</a>
<a id="1664" class="Comment">-- given at once.</a>

<a id="ex₄"></a><a id="1683" href="README.Design.Decidability.html#1683" class="Function">ex₄</a> <a id="1687" class="Symbol">:</a> <a id="1689" class="Symbol">(</a><a id="1690" href="README.Design.Decidability.html#1690" class="Bound">n</a> <a id="1692" class="Symbol">:</a> <a id="1694" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="1695" class="Symbol">)</a> <a id="1697" class="Symbol">→</a> <a id="1699" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="1703" class="Symbol">(</a><a id="1704" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="1709" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="1711" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="1715" href="README.Design.Decidability.html#1690" class="Bound">n</a><a id="1716" class="Symbol">)</a>
<a id="1718" href="README.Design.Decidability.html#1683" class="Function">ex₄</a> <a id="1722" href="README.Design.Decidability.html#1722" class="Bound">n</a> <a id="1724" class="Symbol">=</a> <a id="1726" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="1729" class="Symbol">λ</a> <a id="1731" class="Symbol">()</a>

<a id="1735" class="Comment">-- It is possible, but not ideal, to define recursive decision procedures using</a>
<a id="1815" class="Comment">-- only the `yes` and `no` patterns. The following procedure decides whether two</a>
<a id="1896" class="Comment">-- given natural numbers are equal.</a>

<a id="_≟₀_"></a><a id="1933" href="README.Design.Decidability.html#1933" class="Function Operator">_≟₀_</a> <a id="1938" class="Symbol">:</a> <a id="1940" class="Symbol">(</a><a id="1941" href="README.Design.Decidability.html#1941" class="Bound">m</a> <a id="1943" href="README.Design.Decidability.html#1943" class="Bound">n</a> <a id="1945" class="Symbol">:</a> <a id="1947" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="1948" class="Symbol">)</a> <a id="1950" class="Symbol">→</a> <a id="1952" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="1956" class="Symbol">(</a><a id="1957" href="README.Design.Decidability.html#1941" class="Bound">m</a> <a id="1959" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="1961" href="README.Design.Decidability.html#1943" class="Bound">n</a><a id="1962" class="Symbol">)</a>
<a id="1964" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="1970" href="README.Design.Decidability.html#1933" class="Function Operator">≟₀</a> <a id="1973" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="1979" class="Symbol">=</a> <a id="1981" href="Relation.Nullary.Decidable.Core.html#1627" class="InductiveConstructor">yes</a> <a id="1985" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="1990" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="1996" href="README.Design.Decidability.html#1933" class="Function Operator">≟₀</a> <a id="1999" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2003" href="README.Design.Decidability.html#2003" class="Bound">n</a> <a id="2005" class="Symbol">=</a> <a id="2007" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="2010" class="Symbol">λ</a> <a id="2012" class="Symbol">()</a>
<a id="2015" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2019" href="README.Design.Decidability.html#2019" class="Bound">m</a> <a id="2021" href="README.Design.Decidability.html#1933" class="Function Operator">≟₀</a> <a id="2024" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="2030" class="Symbol">=</a> <a id="2032" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="2035" class="Symbol">λ</a> <a id="2037" class="Symbol">()</a>
<a id="2040" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2044" href="README.Design.Decidability.html#2044" class="Bound">m</a> <a id="2046" href="README.Design.Decidability.html#1933" class="Function Operator">≟₀</a> <a id="2049" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2053" href="README.Design.Decidability.html#2053" class="Bound">n</a> <a id="2055" class="Keyword">with</a> <a id="2060" href="README.Design.Decidability.html#2044" class="Bound">m</a> <a id="2062" href="README.Design.Decidability.html#1933" class="Function Operator">≟₀</a> <a id="2065" href="README.Design.Decidability.html#2053" class="Bound">n</a>
<a id="2067" class="Symbol">...</a> <a id="2071" class="Symbol">|</a> <a id="2073" href="Relation.Nullary.Decidable.Core.html#1627" class="InductiveConstructor">yes</a> <a id="2077" href="README.Design.Decidability.html#2077" class="Bound">p</a> <a id="2079" class="Symbol">=</a> <a id="2081" href="Relation.Nullary.Decidable.Core.html#1627" class="InductiveConstructor">yes</a> <a id="2085" class="Symbol">(</a><a id="2086" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="2091" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2095" href="README.Design.Decidability.html#2077" class="Bound">p</a><a id="2096" class="Symbol">)</a>
<a id="2098" class="Symbol">...</a> <a id="2102" class="Symbol">|</a> <a id="2104" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="2107" href="README.Design.Decidability.html#2107" class="Bound">¬p</a> <a id="2110" class="Symbol">=</a> <a id="2112" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="2115" class="Symbol">(</a><a id="2116" href="README.Design.Decidability.html#2107" class="Bound">¬p</a> <a id="2119" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="2121" href="Data.Nat.Properties.html#2329" class="Function">suc-injective</a><a id="2134" class="Symbol">)</a>

<a id="2137" class="Comment">-- In this case, we can see that `does (suc m ≟ suc n)` should be equal to</a>
<a id="2212" class="Comment">-- `does (m ≟ n)`, because a `yes` from `m ≟ n` gives rise to a `yes` from the</a>
<a id="2291" class="Comment">-- result, and similarly for `no`. However, in the above definition, this</a>
<a id="2365" class="Comment">-- equality does not hold definitionally, because we always do a case split</a>
<a id="2441" class="Comment">-- before returning a result. To avoid this, we can return the `does` part</a>
<a id="2516" class="Comment">-- separately, before any pattern matching.</a>

<a id="_≟₁_"></a><a id="2561" href="README.Design.Decidability.html#2561" class="Function Operator">_≟₁_</a> <a id="2566" class="Symbol">:</a> <a id="2568" class="Symbol">(</a><a id="2569" href="README.Design.Decidability.html#2569" class="Bound">m</a> <a id="2571" href="README.Design.Decidability.html#2571" class="Bound">n</a> <a id="2573" class="Symbol">:</a> <a id="2575" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2576" class="Symbol">)</a> <a id="2578" class="Symbol">→</a> <a id="2580" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="2584" class="Symbol">(</a><a id="2585" href="README.Design.Decidability.html#2569" class="Bound">m</a> <a id="2587" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2589" href="README.Design.Decidability.html#2571" class="Bound">n</a><a id="2590" class="Symbol">)</a>
<a id="2592" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="2598" href="README.Design.Decidability.html#2561" class="Function Operator">≟₁</a> <a id="2601" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="2607" class="Symbol">=</a> <a id="2609" href="Relation.Nullary.Decidable.Core.html#1627" class="InductiveConstructor">yes</a> <a id="2613" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="2618" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="2624" href="README.Design.Decidability.html#2561" class="Function Operator">≟₁</a> <a id="2627" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2631" href="README.Design.Decidability.html#2631" class="Bound">n</a> <a id="2633" class="Symbol">=</a> <a id="2635" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="2638" class="Symbol">λ</a> <a id="2640" class="Symbol">()</a>
<a id="2643" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2647" href="README.Design.Decidability.html#2647" class="Bound">m</a> <a id="2649" href="README.Design.Decidability.html#2561" class="Function Operator">≟₁</a> <a id="2652" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="2658" class="Symbol">=</a> <a id="2660" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="2663" class="Symbol">λ</a> <a id="2665" class="Symbol">()</a>
<a id="2668" href="Relation.Nullary.Decidable.Core.html#1560" class="Field">does</a>  <a id="2674" class="Symbol">(</a><a id="2675" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2679" href="README.Design.Decidability.html#2679" class="Bound">m</a> <a id="2681" href="README.Design.Decidability.html#2561" class="Function Operator">≟₁</a> <a id="2684" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2688" href="README.Design.Decidability.html#2688" class="Bound">n</a><a id="2689" class="Symbol">)</a> <a id="2691" class="Symbol">=</a> <a id="2693" href="Relation.Nullary.Decidable.Core.html#1560" class="Field">does</a> <a id="2698" class="Symbol">(</a><a id="2699" href="README.Design.Decidability.html#2679" class="Bound">m</a> <a id="2701" href="README.Design.Decidability.html#2561" class="Function Operator">≟₁</a> <a id="2704" href="README.Design.Decidability.html#2688" class="Bound">n</a><a id="2705" class="Symbol">)</a>
<a id="2707" href="Relation.Nullary.Decidable.Core.html#1577" class="Field">proof</a> <a id="2713" class="Symbol">(</a><a id="2714" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2718" href="README.Design.Decidability.html#2718" class="Bound">m</a> <a id="2720" href="README.Design.Decidability.html#2561" class="Function Operator">≟₁</a> <a id="2723" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2727" href="README.Design.Decidability.html#2727" class="Bound">n</a><a id="2728" class="Symbol">)</a> <a id="2730" class="Keyword">with</a> <a id="2735" href="README.Design.Decidability.html#2718" class="Bound">m</a> <a id="2737" href="README.Design.Decidability.html#2561" class="Function Operator">≟₁</a> <a id="2740" href="README.Design.Decidability.html#2727" class="Bound">n</a>
<a id="2742" class="Symbol">...</a> <a id="2746" class="Symbol">|</a> <a id="2748" href="Relation.Nullary.Decidable.Core.html#1627" class="InductiveConstructor">yes</a> <a id="2752" href="README.Design.Decidability.html#2752" class="Bound">p</a> <a id="2754" class="Symbol">=</a> <a id="2756" href="Relation.Nullary.Reflects.html#947" class="InductiveConstructor">ofʸ</a> <a id="2760" class="Symbol">(</a><a id="2761" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="2766" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2770" href="README.Design.Decidability.html#2752" class="Bound">p</a><a id="2771" class="Symbol">)</a>
<a id="2773" class="Symbol">...</a> <a id="2777" class="Symbol">|</a> <a id="2779" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="2782" href="README.Design.Decidability.html#2782" class="Bound">¬p</a> <a id="2785" class="Symbol">=</a> <a id="2787" href="Relation.Nullary.Reflects.html#984" class="InductiveConstructor">ofⁿ</a> <a id="2791" class="Symbol">(</a><a id="2792" href="README.Design.Decidability.html#2782" class="Bound">¬p</a> <a id="2795" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="2797" href="Data.Nat.Properties.html#2329" class="Function">suc-injective</a><a id="2810" class="Symbol">)</a>

<a id="2813" class="Comment">-- We now get definitional equalities such as the following.</a>

<a id="2875" href="README.Design.Decidability.html#2875" class="Function">_</a> <a id="2877" class="Symbol">:</a> <a id="2879" class="Symbol">(</a><a id="2880" href="README.Design.Decidability.html#2880" class="Bound">m</a> <a id="2882" href="README.Design.Decidability.html#2882" class="Bound">n</a> <a id="2884" class="Symbol">:</a> <a id="2886" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2887" class="Symbol">)</a> <a id="2889" class="Symbol">→</a> <a id="2891" href="Relation.Nullary.Decidable.Core.html#1560" class="Field">does</a> <a id="2896" class="Symbol">(</a><a id="2897" class="Number">5</a> <a id="2899" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2901" href="README.Design.Decidability.html#2880" class="Bound">m</a> <a id="2903" href="README.Design.Decidability.html#2561" class="Function Operator">≟₁</a> <a id="2906" class="Number">3</a> <a id="2908" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2910" href="README.Design.Decidability.html#2882" class="Bound">n</a><a id="2911" class="Symbol">)</a> <a id="2913" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2915" href="Relation.Nullary.Decidable.Core.html#1560" class="Field">does</a> <a id="2920" class="Symbol">(</a><a id="2921" class="Number">2</a> <a id="2923" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2925" href="README.Design.Decidability.html#2880" class="Bound">m</a> <a id="2927" href="README.Design.Decidability.html#2561" class="Function Operator">≟₁</a> <a id="2930" href="README.Design.Decidability.html#2882" class="Bound">n</a><a id="2931" class="Symbol">)</a>
<a id="2933" class="Symbol">_</a> <a id="2935" class="Symbol">=</a> <a id="2937" class="Symbol">λ</a> <a id="2939" href="README.Design.Decidability.html#2939" class="Bound">m</a> <a id="2941" href="README.Design.Decidability.html#2941" class="Bound">n</a> <a id="2943" class="Symbol">→</a> <a id="2945" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="2951" class="Comment">-- Even better, from a maintainability point of view, is to use `map` or `map′`,</a>
<a id="3032" class="Comment">-- both of which capture the pattern of the `does` field remaining the same, but</a>
<a id="3113" class="Comment">-- the `proof` field being updated.</a>

<a id="_≟₂_"></a><a id="3150" href="README.Design.Decidability.html#3150" class="Function Operator">_≟₂_</a> <a id="3155" class="Symbol">:</a> <a id="3157" class="Symbol">(</a><a id="3158" href="README.Design.Decidability.html#3158" class="Bound">m</a> <a id="3160" href="README.Design.Decidability.html#3160" class="Bound">n</a> <a id="3162" class="Symbol">:</a> <a id="3164" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="3165" class="Symbol">)</a> <a id="3167" class="Symbol">→</a> <a id="3169" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="3173" class="Symbol">(</a><a id="3174" href="README.Design.Decidability.html#3158" class="Bound">m</a> <a id="3176" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="3178" href="README.Design.Decidability.html#3160" class="Bound">n</a><a id="3179" class="Symbol">)</a>
<a id="3181" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="3187" href="README.Design.Decidability.html#3150" class="Function Operator">≟₂</a> <a id="3190" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="3196" class="Symbol">=</a> <a id="3198" href="Relation.Nullary.Decidable.Core.html#1627" class="InductiveConstructor">yes</a> <a id="3202" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
<a id="3207" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="3213" href="README.Design.Decidability.html#3150" class="Function Operator">≟₂</a> <a id="3216" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="3220" href="README.Design.Decidability.html#3220" class="Bound">n</a> <a id="3222" class="Symbol">=</a> <a id="3224" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="3227" class="Symbol">λ</a> <a id="3229" class="Symbol">()</a>
<a id="3232" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="3236" href="README.Design.Decidability.html#3236" class="Bound">m</a> <a id="3238" href="README.Design.Decidability.html#3150" class="Function Operator">≟₂</a> <a id="3241" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>  <a id="3247" class="Symbol">=</a> <a id="3249" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="3252" class="Symbol">λ</a> <a id="3254" class="Symbol">()</a>
<a id="3257" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="3261" href="README.Design.Decidability.html#3261" class="Bound">m</a> <a id="3263" href="README.Design.Decidability.html#3150" class="Function Operator">≟₂</a> <a id="3266" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="3270" href="README.Design.Decidability.html#3270" class="Bound">n</a> <a id="3272" class="Symbol">=</a> <a id="3274" href="Relation.Nullary.Decidable.Core.html#4793" class="Function">map′</a> <a id="3279" class="Symbol">(</a><a id="3280" href="Relation.Binary.PropositionalEquality.Core.html#1158" class="Function">cong</a> <a id="3285" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="3288" class="Symbol">)</a> <a id="3290" href="Data.Nat.Properties.html#2329" class="Function">suc-injective</a> <a id="3304" class="Symbol">(</a><a id="3305" href="README.Design.Decidability.html#3261" class="Bound">m</a> <a id="3307" href="README.Design.Decidability.html#3150" class="Function Operator">≟₂</a> <a id="3310" href="README.Design.Decidability.html#3270" class="Bound">n</a><a id="3311" class="Symbol">)</a>

<a id="3314" href="README.Design.Decidability.html#3314" class="Function">_</a> <a id="3316" class="Symbol">:</a> <a id="3318" class="Symbol">(</a><a id="3319" href="README.Design.Decidability.html#3319" class="Bound">m</a> <a id="3321" href="README.Design.Decidability.html#3321" class="Bound">n</a> <a id="3323" class="Symbol">:</a> <a id="3325" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="3326" class="Symbol">)</a> <a id="3328" class="Symbol">→</a> <a id="3330" href="Relation.Nullary.Decidable.Core.html#1560" class="Field">does</a> <a id="3335" class="Symbol">(</a><a id="3336" class="Number">5</a> <a id="3338" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3340" href="README.Design.Decidability.html#3319" class="Bound">m</a> <a id="3342" href="README.Design.Decidability.html#3150" class="Function Operator">≟₂</a> <a id="3345" class="Number">3</a> <a id="3347" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3349" href="README.Design.Decidability.html#3321" class="Bound">n</a><a id="3350" class="Symbol">)</a> <a id="3352" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="3354" href="Relation.Nullary.Decidable.Core.html#1560" class="Field">does</a> <a id="3359" class="Symbol">(</a><a id="3360" class="Number">2</a> <a id="3362" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3364" href="README.Design.Decidability.html#3319" class="Bound">m</a> <a id="3366" href="README.Design.Decidability.html#3150" class="Function Operator">≟₂</a> <a id="3369" href="README.Design.Decidability.html#3321" class="Bound">n</a><a id="3370" class="Symbol">)</a>
<a id="3372" class="Symbol">_</a> <a id="3374" class="Symbol">=</a> <a id="3376" class="Symbol">λ</a> <a id="3378" href="README.Design.Decidability.html#3378" class="Bound">m</a> <a id="3380" href="README.Design.Decidability.html#3380" class="Bound">n</a> <a id="3382" class="Symbol">→</a> <a id="3384" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="3390" class="Comment">-- `map′` can be used in conjunction with combinators such as `_⊎-dec_` and</a>
<a id="3466" class="Comment">-- `_×-dec_` to build complex (simply typed) decision procedures.</a>

<a id="3533" class="Keyword">module</a> <a id="ListDecEq₀"></a><a id="3540" href="README.Design.Decidability.html#3540" class="Module">ListDecEq₀</a> <a id="3551" class="Symbol">{</a><a id="3552" href="README.Design.Decidability.html#3552" class="Bound">a</a><a id="3553" class="Symbol">}</a> <a id="3555" class="Symbol">{</a><a id="3556" href="README.Design.Decidability.html#3556" class="Bound">A</a> <a id="3558" class="Symbol">:</a> <a id="3560" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3564" href="README.Design.Decidability.html#3552" class="Bound">a</a><a id="3565" class="Symbol">}</a> <a id="3567" class="Symbol">(</a><a id="3568" href="README.Design.Decidability.html#3568" class="Bound Operator">_≟ᴬ_</a> <a id="3573" class="Symbol">:</a> <a id="3575" class="Symbol">(</a><a id="3576" href="README.Design.Decidability.html#3576" class="Bound">x</a> <a id="3578" href="README.Design.Decidability.html#3578" class="Bound">y</a> <a id="3580" class="Symbol">:</a> <a id="3582" href="README.Design.Decidability.html#3556" class="Bound">A</a><a id="3583" class="Symbol">)</a> <a id="3585" class="Symbol">→</a> <a id="3587" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="3591" class="Symbol">(</a><a id="3592" href="README.Design.Decidability.html#3576" class="Bound">x</a> <a id="3594" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="3596" href="README.Design.Decidability.html#3578" class="Bound">y</a><a id="3597" class="Symbol">))</a> <a id="3600" class="Keyword">where</a>

  <a id="ListDecEq₀._≟ᴸᴬ_"></a><a id="3609" href="README.Design.Decidability.html#3609" class="Function Operator">_≟ᴸᴬ_</a> <a id="3615" class="Symbol">:</a> <a id="3617" class="Symbol">(</a><a id="3618" href="README.Design.Decidability.html#3618" class="Bound">xs</a> <a id="3621" href="README.Design.Decidability.html#3621" class="Bound">ys</a> <a id="3624" class="Symbol">:</a> <a id="3626" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="3631" href="README.Design.Decidability.html#3556" class="Bound">A</a><a id="3632" class="Symbol">)</a> <a id="3634" class="Symbol">→</a> <a id="3636" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="3640" class="Symbol">(</a><a id="3641" href="README.Design.Decidability.html#3618" class="Bound">xs</a> <a id="3644" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="3646" href="README.Design.Decidability.html#3621" class="Bound">ys</a><a id="3648" class="Symbol">)</a>
  <a id="3652" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>       <a id="3661" href="README.Design.Decidability.html#3609" class="Function Operator">≟ᴸᴬ</a> <a id="3665" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>       <a id="3674" class="Symbol">=</a> <a id="3676" href="Relation.Nullary.Decidable.Core.html#1627" class="InductiveConstructor">yes</a> <a id="3680" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
  <a id="3687" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>       <a id="3696" href="README.Design.Decidability.html#3609" class="Function Operator">≟ᴸᴬ</a> <a id="3700" class="Symbol">(</a><a id="3701" href="README.Design.Decidability.html#3701" class="Bound">y</a> <a id="3703" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="3705" href="README.Design.Decidability.html#3705" class="Bound">ys</a><a id="3707" class="Symbol">)</a> <a id="3709" class="Symbol">=</a> <a id="3711" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="3714" class="Symbol">λ</a> <a id="3716" class="Symbol">()</a>
  <a id="3721" class="Symbol">(</a><a id="3722" href="README.Design.Decidability.html#3722" class="Bound">x</a> <a id="3724" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="3726" href="README.Design.Decidability.html#3726" class="Bound">xs</a><a id="3728" class="Symbol">)</a> <a id="3730" href="README.Design.Decidability.html#3609" class="Function Operator">≟ᴸᴬ</a> <a id="3734" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>       <a id="3743" class="Symbol">=</a> <a id="3745" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="3748" class="Symbol">λ</a> <a id="3750" class="Symbol">()</a>
  <a id="3755" class="Symbol">(</a><a id="3756" href="README.Design.Decidability.html#3756" class="Bound">x</a> <a id="3758" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="3760" href="README.Design.Decidability.html#3760" class="Bound">xs</a><a id="3762" class="Symbol">)</a> <a id="3764" href="README.Design.Decidability.html#3609" class="Function Operator">≟ᴸᴬ</a> <a id="3768" class="Symbol">(</a><a id="3769" href="README.Design.Decidability.html#3769" class="Bound">y</a> <a id="3771" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="3773" href="README.Design.Decidability.html#3773" class="Bound">ys</a><a id="3775" class="Symbol">)</a> <a id="3777" class="Symbol">=</a>
    <a id="3783" href="Relation.Nullary.Decidable.Core.html#4793" class="Function">map′</a> <a id="3788" class="Symbol">(</a><a id="3789" href="Data.Product.Base.html#3109" class="Function">uncurry</a> <a id="3797" class="Symbol">(</a><a id="3798" href="Relation.Binary.PropositionalEquality.Core.html#1395" class="Function">cong₂</a> <a id="3804" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">_∷_</a><a id="3807" class="Symbol">))</a> <a id="3810" href="Data.List.Properties.html#2315" class="Function">∷-injective</a> <a id="3822" class="Symbol">(</a><a id="3823" href="README.Design.Decidability.html#3756" class="Bound">x</a> <a id="3825" href="README.Design.Decidability.html#3568" class="Bound Operator">≟ᴬ</a> <a id="3828" href="README.Design.Decidability.html#3769" class="Bound">y</a> <a id="3830" href="Relation.Nullary.Decidable.Core.html#2269" class="Function Operator">×-dec</a> <a id="3836" href="README.Design.Decidability.html#3760" class="Bound">xs</a> <a id="3839" href="README.Design.Decidability.html#3609" class="Function Operator">≟ᴸᴬ</a> <a id="3843" href="README.Design.Decidability.html#3773" class="Bound">ys</a><a id="3845" class="Symbol">)</a>

<a id="3848" class="Comment">-- The final case says that `x ∷ xs ≡ y ∷ ys` exactly when `x ≡ y` *and*</a>
<a id="3921" class="Comment">-- `xs ≡ ys`. The proofs are updated by the first two arguments to `map′`.</a>

<a id="3997" class="Comment">-- In the case of ≡-equality tests, the pattern</a>
<a id="4045" class="Comment">-- `map′ (congₙ c) c-injective (x₀ ≟ y₀ ×-dec ... ×-dec xₙ₋₁ ≟ yₙ₋₁)`</a>
<a id="4115" class="Comment">-- is captured by `≟-mapₙ n c c-injective (x₀ ≟ y₀) ... (xₙ₋₁ ≟ yₙ₋₁)`.</a>

<a id="4188" class="Keyword">module</a> <a id="ListDecEq₁"></a><a id="4195" href="README.Design.Decidability.html#4195" class="Module">ListDecEq₁</a> <a id="4206" class="Symbol">{</a><a id="4207" href="README.Design.Decidability.html#4207" class="Bound">a</a><a id="4208" class="Symbol">}</a> <a id="4210" class="Symbol">{</a><a id="4211" href="README.Design.Decidability.html#4211" class="Bound">A</a> <a id="4213" class="Symbol">:</a> <a id="4215" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="4219" href="README.Design.Decidability.html#4207" class="Bound">a</a><a id="4220" class="Symbol">}</a> <a id="4222" class="Symbol">(</a><a id="4223" href="README.Design.Decidability.html#4223" class="Bound Operator">_≟ᴬ_</a> <a id="4228" class="Symbol">:</a> <a id="4230" class="Symbol">(</a><a id="4231" href="README.Design.Decidability.html#4231" class="Bound">x</a> <a id="4233" href="README.Design.Decidability.html#4233" class="Bound">y</a> <a id="4235" class="Symbol">:</a> <a id="4237" href="README.Design.Decidability.html#4211" class="Bound">A</a><a id="4238" class="Symbol">)</a> <a id="4240" class="Symbol">→</a> <a id="4242" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="4246" class="Symbol">(</a><a id="4247" href="README.Design.Decidability.html#4231" class="Bound">x</a> <a id="4249" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4251" href="README.Design.Decidability.html#4233" class="Bound">y</a><a id="4252" class="Symbol">))</a> <a id="4255" class="Keyword">where</a>

  <a id="ListDecEq₁._≟ᴸᴬ_"></a><a id="4264" href="README.Design.Decidability.html#4264" class="Function Operator">_≟ᴸᴬ_</a> <a id="4270" class="Symbol">:</a> <a id="4272" class="Symbol">(</a><a id="4273" href="README.Design.Decidability.html#4273" class="Bound">xs</a> <a id="4276" href="README.Design.Decidability.html#4276" class="Bound">ys</a> <a id="4279" class="Symbol">:</a> <a id="4281" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="4286" href="README.Design.Decidability.html#4211" class="Bound">A</a><a id="4287" class="Symbol">)</a> <a id="4289" class="Symbol">→</a> <a id="4291" href="Relation.Nullary.Decidable.Core.html#1490" class="Record">Dec</a> <a id="4295" class="Symbol">(</a><a id="4296" href="README.Design.Decidability.html#4273" class="Bound">xs</a> <a id="4299" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4301" href="README.Design.Decidability.html#4276" class="Bound">ys</a><a id="4303" class="Symbol">)</a>
  <a id="4307" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>       <a id="4316" href="README.Design.Decidability.html#4264" class="Function Operator">≟ᴸᴬ</a> <a id="4320" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>       <a id="4329" class="Symbol">=</a> <a id="4331" href="Relation.Nullary.Decidable.Core.html#1627" class="InductiveConstructor">yes</a> <a id="4335" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
  <a id="4342" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>       <a id="4351" href="README.Design.Decidability.html#4264" class="Function Operator">≟ᴸᴬ</a> <a id="4355" class="Symbol">(</a><a id="4356" href="README.Design.Decidability.html#4356" class="Bound">y</a> <a id="4358" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="4360" href="README.Design.Decidability.html#4360" class="Bound">ys</a><a id="4362" class="Symbol">)</a> <a id="4364" class="Symbol">=</a> <a id="4366" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="4369" class="Symbol">λ</a> <a id="4371" class="Symbol">()</a>
  <a id="4376" class="Symbol">(</a><a id="4377" href="README.Design.Decidability.html#4377" class="Bound">x</a> <a id="4379" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="4381" href="README.Design.Decidability.html#4381" class="Bound">xs</a><a id="4383" class="Symbol">)</a> <a id="4385" href="README.Design.Decidability.html#4264" class="Function Operator">≟ᴸᴬ</a> <a id="4389" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>       <a id="4398" class="Symbol">=</a> <a id="4400" href="Relation.Nullary.Decidable.Core.html#1664" class="InductiveConstructor">no</a> <a id="4403" class="Symbol">λ</a> <a id="4405" class="Symbol">()</a>
  <a id="4410" class="Symbol">(</a><a id="4411" href="README.Design.Decidability.html#4411" class="Bound">x</a> <a id="4413" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="4415" href="README.Design.Decidability.html#4415" class="Bound">xs</a><a id="4417" class="Symbol">)</a> <a id="4419" href="README.Design.Decidability.html#4264" class="Function Operator">≟ᴸᴬ</a> <a id="4423" class="Symbol">(</a><a id="4424" href="README.Design.Decidability.html#4424" class="Bound">y</a> <a id="4426" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="4428" href="README.Design.Decidability.html#4428" class="Bound">ys</a><a id="4430" class="Symbol">)</a> <a id="4432" class="Symbol">=</a> <a id="4434" href="Relation.Nary.html#2983" class="Function">≟-mapₙ</a> <a id="4441" class="Number">2</a> <a id="4443" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">_∷_</a> <a id="4447" href="Data.List.Properties.html#2315" class="Function">∷-injective</a> <a id="4459" class="Symbol">(</a><a id="4460" href="README.Design.Decidability.html#4411" class="Bound">x</a> <a id="4462" href="README.Design.Decidability.html#4223" class="Bound Operator">≟ᴬ</a> <a id="4465" href="README.Design.Decidability.html#4424" class="Bound">y</a><a id="4466" class="Symbol">)</a> <a id="4468" class="Symbol">(</a><a id="4469" href="README.Design.Decidability.html#4415" class="Bound">xs</a> <a id="4472" href="README.Design.Decidability.html#4264" class="Function Operator">≟ᴸᴬ</a> <a id="4476" href="README.Design.Decidability.html#4428" class="Bound">ys</a><a id="4478" class="Symbol">)</a>
</pre></body></html>